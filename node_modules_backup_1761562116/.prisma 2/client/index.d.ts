
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model RolePermission
 * 
 */
export type RolePermission = $Result.DefaultSelection<Prisma.$RolePermissionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model ClientEmployee
 * 
 */
export type ClientEmployee = $Result.DefaultSelection<Prisma.$ClientEmployeePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Manual
 * 
 */
export type Manual = $Result.DefaultSelection<Prisma.$ManualPayload>
/**
 * Model ManualAttachment
 * 
 */
export type ManualAttachment = $Result.DefaultSelection<Prisma.$ManualAttachmentPayload>
/**
 * Model ManualVersion
 * 
 */
export type ManualVersion = $Result.DefaultSelection<Prisma.$ManualVersionPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model AuditTrail
 * 
 */
export type AuditTrail = $Result.DefaultSelection<Prisma.$AuditTrailPayload>
/**
 * Model SmtpConfig
 * 
 */
export type SmtpConfig = $Result.DefaultSelection<Prisma.$SmtpConfigPayload>
/**
 * Model JobRun
 * 
 */
export type JobRun = $Result.DefaultSelection<Prisma.$JobRunPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model SMTPAccount
 * 
 */
export type SMTPAccount = $Result.DefaultSelection<Prisma.$SMTPAccountPayload>
/**
 * Model NotificationTemplate
 * 
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>
/**
 * Model NotificationLog
 * 
 */
export type NotificationLog = $Result.DefaultSelection<Prisma.$NotificationLogPayload>
/**
 * Model ScheduledNotification
 * 
 */
export type ScheduledNotification = $Result.DefaultSelection<Prisma.$ScheduledNotificationPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model SystemBackup
 * 
 */
export type SystemBackup = $Result.DefaultSelection<Prisma.$SystemBackupPayload>
/**
 * Model SystemUpdate
 * 
 */
export type SystemUpdate = $Result.DefaultSelection<Prisma.$SystemUpdatePayload>
/**
 * Model StorageConfig
 * 
 */
export type StorageConfig = $Result.DefaultSelection<Prisma.$StorageConfigPayload>
/**
 * Model Impuesto
 * 
 */
export type Impuesto = $Result.DefaultSelection<Prisma.$ImpuestoPayload>
/**
 * Model ObligacionFiscal
 * 
 */
export type ObligacionFiscal = $Result.DefaultSelection<Prisma.$ObligacionFiscalPayload>
/**
 * Model CalendarioAEAT
 * 
 */
export type CalendarioAEAT = $Result.DefaultSelection<Prisma.$CalendarioAEATPayload>
/**
 * Model Declaracion
 * 
 */
export type Declaracion = $Result.DefaultSelection<Prisma.$DeclaracionPayload>
/**
 * Model Notificacion
 * 
 */
export type Notificacion = $Result.DefaultSelection<Prisma.$NotificacionPayload>
/**
 * Model taxModel
 * 
 */
export type taxModel = $Result.DefaultSelection<Prisma.$taxModelPayload>
/**
 * Model taxPeriod
 * 
 */
export type taxPeriod = $Result.DefaultSelection<Prisma.$taxPeriodPayload>
/**
 * Model clientTax
 * 
 */
export type clientTax = $Result.DefaultSelection<Prisma.$clientTaxPayload>
/**
 * Model taxFile
 * 
 */
export type taxFile = $Result.DefaultSelection<Prisma.$taxFilePayload>
/**
 * Model clientTaxRequirement
 * 
 */
export type clientTaxRequirement = $Result.DefaultSelection<Prisma.$clientTaxRequirementPayload>
/**
 * Model fiscalPeriod
 * 
 */
export type fiscalPeriod = $Result.DefaultSelection<Prisma.$fiscalPeriodPayload>
/**
 * Model clientTaxFiling
 * 
 */
export type clientTaxFiling = $Result.DefaultSelection<Prisma.$clientTaxFilingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClientType: {
  AUTONOMO: 'AUTONOMO',
  EMPRESA: 'EMPRESA',
  PARTICULAR: 'PARTICULAR'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const TaskPriority: {
  BAJA: 'BAJA',
  MEDIA: 'MEDIA',
  ALTA: 'ALTA'
};

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]


export const TaskStatus: {
  PENDIENTE: 'PENDIENTE',
  EN_PROGRESO: 'EN_PROGRESO',
  COMPLETADA: 'COMPLETADA'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const TaskVisibility: {
  GENERAL: 'GENERAL',
  PERSONAL: 'PERSONAL'
};

export type TaskVisibility = (typeof TaskVisibility)[keyof typeof TaskVisibility]


export const ManualStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED'
};

export type ManualStatus = (typeof ManualStatus)[keyof typeof ManualStatus]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]


export const BackupStatus: {
  CREATING: 'CREATING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  RESTORING: 'RESTORING',
  RESTORED: 'RESTORED'
};

export type BackupStatus = (typeof BackupStatus)[keyof typeof BackupStatus]


export const UpdateStatus: {
  CHECKING: 'CHECKING',
  BACKING_UP: 'BACKING_UP',
  DOWNLOADING: 'DOWNLOADING',
  INSTALLING: 'INSTALLING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  ROLLED_BACK: 'ROLLED_BACK'
};

export type UpdateStatus = (typeof UpdateStatus)[keyof typeof UpdateStatus]


export const StorageType: {
  LOCAL: 'LOCAL',
  FTP: 'FTP',
  SMB: 'SMB'
};

export type StorageType = (typeof StorageType)[keyof typeof StorageType]


export const Periodicidad: {
  MENSUAL: 'MENSUAL',
  TRIMESTRAL: 'TRIMESTRAL',
  ANUAL: 'ANUAL'
};

export type Periodicidad = (typeof Periodicidad)[keyof typeof Periodicidad]


export const EstadoDeclaracion: {
  PENDIENTE: 'PENDIENTE',
  CALCULADO: 'CALCULADO',
  PRESENTADO: 'PRESENTADO'
};

export type EstadoDeclaracion = (typeof EstadoDeclaracion)[keyof typeof EstadoDeclaracion]


export const TipoNotificacion: {
  SOLICITUD_INFO: 'SOLICITUD_INFO',
  CONFIRMACION_PRESENTACION: 'CONFIRMACION_PRESENTACION'
};

export type TipoNotificacion = (typeof TipoNotificacion)[keyof typeof TipoNotificacion]

}

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type TaskPriority = $Enums.TaskPriority

export const TaskPriority: typeof $Enums.TaskPriority

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type TaskVisibility = $Enums.TaskVisibility

export const TaskVisibility: typeof $Enums.TaskVisibility

export type ManualStatus = $Enums.ManualStatus

export const ManualStatus: typeof $Enums.ManualStatus

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

export type BackupStatus = $Enums.BackupStatus

export const BackupStatus: typeof $Enums.BackupStatus

export type UpdateStatus = $Enums.UpdateStatus

export const UpdateStatus: typeof $Enums.UpdateStatus

export type StorageType = $Enums.StorageType

export const StorageType: typeof $Enums.StorageType

export type Periodicidad = $Enums.Periodicidad

export const Periodicidad: typeof $Enums.Periodicidad

export type EstadoDeclaracion = $Enums.EstadoDeclaracion

export const EstadoDeclaracion: typeof $Enums.EstadoDeclaracion

export type TipoNotificacion = $Enums.TipoNotificacion

export const TipoNotificacion: typeof $Enums.TipoNotificacion

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rolePermission`: Exposes CRUD operations for the **RolePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RolePermissions
    * const rolePermissions = await prisma.rolePermission.findMany()
    * ```
    */
  get rolePermission(): Prisma.RolePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientEmployee`: Exposes CRUD operations for the **ClientEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientEmployees
    * const clientEmployees = await prisma.clientEmployee.findMany()
    * ```
    */
  get clientEmployee(): Prisma.ClientEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manual`: Exposes CRUD operations for the **Manual** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manuals
    * const manuals = await prisma.manual.findMany()
    * ```
    */
  get manual(): Prisma.ManualDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualAttachment`: Exposes CRUD operations for the **ManualAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualAttachments
    * const manualAttachments = await prisma.manualAttachment.findMany()
    * ```
    */
  get manualAttachment(): Prisma.ManualAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manualVersion`: Exposes CRUD operations for the **ManualVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManualVersions
    * const manualVersions = await prisma.manualVersion.findMany()
    * ```
    */
  get manualVersion(): Prisma.ManualVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditTrail`: Exposes CRUD operations for the **AuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditTrails
    * const auditTrails = await prisma.auditTrail.findMany()
    * ```
    */
  get auditTrail(): Prisma.AuditTrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.smtpConfig`: Exposes CRUD operations for the **SmtpConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmtpConfigs
    * const smtpConfigs = await prisma.smtpConfig.findMany()
    * ```
    */
  get smtpConfig(): Prisma.SmtpConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobRun`: Exposes CRUD operations for the **JobRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobRuns
    * const jobRuns = await prisma.jobRun.findMany()
    * ```
    */
  get jobRun(): Prisma.JobRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sMTPAccount`: Exposes CRUD operations for the **SMTPAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SMTPAccounts
    * const sMTPAccounts = await prisma.sMTPAccount.findMany()
    * ```
    */
  get sMTPAccount(): Prisma.SMTPAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTemplates
    * const notificationTemplates = await prisma.notificationTemplate.findMany()
    * ```
    */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationLog`: Exposes CRUD operations for the **NotificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationLogs
    * const notificationLogs = await prisma.notificationLog.findMany()
    * ```
    */
  get notificationLog(): Prisma.NotificationLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledNotification`: Exposes CRUD operations for the **ScheduledNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledNotifications
    * const scheduledNotifications = await prisma.scheduledNotification.findMany()
    * ```
    */
  get scheduledNotification(): Prisma.ScheduledNotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemBackup`: Exposes CRUD operations for the **SystemBackup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemBackups
    * const systemBackups = await prisma.systemBackup.findMany()
    * ```
    */
  get systemBackup(): Prisma.SystemBackupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemUpdate`: Exposes CRUD operations for the **SystemUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemUpdates
    * const systemUpdates = await prisma.systemUpdate.findMany()
    * ```
    */
  get systemUpdate(): Prisma.SystemUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storageConfig`: Exposes CRUD operations for the **StorageConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageConfigs
    * const storageConfigs = await prisma.storageConfig.findMany()
    * ```
    */
  get storageConfig(): Prisma.StorageConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.impuesto`: Exposes CRUD operations for the **Impuesto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Impuestos
    * const impuestos = await prisma.impuesto.findMany()
    * ```
    */
  get impuesto(): Prisma.ImpuestoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.obligacionFiscal`: Exposes CRUD operations for the **ObligacionFiscal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObligacionFiscals
    * const obligacionFiscals = await prisma.obligacionFiscal.findMany()
    * ```
    */
  get obligacionFiscal(): Prisma.ObligacionFiscalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendarioAEAT`: Exposes CRUD operations for the **CalendarioAEAT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CalendarioAEATS
    * const calendarioAEATS = await prisma.calendarioAEAT.findMany()
    * ```
    */
  get calendarioAEAT(): Prisma.CalendarioAEATDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.declaracion`: Exposes CRUD operations for the **Declaracion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Declaracions
    * const declaracions = await prisma.declaracion.findMany()
    * ```
    */
  get declaracion(): Prisma.DeclaracionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificacion`: Exposes CRUD operations for the **Notificacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notificacions
    * const notificacions = await prisma.notificacion.findMany()
    * ```
    */
  get notificacion(): Prisma.NotificacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxModel`: Exposes CRUD operations for the **taxModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxModels
    * const taxModels = await prisma.taxModel.findMany()
    * ```
    */
  get taxModel(): Prisma.taxModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxPeriod`: Exposes CRUD operations for the **taxPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxPeriods
    * const taxPeriods = await prisma.taxPeriod.findMany()
    * ```
    */
  get taxPeriod(): Prisma.taxPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientTax`: Exposes CRUD operations for the **clientTax** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientTaxes
    * const clientTaxes = await prisma.clientTax.findMany()
    * ```
    */
  get clientTax(): Prisma.clientTaxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxFile`: Exposes CRUD operations for the **taxFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxFiles
    * const taxFiles = await prisma.taxFile.findMany()
    * ```
    */
  get taxFile(): Prisma.taxFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientTaxRequirement`: Exposes CRUD operations for the **clientTaxRequirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientTaxRequirements
    * const clientTaxRequirements = await prisma.clientTaxRequirement.findMany()
    * ```
    */
  get clientTaxRequirement(): Prisma.clientTaxRequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fiscalPeriod`: Exposes CRUD operations for the **fiscalPeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FiscalPeriods
    * const fiscalPeriods = await prisma.fiscalPeriod.findMany()
    * ```
    */
  get fiscalPeriod(): Prisma.fiscalPeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientTaxFiling`: Exposes CRUD operations for the **clientTaxFiling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientTaxFilings
    * const clientTaxFilings = await prisma.clientTaxFiling.findMany()
    * ```
    */
  get clientTaxFiling(): Prisma.clientTaxFilingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.17.1
   * Query Engine version: 272a37d34178c2894197e17273bf937f25acdeac
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    Permission: 'Permission',
    RolePermission: 'RolePermission',
    User: 'User',
    Client: 'Client',
    ClientEmployee: 'ClientEmployee',
    Task: 'Task',
    Manual: 'Manual',
    ManualAttachment: 'ManualAttachment',
    ManualVersion: 'ManualVersion',
    ActivityLog: 'ActivityLog',
    AuditTrail: 'AuditTrail',
    SmtpConfig: 'SmtpConfig',
    JobRun: 'JobRun',
    SystemSettings: 'SystemSettings',
    SMTPAccount: 'SMTPAccount',
    NotificationTemplate: 'NotificationTemplate',
    NotificationLog: 'NotificationLog',
    ScheduledNotification: 'ScheduledNotification',
    SystemConfig: 'SystemConfig',
    SystemBackup: 'SystemBackup',
    SystemUpdate: 'SystemUpdate',
    StorageConfig: 'StorageConfig',
    Impuesto: 'Impuesto',
    ObligacionFiscal: 'ObligacionFiscal',
    CalendarioAEAT: 'CalendarioAEAT',
    Declaracion: 'Declaracion',
    Notificacion: 'Notificacion',
    taxModel: 'taxModel',
    taxPeriod: 'taxPeriod',
    clientTax: 'clientTax',
    taxFile: 'taxFile',
    clientTaxRequirement: 'clientTaxRequirement',
    fiscalPeriod: 'fiscalPeriod',
    clientTaxFiling: 'clientTaxFiling'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "permission" | "rolePermission" | "user" | "client" | "clientEmployee" | "task" | "manual" | "manualAttachment" | "manualVersion" | "activityLog" | "auditTrail" | "smtpConfig" | "jobRun" | "systemSettings" | "sMTPAccount" | "notificationTemplate" | "notificationLog" | "scheduledNotification" | "systemConfig" | "systemBackup" | "systemUpdate" | "storageConfig" | "impuesto" | "obligacionFiscal" | "calendarioAEAT" | "declaracion" | "notificacion" | "taxModel" | "taxPeriod" | "clientTax" | "taxFile" | "clientTaxRequirement" | "fiscalPeriod" | "clientTaxFiling"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      RolePermission: {
        payload: Prisma.$RolePermissionPayload<ExtArgs>
        fields: Prisma.RolePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findFirst: {
            args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          findMany: {
            args: Prisma.RolePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
          }
          create: {
            args: Prisma.RolePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          createMany: {
            args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RolePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          update: {
            args: Prisma.RolePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          deleteMany: {
            args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePermissionPayload>
          }
          aggregate: {
            args: Prisma.RolePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRolePermission>
          }
          groupBy: {
            args: Prisma.RolePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<RolePermissionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      ClientEmployee: {
        payload: Prisma.$ClientEmployeePayload<ExtArgs>
        fields: Prisma.ClientEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          findFirst: {
            args: Prisma.ClientEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          findMany: {
            args: Prisma.ClientEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>[]
          }
          create: {
            args: Prisma.ClientEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          createMany: {
            args: Prisma.ClientEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          update: {
            args: Prisma.ClientEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          deleteMany: {
            args: Prisma.ClientEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEmployeePayload>
          }
          aggregate: {
            args: Prisma.ClientEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientEmployee>
          }
          groupBy: {
            args: Prisma.ClientEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<ClientEmployeeCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Manual: {
        payload: Prisma.$ManualPayload<ExtArgs>
        fields: Prisma.ManualFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          findFirst: {
            args: Prisma.ManualFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          findMany: {
            args: Prisma.ManualFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>[]
          }
          create: {
            args: Prisma.ManualCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          createMany: {
            args: Prisma.ManualCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManualDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          update: {
            args: Prisma.ManualUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          deleteMany: {
            args: Prisma.ManualDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManualUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualPayload>
          }
          aggregate: {
            args: Prisma.ManualAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManual>
          }
          groupBy: {
            args: Prisma.ManualGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualCountArgs<ExtArgs>
            result: $Utils.Optional<ManualCountAggregateOutputType> | number
          }
        }
      }
      ManualAttachment: {
        payload: Prisma.$ManualAttachmentPayload<ExtArgs>
        fields: Prisma.ManualAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          findFirst: {
            args: Prisma.ManualAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          findMany: {
            args: Prisma.ManualAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>[]
          }
          create: {
            args: Prisma.ManualAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          createMany: {
            args: Prisma.ManualAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManualAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          update: {
            args: Prisma.ManualAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.ManualAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManualAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualAttachmentPayload>
          }
          aggregate: {
            args: Prisma.ManualAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualAttachment>
          }
          groupBy: {
            args: Prisma.ManualAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<ManualAttachmentCountAggregateOutputType> | number
          }
        }
      }
      ManualVersion: {
        payload: Prisma.$ManualVersionPayload<ExtArgs>
        fields: Prisma.ManualVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManualVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManualVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          findFirst: {
            args: Prisma.ManualVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManualVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          findMany: {
            args: Prisma.ManualVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>[]
          }
          create: {
            args: Prisma.ManualVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          createMany: {
            args: Prisma.ManualVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManualVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          update: {
            args: Prisma.ManualVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          deleteMany: {
            args: Prisma.ManualVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManualVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManualVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManualVersionPayload>
          }
          aggregate: {
            args: Prisma.ManualVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManualVersion>
          }
          groupBy: {
            args: Prisma.ManualVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManualVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManualVersionCountArgs<ExtArgs>
            result: $Utils.Optional<ManualVersionCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      AuditTrail: {
        payload: Prisma.$AuditTrailPayload<ExtArgs>
        fields: Prisma.AuditTrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditTrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditTrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findFirst: {
            args: Prisma.AuditTrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditTrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findMany: {
            args: Prisma.AuditTrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          create: {
            args: Prisma.AuditTrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          createMany: {
            args: Prisma.AuditTrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditTrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          update: {
            args: Prisma.AuditTrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          deleteMany: {
            args: Prisma.AuditTrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditTrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditTrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          aggregate: {
            args: Prisma.AuditTrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditTrail>
          }
          groupBy: {
            args: Prisma.AuditTrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditTrailCountArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailCountAggregateOutputType> | number
          }
        }
      }
      SmtpConfig: {
        payload: Prisma.$SmtpConfigPayload<ExtArgs>
        fields: Prisma.SmtpConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SmtpConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SmtpConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          findFirst: {
            args: Prisma.SmtpConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SmtpConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          findMany: {
            args: Prisma.SmtpConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>[]
          }
          create: {
            args: Prisma.SmtpConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          createMany: {
            args: Prisma.SmtpConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SmtpConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          update: {
            args: Prisma.SmtpConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          deleteMany: {
            args: Prisma.SmtpConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SmtpConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SmtpConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SmtpConfigPayload>
          }
          aggregate: {
            args: Prisma.SmtpConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSmtpConfig>
          }
          groupBy: {
            args: Prisma.SmtpConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SmtpConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SmtpConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SmtpConfigCountAggregateOutputType> | number
          }
        }
      }
      JobRun: {
        payload: Prisma.$JobRunPayload<ExtArgs>
        fields: Prisma.JobRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          findFirst: {
            args: Prisma.JobRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          findMany: {
            args: Prisma.JobRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>[]
          }
          create: {
            args: Prisma.JobRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          createMany: {
            args: Prisma.JobRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          update: {
            args: Prisma.JobRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          deleteMany: {
            args: Prisma.JobRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobRunPayload>
          }
          aggregate: {
            args: Prisma.JobRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobRun>
          }
          groupBy: {
            args: Prisma.JobRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobRunCountArgs<ExtArgs>
            result: $Utils.Optional<JobRunCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      SMTPAccount: {
        payload: Prisma.$SMTPAccountPayload<ExtArgs>
        fields: Prisma.SMTPAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SMTPAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SMTPAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          findFirst: {
            args: Prisma.SMTPAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SMTPAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          findMany: {
            args: Prisma.SMTPAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>[]
          }
          create: {
            args: Prisma.SMTPAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          createMany: {
            args: Prisma.SMTPAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SMTPAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          update: {
            args: Prisma.SMTPAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          deleteMany: {
            args: Prisma.SMTPAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SMTPAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SMTPAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SMTPAccountPayload>
          }
          aggregate: {
            args: Prisma.SMTPAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSMTPAccount>
          }
          groupBy: {
            args: Prisma.SMTPAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SMTPAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SMTPAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SMTPAccountCountAggregateOutputType> | number
          }
        }
      }
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>
        fields: Prisma.NotificationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTemplate>
          }
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number
          }
        }
      }
      NotificationLog: {
        payload: Prisma.$NotificationLogPayload<ExtArgs>
        fields: Prisma.NotificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findFirst: {
            args: Prisma.NotificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          findMany: {
            args: Prisma.NotificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>[]
          }
          create: {
            args: Prisma.NotificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          createMany: {
            args: Prisma.NotificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          update: {
            args: Prisma.NotificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          deleteMany: {
            args: Prisma.NotificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationLogPayload>
          }
          aggregate: {
            args: Prisma.NotificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationLog>
          }
          groupBy: {
            args: Prisma.NotificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationLogCountAggregateOutputType> | number
          }
        }
      }
      ScheduledNotification: {
        payload: Prisma.$ScheduledNotificationPayload<ExtArgs>
        fields: Prisma.ScheduledNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          findFirst: {
            args: Prisma.ScheduledNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          findMany: {
            args: Prisma.ScheduledNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>[]
          }
          create: {
            args: Prisma.ScheduledNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          createMany: {
            args: Prisma.ScheduledNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduledNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          update: {
            args: Prisma.ScheduledNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledNotificationPayload>
          }
          aggregate: {
            args: Prisma.ScheduledNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledNotification>
          }
          groupBy: {
            args: Prisma.ScheduledNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduledNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledNotificationCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      SystemBackup: {
        payload: Prisma.$SystemBackupPayload<ExtArgs>
        fields: Prisma.SystemBackupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemBackupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemBackupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          findFirst: {
            args: Prisma.SystemBackupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemBackupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          findMany: {
            args: Prisma.SystemBackupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>[]
          }
          create: {
            args: Prisma.SystemBackupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          createMany: {
            args: Prisma.SystemBackupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemBackupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          update: {
            args: Prisma.SystemBackupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          deleteMany: {
            args: Prisma.SystemBackupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemBackupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemBackupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemBackupPayload>
          }
          aggregate: {
            args: Prisma.SystemBackupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemBackup>
          }
          groupBy: {
            args: Prisma.SystemBackupGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemBackupGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemBackupCountArgs<ExtArgs>
            result: $Utils.Optional<SystemBackupCountAggregateOutputType> | number
          }
        }
      }
      SystemUpdate: {
        payload: Prisma.$SystemUpdatePayload<ExtArgs>
        fields: Prisma.SystemUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          findFirst: {
            args: Prisma.SystemUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          findMany: {
            args: Prisma.SystemUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>[]
          }
          create: {
            args: Prisma.SystemUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          createMany: {
            args: Prisma.SystemUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          update: {
            args: Prisma.SystemUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          deleteMany: {
            args: Prisma.SystemUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemUpdatePayload>
          }
          aggregate: {
            args: Prisma.SystemUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemUpdate>
          }
          groupBy: {
            args: Prisma.SystemUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<SystemUpdateCountAggregateOutputType> | number
          }
        }
      }
      StorageConfig: {
        payload: Prisma.$StorageConfigPayload<ExtArgs>
        fields: Prisma.StorageConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          findFirst: {
            args: Prisma.StorageConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          findMany: {
            args: Prisma.StorageConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>[]
          }
          create: {
            args: Prisma.StorageConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          createMany: {
            args: Prisma.StorageConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StorageConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          update: {
            args: Prisma.StorageConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          deleteMany: {
            args: Prisma.StorageConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StorageConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageConfigPayload>
          }
          aggregate: {
            args: Prisma.StorageConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageConfig>
          }
          groupBy: {
            args: Prisma.StorageConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageConfigCountArgs<ExtArgs>
            result: $Utils.Optional<StorageConfigCountAggregateOutputType> | number
          }
        }
      }
      Impuesto: {
        payload: Prisma.$ImpuestoPayload<ExtArgs>
        fields: Prisma.ImpuestoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImpuestoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImpuestoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          findFirst: {
            args: Prisma.ImpuestoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImpuestoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          findMany: {
            args: Prisma.ImpuestoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>[]
          }
          create: {
            args: Prisma.ImpuestoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          createMany: {
            args: Prisma.ImpuestoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImpuestoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          update: {
            args: Prisma.ImpuestoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          deleteMany: {
            args: Prisma.ImpuestoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImpuestoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImpuestoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImpuestoPayload>
          }
          aggregate: {
            args: Prisma.ImpuestoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImpuesto>
          }
          groupBy: {
            args: Prisma.ImpuestoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImpuestoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImpuestoCountArgs<ExtArgs>
            result: $Utils.Optional<ImpuestoCountAggregateOutputType> | number
          }
        }
      }
      ObligacionFiscal: {
        payload: Prisma.$ObligacionFiscalPayload<ExtArgs>
        fields: Prisma.ObligacionFiscalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObligacionFiscalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObligacionFiscalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          findFirst: {
            args: Prisma.ObligacionFiscalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObligacionFiscalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          findMany: {
            args: Prisma.ObligacionFiscalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>[]
          }
          create: {
            args: Prisma.ObligacionFiscalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          createMany: {
            args: Prisma.ObligacionFiscalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ObligacionFiscalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          update: {
            args: Prisma.ObligacionFiscalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          deleteMany: {
            args: Prisma.ObligacionFiscalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObligacionFiscalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObligacionFiscalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObligacionFiscalPayload>
          }
          aggregate: {
            args: Prisma.ObligacionFiscalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObligacionFiscal>
          }
          groupBy: {
            args: Prisma.ObligacionFiscalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObligacionFiscalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObligacionFiscalCountArgs<ExtArgs>
            result: $Utils.Optional<ObligacionFiscalCountAggregateOutputType> | number
          }
        }
      }
      CalendarioAEAT: {
        payload: Prisma.$CalendarioAEATPayload<ExtArgs>
        fields: Prisma.CalendarioAEATFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CalendarioAEATFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CalendarioAEATFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          findFirst: {
            args: Prisma.CalendarioAEATFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CalendarioAEATFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          findMany: {
            args: Prisma.CalendarioAEATFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>[]
          }
          create: {
            args: Prisma.CalendarioAEATCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          createMany: {
            args: Prisma.CalendarioAEATCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CalendarioAEATDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          update: {
            args: Prisma.CalendarioAEATUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          deleteMany: {
            args: Prisma.CalendarioAEATDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CalendarioAEATUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CalendarioAEATUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CalendarioAEATPayload>
          }
          aggregate: {
            args: Prisma.CalendarioAEATAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendarioAEAT>
          }
          groupBy: {
            args: Prisma.CalendarioAEATGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarioAEATGroupByOutputType>[]
          }
          count: {
            args: Prisma.CalendarioAEATCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarioAEATCountAggregateOutputType> | number
          }
        }
      }
      Declaracion: {
        payload: Prisma.$DeclaracionPayload<ExtArgs>
        fields: Prisma.DeclaracionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeclaracionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeclaracionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          findFirst: {
            args: Prisma.DeclaracionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeclaracionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          findMany: {
            args: Prisma.DeclaracionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>[]
          }
          create: {
            args: Prisma.DeclaracionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          createMany: {
            args: Prisma.DeclaracionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeclaracionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          update: {
            args: Prisma.DeclaracionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          deleteMany: {
            args: Prisma.DeclaracionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeclaracionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeclaracionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeclaracionPayload>
          }
          aggregate: {
            args: Prisma.DeclaracionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeclaracion>
          }
          groupBy: {
            args: Prisma.DeclaracionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeclaracionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeclaracionCountArgs<ExtArgs>
            result: $Utils.Optional<DeclaracionCountAggregateOutputType> | number
          }
        }
      }
      Notificacion: {
        payload: Prisma.$NotificacionPayload<ExtArgs>
        fields: Prisma.NotificacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findFirst: {
            args: Prisma.NotificacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          findMany: {
            args: Prisma.NotificacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>[]
          }
          create: {
            args: Prisma.NotificacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          createMany: {
            args: Prisma.NotificacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          update: {
            args: Prisma.NotificacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          deleteMany: {
            args: Prisma.NotificacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificacionPayload>
          }
          aggregate: {
            args: Prisma.NotificacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificacion>
          }
          groupBy: {
            args: Prisma.NotificacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificacionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificacionCountAggregateOutputType> | number
          }
        }
      }
      taxModel: {
        payload: Prisma.$taxModelPayload<ExtArgs>
        fields: Prisma.taxModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.taxModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.taxModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          findFirst: {
            args: Prisma.taxModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.taxModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          findMany: {
            args: Prisma.taxModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>[]
          }
          create: {
            args: Prisma.taxModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          createMany: {
            args: Prisma.taxModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.taxModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          update: {
            args: Prisma.taxModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          deleteMany: {
            args: Prisma.taxModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.taxModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.taxModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxModelPayload>
          }
          aggregate: {
            args: Prisma.TaxModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxModel>
          }
          groupBy: {
            args: Prisma.taxModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.taxModelCountArgs<ExtArgs>
            result: $Utils.Optional<TaxModelCountAggregateOutputType> | number
          }
        }
      }
      taxPeriod: {
        payload: Prisma.$taxPeriodPayload<ExtArgs>
        fields: Prisma.taxPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.taxPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.taxPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          findFirst: {
            args: Prisma.taxPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.taxPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          findMany: {
            args: Prisma.taxPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>[]
          }
          create: {
            args: Prisma.taxPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          createMany: {
            args: Prisma.taxPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.taxPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          update: {
            args: Prisma.taxPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          deleteMany: {
            args: Prisma.taxPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.taxPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.taxPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxPeriodPayload>
          }
          aggregate: {
            args: Prisma.TaxPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxPeriod>
          }
          groupBy: {
            args: Prisma.taxPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.taxPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<TaxPeriodCountAggregateOutputType> | number
          }
        }
      }
      clientTax: {
        payload: Prisma.$clientTaxPayload<ExtArgs>
        fields: Prisma.clientTaxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientTaxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientTaxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          findFirst: {
            args: Prisma.clientTaxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientTaxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          findMany: {
            args: Prisma.clientTaxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>[]
          }
          create: {
            args: Prisma.clientTaxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          createMany: {
            args: Prisma.clientTaxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientTaxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          update: {
            args: Prisma.clientTaxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          deleteMany: {
            args: Prisma.clientTaxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientTaxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientTaxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxPayload>
          }
          aggregate: {
            args: Prisma.ClientTaxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientTax>
          }
          groupBy: {
            args: Prisma.clientTaxGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientTaxCountArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxCountAggregateOutputType> | number
          }
        }
      }
      taxFile: {
        payload: Prisma.$taxFilePayload<ExtArgs>
        fields: Prisma.taxFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.taxFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.taxFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          findFirst: {
            args: Prisma.taxFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.taxFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          findMany: {
            args: Prisma.taxFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>[]
          }
          create: {
            args: Prisma.taxFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          createMany: {
            args: Prisma.taxFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.taxFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          update: {
            args: Prisma.taxFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          deleteMany: {
            args: Prisma.taxFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.taxFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.taxFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$taxFilePayload>
          }
          aggregate: {
            args: Prisma.TaxFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxFile>
          }
          groupBy: {
            args: Prisma.taxFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.taxFileCountArgs<ExtArgs>
            result: $Utils.Optional<TaxFileCountAggregateOutputType> | number
          }
        }
      }
      clientTaxRequirement: {
        payload: Prisma.$clientTaxRequirementPayload<ExtArgs>
        fields: Prisma.clientTaxRequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientTaxRequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientTaxRequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          findFirst: {
            args: Prisma.clientTaxRequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientTaxRequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          findMany: {
            args: Prisma.clientTaxRequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>[]
          }
          create: {
            args: Prisma.clientTaxRequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          createMany: {
            args: Prisma.clientTaxRequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientTaxRequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          update: {
            args: Prisma.clientTaxRequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          deleteMany: {
            args: Prisma.clientTaxRequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientTaxRequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientTaxRequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxRequirementPayload>
          }
          aggregate: {
            args: Prisma.ClientTaxRequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientTaxRequirement>
          }
          groupBy: {
            args: Prisma.clientTaxRequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxRequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientTaxRequirementCountArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxRequirementCountAggregateOutputType> | number
          }
        }
      }
      fiscalPeriod: {
        payload: Prisma.$fiscalPeriodPayload<ExtArgs>
        fields: Prisma.fiscalPeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fiscalPeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fiscalPeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          findFirst: {
            args: Prisma.fiscalPeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fiscalPeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          findMany: {
            args: Prisma.fiscalPeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>[]
          }
          create: {
            args: Prisma.fiscalPeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          createMany: {
            args: Prisma.fiscalPeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fiscalPeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          update: {
            args: Prisma.fiscalPeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          deleteMany: {
            args: Prisma.fiscalPeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fiscalPeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fiscalPeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fiscalPeriodPayload>
          }
          aggregate: {
            args: Prisma.FiscalPeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiscalPeriod>
          }
          groupBy: {
            args: Prisma.fiscalPeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FiscalPeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.fiscalPeriodCountArgs<ExtArgs>
            result: $Utils.Optional<FiscalPeriodCountAggregateOutputType> | number
          }
        }
      }
      clientTaxFiling: {
        payload: Prisma.$clientTaxFilingPayload<ExtArgs>
        fields: Prisma.clientTaxFilingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientTaxFilingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientTaxFilingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          findFirst: {
            args: Prisma.clientTaxFilingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientTaxFilingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          findMany: {
            args: Prisma.clientTaxFilingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>[]
          }
          create: {
            args: Prisma.clientTaxFilingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          createMany: {
            args: Prisma.clientTaxFilingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientTaxFilingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          update: {
            args: Prisma.clientTaxFilingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          deleteMany: {
            args: Prisma.clientTaxFilingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientTaxFilingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientTaxFilingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientTaxFilingPayload>
          }
          aggregate: {
            args: Prisma.ClientTaxFilingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientTaxFiling>
          }
          groupBy: {
            args: Prisma.clientTaxFilingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxFilingGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientTaxFilingCountArgs<ExtArgs>
            result: $Utils.Optional<ClientTaxFilingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    permission?: PermissionOmit
    rolePermission?: RolePermissionOmit
    user?: UserOmit
    client?: ClientOmit
    clientEmployee?: ClientEmployeeOmit
    task?: TaskOmit
    manual?: ManualOmit
    manualAttachment?: ManualAttachmentOmit
    manualVersion?: ManualVersionOmit
    activityLog?: ActivityLogOmit
    auditTrail?: AuditTrailOmit
    smtpConfig?: SmtpConfigOmit
    jobRun?: JobRunOmit
    systemSettings?: SystemSettingsOmit
    sMTPAccount?: SMTPAccountOmit
    notificationTemplate?: NotificationTemplateOmit
    notificationLog?: NotificationLogOmit
    scheduledNotification?: ScheduledNotificationOmit
    systemConfig?: SystemConfigOmit
    systemBackup?: SystemBackupOmit
    systemUpdate?: SystemUpdateOmit
    storageConfig?: StorageConfigOmit
    impuesto?: ImpuestoOmit
    obligacionFiscal?: ObligacionFiscalOmit
    calendarioAEAT?: CalendarioAEATOmit
    declaracion?: DeclaracionOmit
    notificacion?: NotificacionOmit
    taxModel?: taxModelOmit
    taxPeriod?: taxPeriodOmit
    clientTax?: clientTaxOmit
    taxFile?: taxFileOmit
    clientTaxRequirement?: clientTaxRequirementOmit
    fiscalPeriod?: fiscalPeriodOmit
    clientTaxFiling?: clientTaxFilingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
    permissions: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
    permissions?: boolean | RoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    clientsManaged: number
    clientsAssigned: number
    tasksAssigned: number
    manualsAuthored: number
    activityLogs: number
    auditTrails: number
    smtpAccountsCreated: number
    notificationTemplatesCreated: number
    notificationsSent: number
    scheduledNotificationsCreated: number
    backupsCreated: number
    updatesInitiated: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientsManaged?: boolean | UserCountOutputTypeCountClientsManagedArgs
    clientsAssigned?: boolean | UserCountOutputTypeCountClientsAssignedArgs
    tasksAssigned?: boolean | UserCountOutputTypeCountTasksAssignedArgs
    manualsAuthored?: boolean | UserCountOutputTypeCountManualsAuthoredArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    auditTrails?: boolean | UserCountOutputTypeCountAuditTrailsArgs
    smtpAccountsCreated?: boolean | UserCountOutputTypeCountSmtpAccountsCreatedArgs
    notificationTemplatesCreated?: boolean | UserCountOutputTypeCountNotificationTemplatesCreatedArgs
    notificationsSent?: boolean | UserCountOutputTypeCountNotificationsSentArgs
    scheduledNotificationsCreated?: boolean | UserCountOutputTypeCountScheduledNotificationsCreatedArgs
    backupsCreated?: boolean | UserCountOutputTypeCountBackupsCreatedArgs
    updatesInitiated?: boolean | UserCountOutputTypeCountUpdatesInitiatedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClientsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManualsAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSmtpAccountsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMTPAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationTemplatesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScheduledNotificationsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledNotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBackupsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemBackupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatesInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemUpdateWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    tasks: number
    employees: number
    clientTaxes: number
    clientTaxRequirements: number
    taxFilings: number
    obligacionesFiscales: number
    notificaciones: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ClientCountOutputTypeCountTasksArgs
    employees?: boolean | ClientCountOutputTypeCountEmployeesArgs
    clientTaxes?: boolean | ClientCountOutputTypeCountClientTaxesArgs
    clientTaxRequirements?: boolean | ClientCountOutputTypeCountClientTaxRequirementsArgs
    taxFilings?: boolean | ClientCountOutputTypeCountTaxFilingsArgs
    obligacionesFiscales?: boolean | ClientCountOutputTypeCountObligacionesFiscalesArgs
    notificaciones?: boolean | ClientCountOutputTypeCountNotificacionesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEmployeeWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientTaxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountClientTaxRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxRequirementWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountTaxFilingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxFilingWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountObligacionesFiscalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObligacionFiscalWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountNotificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
  }


  /**
   * Count Type ManualCountOutputType
   */

  export type ManualCountOutputType = {
    attachments: number
    versions: number
  }

  export type ManualCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | ManualCountOutputTypeCountAttachmentsArgs
    versions?: boolean | ManualCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * ManualCountOutputType without action
   */
  export type ManualCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualCountOutputType
     */
    select?: ManualCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManualCountOutputType without action
   */
  export type ManualCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualAttachmentWhereInput
  }

  /**
   * ManualCountOutputType without action
   */
  export type ManualCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualVersionWhereInput
  }


  /**
   * Count Type SMTPAccountCountOutputType
   */

  export type SMTPAccountCountOutputType = {
    logs: number
    scheduled: number
  }

  export type SMTPAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | SMTPAccountCountOutputTypeCountLogsArgs
    scheduled?: boolean | SMTPAccountCountOutputTypeCountScheduledArgs
  }

  // Custom InputTypes
  /**
   * SMTPAccountCountOutputType without action
   */
  export type SMTPAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccountCountOutputType
     */
    select?: SMTPAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SMTPAccountCountOutputType without action
   */
  export type SMTPAccountCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * SMTPAccountCountOutputType without action
   */
  export type SMTPAccountCountOutputTypeCountScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledNotificationWhereInput
  }


  /**
   * Count Type NotificationTemplateCountOutputType
   */

  export type NotificationTemplateCountOutputType = {
    logs: number
    scheduled: number
  }

  export type NotificationTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | NotificationTemplateCountOutputTypeCountLogsArgs
    scheduled?: boolean | NotificationTemplateCountOutputTypeCountScheduledArgs
  }

  // Custom InputTypes
  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplateCountOutputType
     */
    select?: NotificationTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
  }

  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeCountScheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledNotificationWhereInput
  }


  /**
   * Count Type ImpuestoCountOutputType
   */

  export type ImpuestoCountOutputType = {
    obligaciones: number
  }

  export type ImpuestoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obligaciones?: boolean | ImpuestoCountOutputTypeCountObligacionesArgs
  }

  // Custom InputTypes
  /**
   * ImpuestoCountOutputType without action
   */
  export type ImpuestoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImpuestoCountOutputType
     */
    select?: ImpuestoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImpuestoCountOutputType without action
   */
  export type ImpuestoCountOutputTypeCountObligacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObligacionFiscalWhereInput
  }


  /**
   * Count Type ObligacionFiscalCountOutputType
   */

  export type ObligacionFiscalCountOutputType = {
    declaraciones: number
  }

  export type ObligacionFiscalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    declaraciones?: boolean | ObligacionFiscalCountOutputTypeCountDeclaracionesArgs
  }

  // Custom InputTypes
  /**
   * ObligacionFiscalCountOutputType without action
   */
  export type ObligacionFiscalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscalCountOutputType
     */
    select?: ObligacionFiscalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ObligacionFiscalCountOutputType without action
   */
  export type ObligacionFiscalCountOutputTypeCountDeclaracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeclaracionWhereInput
  }


  /**
   * Count Type CalendarioAEATCountOutputType
   */

  export type CalendarioAEATCountOutputType = {
    declaraciones: number
  }

  export type CalendarioAEATCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    declaraciones?: boolean | CalendarioAEATCountOutputTypeCountDeclaracionesArgs
  }

  // Custom InputTypes
  /**
   * CalendarioAEATCountOutputType without action
   */
  export type CalendarioAEATCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEATCountOutputType
     */
    select?: CalendarioAEATCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarioAEATCountOutputType without action
   */
  export type CalendarioAEATCountOutputTypeCountDeclaracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeclaracionWhereInput
  }


  /**
   * Count Type TaxModelCountOutputType
   */

  export type TaxModelCountOutputType = {
    periods: number
  }

  export type TaxModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | TaxModelCountOutputTypeCountPeriodsArgs
  }

  // Custom InputTypes
  /**
   * TaxModelCountOutputType without action
   */
  export type TaxModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxModelCountOutputType
     */
    select?: TaxModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxModelCountOutputType without action
   */
  export type TaxModelCountOutputTypeCountPeriodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taxPeriodWhereInput
  }


  /**
   * Count Type TaxPeriodCountOutputType
   */

  export type TaxPeriodCountOutputType = {
    clientTaxes: number
  }

  export type TaxPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientTaxes?: boolean | TaxPeriodCountOutputTypeCountClientTaxesArgs
  }

  // Custom InputTypes
  /**
   * TaxPeriodCountOutputType without action
   */
  export type TaxPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxPeriodCountOutputType
     */
    select?: TaxPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxPeriodCountOutputType without action
   */
  export type TaxPeriodCountOutputTypeCountClientTaxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxWhereInput
  }


  /**
   * Count Type ClientTaxCountOutputType
   */

  export type ClientTaxCountOutputType = {
    files: number
  }

  export type ClientTaxCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | ClientTaxCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * ClientTaxCountOutputType without action
   */
  export type ClientTaxCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientTaxCountOutputType
     */
    select?: ClientTaxCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientTaxCountOutputType without action
   */
  export type ClientTaxCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taxFileWhereInput
  }


  /**
   * Count Type FiscalPeriodCountOutputType
   */

  export type FiscalPeriodCountOutputType = {
    filings: number
  }

  export type FiscalPeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filings?: boolean | FiscalPeriodCountOutputTypeCountFilingsArgs
  }

  // Custom InputTypes
  /**
   * FiscalPeriodCountOutputType without action
   */
  export type FiscalPeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FiscalPeriodCountOutputType
     */
    select?: FiscalPeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FiscalPeriodCountOutputType without action
   */
  export type FiscalPeriodCountOutputTypeCountFilingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxFilingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isSystem: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isSystem: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isSystem?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isSystem: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>



  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isSystem?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isSystem" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    permissions?: boolean | Role$permissionsArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      permissions: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isSystem: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends Role$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, Role$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly isSystem: FieldRef<"Role", 'Boolean'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role.permissions
   */
  export type Role$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    resource: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    resource: string | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    resource: number
    action: number
    description: number
    createdAt: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    resource?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    resource?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    resource?: true
    action?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    id: string
    resource: string
    action: string
    description: string | null
    createdAt: Date
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resource?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>



  export type PermissionSelectScalar = {
    id?: boolean
    resource?: boolean
    action?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resource" | "action" | "description" | "createdAt", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$RolePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resource: string
      action: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly id: FieldRef<"Permission", 'String'>
    readonly resource: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
    readonly createdAt: FieldRef<"Permission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    cursor?: RolePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model RolePermission
   */

  export type AggregateRolePermission = {
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  export type RolePermissionMinAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionMaxAggregateOutputType = {
    id: string | null
    roleId: string | null
    permissionId: string | null
    createdAt: Date | null
  }

  export type RolePermissionCountAggregateOutputType = {
    id: number
    roleId: number
    permissionId: number
    createdAt: number
    _all: number
  }


  export type RolePermissionMinAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionMaxAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
  }

  export type RolePermissionCountAggregateInputType = {
    id?: true
    roleId?: true
    permissionId?: true
    createdAt?: true
    _all?: true
  }

  export type RolePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermission to aggregate.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RolePermissions
    **/
    _count?: true | RolePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolePermissionMaxAggregateInputType
  }

  export type GetRolePermissionAggregateType<T extends RolePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateRolePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolePermission[P]>
      : GetScalarType<T[P], AggregateRolePermission[P]>
  }




  export type RolePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolePermissionWhereInput
    orderBy?: RolePermissionOrderByWithAggregationInput | RolePermissionOrderByWithAggregationInput[]
    by: RolePermissionScalarFieldEnum[] | RolePermissionScalarFieldEnum
    having?: RolePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolePermissionCountAggregateInputType | true
    _min?: RolePermissionMinAggregateInputType
    _max?: RolePermissionMaxAggregateInputType
  }

  export type RolePermissionGroupByOutputType = {
    id: string
    roleId: string
    permissionId: string
    createdAt: Date
    _count: RolePermissionCountAggregateOutputType | null
    _min: RolePermissionMinAggregateOutputType | null
    _max: RolePermissionMaxAggregateOutputType | null
  }

  type GetRolePermissionGroupByPayload<T extends RolePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], RolePermissionGroupByOutputType[P]>
        }
      >
    >


  export type RolePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolePermission"]>



  export type RolePermissionSelectScalar = {
    id?: boolean
    roleId?: boolean
    permissionId?: boolean
    createdAt?: boolean
  }

  export type RolePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "permissionId" | "createdAt", ExtArgs["result"]["rolePermission"]>
  export type RolePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    permission?: boolean | PermissionDefaultArgs<ExtArgs>
  }

  export type $RolePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RolePermission"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      permission: Prisma.$PermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roleId: string
      permissionId: string
      createdAt: Date
    }, ExtArgs["result"]["rolePermission"]>
    composites: {}
  }

  type RolePermissionGetPayload<S extends boolean | null | undefined | RolePermissionDefaultArgs> = $Result.GetResult<Prisma.$RolePermissionPayload, S>

  type RolePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolePermissionCountAggregateInputType | true
    }

  export interface RolePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RolePermission'], meta: { name: 'RolePermission' } }
    /**
     * Find zero or one RolePermission that matches the filter.
     * @param {RolePermissionFindUniqueArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolePermissionFindUniqueArgs>(args: SelectSubset<T, RolePermissionFindUniqueArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RolePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolePermissionFindUniqueOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, RolePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolePermissionFindFirstArgs>(args?: SelectSubset<T, RolePermissionFindFirstArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RolePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindFirstOrThrowArgs} args - Arguments to find a RolePermission
     * @example
     * // Get one RolePermission
     * const rolePermission = await prisma.rolePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, RolePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RolePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany()
     * 
     * // Get first 10 RolePermissions
     * const rolePermissions = await prisma.rolePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolePermissionWithIdOnly = await prisma.rolePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolePermissionFindManyArgs>(args?: SelectSubset<T, RolePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RolePermission.
     * @param {RolePermissionCreateArgs} args - Arguments to create a RolePermission.
     * @example
     * // Create one RolePermission
     * const RolePermission = await prisma.rolePermission.create({
     *   data: {
     *     // ... data to create a RolePermission
     *   }
     * })
     * 
     */
    create<T extends RolePermissionCreateArgs>(args: SelectSubset<T, RolePermissionCreateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RolePermissions.
     * @param {RolePermissionCreateManyArgs} args - Arguments to create many RolePermissions.
     * @example
     * // Create many RolePermissions
     * const rolePermission = await prisma.rolePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolePermissionCreateManyArgs>(args?: SelectSubset<T, RolePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RolePermission.
     * @param {RolePermissionDeleteArgs} args - Arguments to delete one RolePermission.
     * @example
     * // Delete one RolePermission
     * const RolePermission = await prisma.rolePermission.delete({
     *   where: {
     *     // ... filter to delete one RolePermission
     *   }
     * })
     * 
     */
    delete<T extends RolePermissionDeleteArgs>(args: SelectSubset<T, RolePermissionDeleteArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RolePermission.
     * @param {RolePermissionUpdateArgs} args - Arguments to update one RolePermission.
     * @example
     * // Update one RolePermission
     * const rolePermission = await prisma.rolePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolePermissionUpdateArgs>(args: SelectSubset<T, RolePermissionUpdateArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RolePermissions.
     * @param {RolePermissionDeleteManyArgs} args - Arguments to filter RolePermissions to delete.
     * @example
     * // Delete a few RolePermissions
     * const { count } = await prisma.rolePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolePermissionDeleteManyArgs>(args?: SelectSubset<T, RolePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RolePermissions
     * const rolePermission = await prisma.rolePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolePermissionUpdateManyArgs>(args: SelectSubset<T, RolePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RolePermission.
     * @param {RolePermissionUpsertArgs} args - Arguments to update or create a RolePermission.
     * @example
     * // Update or create a RolePermission
     * const rolePermission = await prisma.rolePermission.upsert({
     *   create: {
     *     // ... data to create a RolePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RolePermission we want to update
     *   }
     * })
     */
    upsert<T extends RolePermissionUpsertArgs>(args: SelectSubset<T, RolePermissionUpsertArgs<ExtArgs>>): Prisma__RolePermissionClient<$Result.GetResult<Prisma.$RolePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RolePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionCountArgs} args - Arguments to filter RolePermissions to count.
     * @example
     * // Count the number of RolePermissions
     * const count = await prisma.rolePermission.count({
     *   where: {
     *     // ... the filter for the RolePermissions we want to count
     *   }
     * })
    **/
    count<T extends RolePermissionCountArgs>(
      args?: Subset<T, RolePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolePermissionAggregateArgs>(args: Subset<T, RolePermissionAggregateArgs>): Prisma.PrismaPromise<GetRolePermissionAggregateType<T>>

    /**
     * Group by RolePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolePermissionGroupByArgs['orderBy'] }
        : { orderBy?: RolePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RolePermission model
   */
  readonly fields: RolePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RolePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    permission<T extends PermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PermissionDefaultArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RolePermission model
   */
  interface RolePermissionFieldRefs {
    readonly id: FieldRef<"RolePermission", 'String'>
    readonly roleId: FieldRef<"RolePermission", 'String'>
    readonly permissionId: FieldRef<"RolePermission", 'String'>
    readonly createdAt: FieldRef<"RolePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RolePermission findUnique
   */
  export type RolePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findUniqueOrThrow
   */
  export type RolePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission findFirst
   */
  export type RolePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findFirstOrThrow
   */
  export type RolePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermission to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RolePermissions.
     */
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission findMany
   */
  export type RolePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter, which RolePermissions to fetch.
     */
    where?: RolePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RolePermissions to fetch.
     */
    orderBy?: RolePermissionOrderByWithRelationInput | RolePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RolePermissions.
     */
    cursor?: RolePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RolePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RolePermissions.
     */
    skip?: number
    distinct?: RolePermissionScalarFieldEnum | RolePermissionScalarFieldEnum[]
  }

  /**
   * RolePermission create
   */
  export type RolePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a RolePermission.
     */
    data: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
  }

  /**
   * RolePermission createMany
   */
  export type RolePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RolePermissions.
     */
    data: RolePermissionCreateManyInput | RolePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RolePermission update
   */
  export type RolePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a RolePermission.
     */
    data: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
    /**
     * Choose, which RolePermission to update.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission updateMany
   */
  export type RolePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RolePermissions.
     */
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyInput>
    /**
     * Filter which RolePermissions to update
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to update.
     */
    limit?: number
  }

  /**
   * RolePermission upsert
   */
  export type RolePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the RolePermission to update in case it exists.
     */
    where: RolePermissionWhereUniqueInput
    /**
     * In case the RolePermission found by the `where` argument doesn't exist, create a new RolePermission with this data.
     */
    create: XOR<RolePermissionCreateInput, RolePermissionUncheckedCreateInput>
    /**
     * In case the RolePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolePermissionUpdateInput, RolePermissionUncheckedUpdateInput>
  }

  /**
   * RolePermission delete
   */
  export type RolePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
    /**
     * Filter which RolePermission to delete.
     */
    where: RolePermissionWhereUniqueInput
  }

  /**
   * RolePermission deleteMany
   */
  export type RolePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RolePermissions to delete
     */
    where?: RolePermissionWhereInput
    /**
     * Limit how many RolePermissions to delete.
     */
    limit?: number
  }

  /**
   * RolePermission without action
   */
  export type RolePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolePermission
     */
    select?: RolePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RolePermission
     */
    omit?: RolePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolePermissionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    roleId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    roleId: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    roleId: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    roleId?: true
    isActive?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    roleId?: true
    isActive?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    roleId?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    roleId: string | null
    isActive: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    isActive?: boolean
    createdAt?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
    clientsManaged?: boolean | User$clientsManagedArgs<ExtArgs>
    clientsAssigned?: boolean | User$clientsAssignedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    manualsAuthored?: boolean | User$manualsAuthoredArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    smtpAccountsCreated?: boolean | User$smtpAccountsCreatedArgs<ExtArgs>
    notificationTemplatesCreated?: boolean | User$notificationTemplatesCreatedArgs<ExtArgs>
    notificationsSent?: boolean | User$notificationsSentArgs<ExtArgs>
    scheduledNotificationsCreated?: boolean | User$scheduledNotificationsCreatedArgs<ExtArgs>
    backupsCreated?: boolean | User$backupsCreatedArgs<ExtArgs>
    updatesInitiated?: boolean | User$updatesInitiatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    roleId?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "roleId" | "isActive" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
    clientsManaged?: boolean | User$clientsManagedArgs<ExtArgs>
    clientsAssigned?: boolean | User$clientsAssignedArgs<ExtArgs>
    tasksAssigned?: boolean | User$tasksAssignedArgs<ExtArgs>
    manualsAuthored?: boolean | User$manualsAuthoredArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    smtpAccountsCreated?: boolean | User$smtpAccountsCreatedArgs<ExtArgs>
    notificationTemplatesCreated?: boolean | User$notificationTemplatesCreatedArgs<ExtArgs>
    notificationsSent?: boolean | User$notificationsSentArgs<ExtArgs>
    scheduledNotificationsCreated?: boolean | User$scheduledNotificationsCreatedArgs<ExtArgs>
    backupsCreated?: boolean | User$backupsCreatedArgs<ExtArgs>
    updatesInitiated?: boolean | User$updatesInitiatedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs> | null
      clientsManaged: Prisma.$ClientPayload<ExtArgs>[]
      clientsAssigned: Prisma.$ClientEmployeePayload<ExtArgs>[]
      tasksAssigned: Prisma.$TaskPayload<ExtArgs>[]
      manualsAuthored: Prisma.$ManualPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      auditTrails: Prisma.$AuditTrailPayload<ExtArgs>[]
      smtpAccountsCreated: Prisma.$SMTPAccountPayload<ExtArgs>[]
      notificationTemplatesCreated: Prisma.$NotificationTemplatePayload<ExtArgs>[]
      notificationsSent: Prisma.$NotificationLogPayload<ExtArgs>[]
      scheduledNotificationsCreated: Prisma.$ScheduledNotificationPayload<ExtArgs>[]
      backupsCreated: Prisma.$SystemBackupPayload<ExtArgs>[]
      updatesInitiated: Prisma.$SystemUpdatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      roleId: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends User$roleArgs<ExtArgs> = {}>(args?: Subset<T, User$roleArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clientsManaged<T extends User$clientsManagedArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsManagedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientsAssigned<T extends User$clientsAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$clientsAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasksAssigned<T extends User$tasksAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manualsAuthored<T extends User$manualsAuthoredArgs<ExtArgs> = {}>(args?: Subset<T, User$manualsAuthoredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditTrails<T extends User$auditTrailsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditTrailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    smtpAccountsCreated<T extends User$smtpAccountsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$smtpAccountsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationTemplatesCreated<T extends User$notificationTemplatesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationTemplatesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationsSent<T extends User$notificationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduledNotificationsCreated<T extends User$scheduledNotificationsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$scheduledNotificationsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    backupsCreated<T extends User$backupsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$backupsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatesInitiated<T extends User$updatesInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$updatesInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.role
   */
  export type User$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    where?: RoleWhereInput
  }

  /**
   * User.clientsManaged
   */
  export type User$clientsManagedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * User.clientsAssigned
   */
  export type User$clientsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    where?: ClientEmployeeWhereInput
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    cursor?: ClientEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientEmployeeScalarFieldEnum | ClientEmployeeScalarFieldEnum[]
  }

  /**
   * User.tasksAssigned
   */
  export type User$tasksAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.manualsAuthored
   */
  export type User$manualsAuthoredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    where?: ManualWhereInput
    orderBy?: ManualOrderByWithRelationInput | ManualOrderByWithRelationInput[]
    cursor?: ManualWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualScalarFieldEnum | ManualScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.auditTrails
   */
  export type User$auditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    cursor?: AuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * User.smtpAccountsCreated
   */
  export type User$smtpAccountsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    where?: SMTPAccountWhereInput
    orderBy?: SMTPAccountOrderByWithRelationInput | SMTPAccountOrderByWithRelationInput[]
    cursor?: SMTPAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SMTPAccountScalarFieldEnum | SMTPAccountScalarFieldEnum[]
  }

  /**
   * User.notificationTemplatesCreated
   */
  export type User$notificationTemplatesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    cursor?: NotificationTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * User.notificationsSent
   */
  export type User$notificationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * User.scheduledNotificationsCreated
   */
  export type User$scheduledNotificationsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    where?: ScheduledNotificationWhereInput
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    cursor?: ScheduledNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * User.backupsCreated
   */
  export type User$backupsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    where?: SystemBackupWhereInput
    orderBy?: SystemBackupOrderByWithRelationInput | SystemBackupOrderByWithRelationInput[]
    cursor?: SystemBackupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemBackupScalarFieldEnum | SystemBackupScalarFieldEnum[]
  }

  /**
   * User.updatesInitiated
   */
  export type User$updatesInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    where?: SystemUpdateWhereInput
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    cursor?: SystemUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    razonSocial: string | null
    nifCif: string | null
    tipo: $Enums.ClientType | null
    email: string | null
    telefono: string | null
    direccion: string | null
    fechaAlta: Date | null
    fechaBaja: Date | null
    responsableAsignado: string | null
    isActive: boolean | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    razonSocial: string | null
    nifCif: string | null
    tipo: $Enums.ClientType | null
    email: string | null
    telefono: string | null
    direccion: string | null
    fechaAlta: Date | null
    fechaBaja: Date | null
    responsableAsignado: string | null
    isActive: boolean | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    razonSocial: number
    nifCif: number
    tipo: number
    email: number
    telefono: number
    direccion: number
    fechaAlta: number
    fechaBaja: number
    responsableAsignado: number
    taxModels: number
    isActive: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    razonSocial?: true
    nifCif?: true
    tipo?: true
    email?: true
    telefono?: true
    direccion?: true
    fechaAlta?: true
    fechaBaja?: true
    responsableAsignado?: true
    isActive?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    razonSocial?: true
    nifCif?: true
    tipo?: true
    email?: true
    telefono?: true
    direccion?: true
    fechaAlta?: true
    fechaBaja?: true
    responsableAsignado?: true
    isActive?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    razonSocial?: true
    nifCif?: true
    tipo?: true
    email?: true
    telefono?: true
    direccion?: true
    fechaAlta?: true
    fechaBaja?: true
    responsableAsignado?: true
    taxModels?: true
    isActive?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email: string | null
    telefono: string | null
    direccion: string | null
    fechaAlta: Date
    fechaBaja: Date | null
    responsableAsignado: string | null
    taxModels: JsonValue | null
    isActive: boolean
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    razonSocial?: boolean
    nifCif?: boolean
    tipo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    fechaAlta?: boolean
    fechaBaja?: boolean
    responsableAsignado?: boolean
    taxModels?: boolean
    isActive?: boolean
    responsable?: boolean | Client$responsableArgs<ExtArgs>
    tasks?: boolean | Client$tasksArgs<ExtArgs>
    employees?: boolean | Client$employeesArgs<ExtArgs>
    clientTaxes?: boolean | Client$clientTaxesArgs<ExtArgs>
    clientTaxRequirements?: boolean | Client$clientTaxRequirementsArgs<ExtArgs>
    taxFilings?: boolean | Client$taxFilingsArgs<ExtArgs>
    obligacionesFiscales?: boolean | Client$obligacionesFiscalesArgs<ExtArgs>
    notificaciones?: boolean | Client$notificacionesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>



  export type ClientSelectScalar = {
    id?: boolean
    razonSocial?: boolean
    nifCif?: boolean
    tipo?: boolean
    email?: boolean
    telefono?: boolean
    direccion?: boolean
    fechaAlta?: boolean
    fechaBaja?: boolean
    responsableAsignado?: boolean
    taxModels?: boolean
    isActive?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "razonSocial" | "nifCif" | "tipo" | "email" | "telefono" | "direccion" | "fechaAlta" | "fechaBaja" | "responsableAsignado" | "taxModels" | "isActive", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsable?: boolean | Client$responsableArgs<ExtArgs>
    tasks?: boolean | Client$tasksArgs<ExtArgs>
    employees?: boolean | Client$employeesArgs<ExtArgs>
    clientTaxes?: boolean | Client$clientTaxesArgs<ExtArgs>
    clientTaxRequirements?: boolean | Client$clientTaxRequirementsArgs<ExtArgs>
    taxFilings?: boolean | Client$taxFilingsArgs<ExtArgs>
    obligacionesFiscales?: boolean | Client$obligacionesFiscalesArgs<ExtArgs>
    notificaciones?: boolean | Client$notificacionesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      responsable: Prisma.$UserPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      employees: Prisma.$ClientEmployeePayload<ExtArgs>[]
      clientTaxes: Prisma.$clientTaxPayload<ExtArgs>[]
      clientTaxRequirements: Prisma.$clientTaxRequirementPayload<ExtArgs>[]
      taxFilings: Prisma.$clientTaxFilingPayload<ExtArgs>[]
      obligacionesFiscales: Prisma.$ObligacionFiscalPayload<ExtArgs>[]
      notificaciones: Prisma.$NotificacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      razonSocial: string
      nifCif: string
      tipo: $Enums.ClientType
      email: string | null
      telefono: string | null
      direccion: string | null
      fechaAlta: Date
      fechaBaja: Date | null
      responsableAsignado: string | null
      taxModels: Prisma.JsonValue | null
      isActive: boolean
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsable<T extends Client$responsableArgs<ExtArgs> = {}>(args?: Subset<T, Client$responsableArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Client$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Client$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Client$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Client$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientTaxes<T extends Client$clientTaxesArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientTaxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientTaxRequirements<T extends Client$clientTaxRequirementsArgs<ExtArgs> = {}>(args?: Subset<T, Client$clientTaxRequirementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    taxFilings<T extends Client$taxFilingsArgs<ExtArgs> = {}>(args?: Subset<T, Client$taxFilingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    obligacionesFiscales<T extends Client$obligacionesFiscalesArgs<ExtArgs> = {}>(args?: Subset<T, Client$obligacionesFiscalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificaciones<T extends Client$notificacionesArgs<ExtArgs> = {}>(args?: Subset<T, Client$notificacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly razonSocial: FieldRef<"Client", 'String'>
    readonly nifCif: FieldRef<"Client", 'String'>
    readonly tipo: FieldRef<"Client", 'ClientType'>
    readonly email: FieldRef<"Client", 'String'>
    readonly telefono: FieldRef<"Client", 'String'>
    readonly direccion: FieldRef<"Client", 'String'>
    readonly fechaAlta: FieldRef<"Client", 'DateTime'>
    readonly fechaBaja: FieldRef<"Client", 'DateTime'>
    readonly responsableAsignado: FieldRef<"Client", 'String'>
    readonly taxModels: FieldRef<"Client", 'Json'>
    readonly isActive: FieldRef<"Client", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.responsable
   */
  export type Client$responsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Client.tasks
   */
  export type Client$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Client.employees
   */
  export type Client$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    where?: ClientEmployeeWhereInput
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    cursor?: ClientEmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientEmployeeScalarFieldEnum | ClientEmployeeScalarFieldEnum[]
  }

  /**
   * Client.clientTaxes
   */
  export type Client$clientTaxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    where?: clientTaxWhereInput
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    cursor?: clientTaxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTaxScalarFieldEnum | ClientTaxScalarFieldEnum[]
  }

  /**
   * Client.clientTaxRequirements
   */
  export type Client$clientTaxRequirementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    where?: clientTaxRequirementWhereInput
    orderBy?: clientTaxRequirementOrderByWithRelationInput | clientTaxRequirementOrderByWithRelationInput[]
    cursor?: clientTaxRequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTaxRequirementScalarFieldEnum | ClientTaxRequirementScalarFieldEnum[]
  }

  /**
   * Client.taxFilings
   */
  export type Client$taxFilingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    where?: clientTaxFilingWhereInput
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    cursor?: clientTaxFilingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTaxFilingScalarFieldEnum | ClientTaxFilingScalarFieldEnum[]
  }

  /**
   * Client.obligacionesFiscales
   */
  export type Client$obligacionesFiscalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    where?: ObligacionFiscalWhereInput
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    cursor?: ObligacionFiscalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObligacionFiscalScalarFieldEnum | ObligacionFiscalScalarFieldEnum[]
  }

  /**
   * Client.notificaciones
   */
  export type Client$notificacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    cursor?: NotificacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model ClientEmployee
   */

  export type AggregateClientEmployee = {
    _count: ClientEmployeeCountAggregateOutputType | null
    _min: ClientEmployeeMinAggregateOutputType | null
    _max: ClientEmployeeMaxAggregateOutputType | null
  }

  export type ClientEmployeeMinAggregateOutputType = {
    clientId: string | null
    userId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type ClientEmployeeMaxAggregateOutputType = {
    clientId: string | null
    userId: string | null
    isPrimary: boolean | null
    assignedAt: Date | null
  }

  export type ClientEmployeeCountAggregateOutputType = {
    clientId: number
    userId: number
    isPrimary: number
    assignedAt: number
    _all: number
  }


  export type ClientEmployeeMinAggregateInputType = {
    clientId?: true
    userId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type ClientEmployeeMaxAggregateInputType = {
    clientId?: true
    userId?: true
    isPrimary?: true
    assignedAt?: true
  }

  export type ClientEmployeeCountAggregateInputType = {
    clientId?: true
    userId?: true
    isPrimary?: true
    assignedAt?: true
    _all?: true
  }

  export type ClientEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEmployee to aggregate.
     */
    where?: ClientEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmployees to fetch.
     */
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientEmployees
    **/
    _count?: true | ClientEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientEmployeeMaxAggregateInputType
  }

  export type GetClientEmployeeAggregateType<T extends ClientEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateClientEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientEmployee[P]>
      : GetScalarType<T[P], AggregateClientEmployee[P]>
  }




  export type ClientEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEmployeeWhereInput
    orderBy?: ClientEmployeeOrderByWithAggregationInput | ClientEmployeeOrderByWithAggregationInput[]
    by: ClientEmployeeScalarFieldEnum[] | ClientEmployeeScalarFieldEnum
    having?: ClientEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientEmployeeCountAggregateInputType | true
    _min?: ClientEmployeeMinAggregateInputType
    _max?: ClientEmployeeMaxAggregateInputType
  }

  export type ClientEmployeeGroupByOutputType = {
    clientId: string
    userId: string
    isPrimary: boolean
    assignedAt: Date
    _count: ClientEmployeeCountAggregateOutputType | null
    _min: ClientEmployeeMinAggregateOutputType | null
    _max: ClientEmployeeMaxAggregateOutputType | null
  }

  type GetClientEmployeeGroupByPayload<T extends ClientEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], ClientEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type ClientEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    clientId?: boolean
    userId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientEmployee"]>



  export type ClientEmployeeSelectScalar = {
    clientId?: boolean
    userId?: boolean
    isPrimary?: boolean
    assignedAt?: boolean
  }

  export type ClientEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"clientId" | "userId" | "isPrimary" | "assignedAt", ExtArgs["result"]["clientEmployee"]>
  export type ClientEmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClientEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientEmployee"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      clientId: string
      userId: string
      isPrimary: boolean
      assignedAt: Date
    }, ExtArgs["result"]["clientEmployee"]>
    composites: {}
  }

  type ClientEmployeeGetPayload<S extends boolean | null | undefined | ClientEmployeeDefaultArgs> = $Result.GetResult<Prisma.$ClientEmployeePayload, S>

  type ClientEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientEmployeeCountAggregateInputType | true
    }

  export interface ClientEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientEmployee'], meta: { name: 'ClientEmployee' } }
    /**
     * Find zero or one ClientEmployee that matches the filter.
     * @param {ClientEmployeeFindUniqueArgs} args - Arguments to find a ClientEmployee
     * @example
     * // Get one ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientEmployeeFindUniqueArgs>(args: SelectSubset<T, ClientEmployeeFindUniqueArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientEmployeeFindUniqueOrThrowArgs} args - Arguments to find a ClientEmployee
     * @example
     * // Get one ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeFindFirstArgs} args - Arguments to find a ClientEmployee
     * @example
     * // Get one ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientEmployeeFindFirstArgs>(args?: SelectSubset<T, ClientEmployeeFindFirstArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeFindFirstOrThrowArgs} args - Arguments to find a ClientEmployee
     * @example
     * // Get one ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientEmployees
     * const clientEmployees = await prisma.clientEmployee.findMany()
     * 
     * // Get first 10 ClientEmployees
     * const clientEmployees = await prisma.clientEmployee.findMany({ take: 10 })
     * 
     * // Only select the `clientId`
     * const clientEmployeeWithClientIdOnly = await prisma.clientEmployee.findMany({ select: { clientId: true } })
     * 
     */
    findMany<T extends ClientEmployeeFindManyArgs>(args?: SelectSubset<T, ClientEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientEmployee.
     * @param {ClientEmployeeCreateArgs} args - Arguments to create a ClientEmployee.
     * @example
     * // Create one ClientEmployee
     * const ClientEmployee = await prisma.clientEmployee.create({
     *   data: {
     *     // ... data to create a ClientEmployee
     *   }
     * })
     * 
     */
    create<T extends ClientEmployeeCreateArgs>(args: SelectSubset<T, ClientEmployeeCreateArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientEmployees.
     * @param {ClientEmployeeCreateManyArgs} args - Arguments to create many ClientEmployees.
     * @example
     * // Create many ClientEmployees
     * const clientEmployee = await prisma.clientEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientEmployeeCreateManyArgs>(args?: SelectSubset<T, ClientEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientEmployee.
     * @param {ClientEmployeeDeleteArgs} args - Arguments to delete one ClientEmployee.
     * @example
     * // Delete one ClientEmployee
     * const ClientEmployee = await prisma.clientEmployee.delete({
     *   where: {
     *     // ... filter to delete one ClientEmployee
     *   }
     * })
     * 
     */
    delete<T extends ClientEmployeeDeleteArgs>(args: SelectSubset<T, ClientEmployeeDeleteArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientEmployee.
     * @param {ClientEmployeeUpdateArgs} args - Arguments to update one ClientEmployee.
     * @example
     * // Update one ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientEmployeeUpdateArgs>(args: SelectSubset<T, ClientEmployeeUpdateArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientEmployees.
     * @param {ClientEmployeeDeleteManyArgs} args - Arguments to filter ClientEmployees to delete.
     * @example
     * // Delete a few ClientEmployees
     * const { count } = await prisma.clientEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientEmployeeDeleteManyArgs>(args?: SelectSubset<T, ClientEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientEmployees
     * const clientEmployee = await prisma.clientEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientEmployeeUpdateManyArgs>(args: SelectSubset<T, ClientEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientEmployee.
     * @param {ClientEmployeeUpsertArgs} args - Arguments to update or create a ClientEmployee.
     * @example
     * // Update or create a ClientEmployee
     * const clientEmployee = await prisma.clientEmployee.upsert({
     *   create: {
     *     // ... data to create a ClientEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientEmployee we want to update
     *   }
     * })
     */
    upsert<T extends ClientEmployeeUpsertArgs>(args: SelectSubset<T, ClientEmployeeUpsertArgs<ExtArgs>>): Prisma__ClientEmployeeClient<$Result.GetResult<Prisma.$ClientEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeCountArgs} args - Arguments to filter ClientEmployees to count.
     * @example
     * // Count the number of ClientEmployees
     * const count = await prisma.clientEmployee.count({
     *   where: {
     *     // ... the filter for the ClientEmployees we want to count
     *   }
     * })
    **/
    count<T extends ClientEmployeeCountArgs>(
      args?: Subset<T, ClientEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientEmployeeAggregateArgs>(args: Subset<T, ClientEmployeeAggregateArgs>): Prisma.PrismaPromise<GetClientEmployeeAggregateType<T>>

    /**
     * Group by ClientEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: ClientEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientEmployee model
   */
  readonly fields: ClientEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientEmployee model
   */
  interface ClientEmployeeFieldRefs {
    readonly clientId: FieldRef<"ClientEmployee", 'String'>
    readonly userId: FieldRef<"ClientEmployee", 'String'>
    readonly isPrimary: FieldRef<"ClientEmployee", 'Boolean'>
    readonly assignedAt: FieldRef<"ClientEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientEmployee findUnique
   */
  export type ClientEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmployee to fetch.
     */
    where: ClientEmployeeWhereUniqueInput
  }

  /**
   * ClientEmployee findUniqueOrThrow
   */
  export type ClientEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmployee to fetch.
     */
    where: ClientEmployeeWhereUniqueInput
  }

  /**
   * ClientEmployee findFirst
   */
  export type ClientEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmployee to fetch.
     */
    where?: ClientEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmployees to fetch.
     */
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEmployees.
     */
    cursor?: ClientEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEmployees.
     */
    distinct?: ClientEmployeeScalarFieldEnum | ClientEmployeeScalarFieldEnum[]
  }

  /**
   * ClientEmployee findFirstOrThrow
   */
  export type ClientEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmployee to fetch.
     */
    where?: ClientEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmployees to fetch.
     */
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEmployees.
     */
    cursor?: ClientEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEmployees.
     */
    distinct?: ClientEmployeeScalarFieldEnum | ClientEmployeeScalarFieldEnum[]
  }

  /**
   * ClientEmployee findMany
   */
  export type ClientEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter, which ClientEmployees to fetch.
     */
    where?: ClientEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEmployees to fetch.
     */
    orderBy?: ClientEmployeeOrderByWithRelationInput | ClientEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientEmployees.
     */
    cursor?: ClientEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEmployees.
     */
    skip?: number
    distinct?: ClientEmployeeScalarFieldEnum | ClientEmployeeScalarFieldEnum[]
  }

  /**
   * ClientEmployee create
   */
  export type ClientEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientEmployee.
     */
    data: XOR<ClientEmployeeCreateInput, ClientEmployeeUncheckedCreateInput>
  }

  /**
   * ClientEmployee createMany
   */
  export type ClientEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientEmployees.
     */
    data: ClientEmployeeCreateManyInput | ClientEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientEmployee update
   */
  export type ClientEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientEmployee.
     */
    data: XOR<ClientEmployeeUpdateInput, ClientEmployeeUncheckedUpdateInput>
    /**
     * Choose, which ClientEmployee to update.
     */
    where: ClientEmployeeWhereUniqueInput
  }

  /**
   * ClientEmployee updateMany
   */
  export type ClientEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientEmployees.
     */
    data: XOR<ClientEmployeeUpdateManyMutationInput, ClientEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ClientEmployees to update
     */
    where?: ClientEmployeeWhereInput
    /**
     * Limit how many ClientEmployees to update.
     */
    limit?: number
  }

  /**
   * ClientEmployee upsert
   */
  export type ClientEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientEmployee to update in case it exists.
     */
    where: ClientEmployeeWhereUniqueInput
    /**
     * In case the ClientEmployee found by the `where` argument doesn't exist, create a new ClientEmployee with this data.
     */
    create: XOR<ClientEmployeeCreateInput, ClientEmployeeUncheckedCreateInput>
    /**
     * In case the ClientEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientEmployeeUpdateInput, ClientEmployeeUncheckedUpdateInput>
  }

  /**
   * ClientEmployee delete
   */
  export type ClientEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
    /**
     * Filter which ClientEmployee to delete.
     */
    where: ClientEmployeeWhereUniqueInput
  }

  /**
   * ClientEmployee deleteMany
   */
  export type ClientEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEmployees to delete
     */
    where?: ClientEmployeeWhereInput
    /**
     * Limit how many ClientEmployees to delete.
     */
    limit?: number
  }

  /**
   * ClientEmployee without action
   */
  export type ClientEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEmployee
     */
    select?: ClientEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEmployee
     */
    omit?: ClientEmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    clienteId: string | null
    asignadoA: string | null
    prioridad: $Enums.TaskPriority | null
    estado: $Enums.TaskStatus | null
    visibilidad: $Enums.TaskVisibility | null
    fechaVencimiento: Date | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descripcion: string | null
    clienteId: string | null
    asignadoA: string | null
    prioridad: $Enums.TaskPriority | null
    estado: $Enums.TaskStatus | null
    visibilidad: $Enums.TaskVisibility | null
    fechaVencimiento: Date | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    titulo: number
    descripcion: number
    clienteId: number
    asignadoA: number
    prioridad: number
    estado: number
    visibilidad: number
    fechaVencimiento: number
    fechaCreacion: number
    fechaActualizacion: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    clienteId?: true
    asignadoA?: true
    prioridad?: true
    estado?: true
    visibilidad?: true
    fechaVencimiento?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    clienteId?: true
    asignadoA?: true
    prioridad?: true
    estado?: true
    visibilidad?: true
    fechaVencimiento?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    titulo?: true
    descripcion?: true
    clienteId?: true
    asignadoA?: true
    prioridad?: true
    estado?: true
    visibilidad?: true
    fechaVencimiento?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    titulo: string
    descripcion: string | null
    clienteId: string | null
    asignadoA: string | null
    prioridad: $Enums.TaskPriority
    estado: $Enums.TaskStatus
    visibilidad: $Enums.TaskVisibility
    fechaVencimiento: Date | null
    fechaCreacion: Date
    fechaActualizacion: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    clienteId?: boolean
    asignadoA?: boolean
    prioridad?: boolean
    estado?: boolean
    visibilidad?: boolean
    fechaVencimiento?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    cliente?: boolean | Task$clienteArgs<ExtArgs>
    asignado?: boolean | Task$asignadoArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>



  export type TaskSelectScalar = {
    id?: boolean
    titulo?: boolean
    descripcion?: boolean
    clienteId?: boolean
    asignadoA?: boolean
    prioridad?: boolean
    estado?: boolean
    visibilidad?: boolean
    fechaVencimiento?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "descripcion" | "clienteId" | "asignadoA" | "prioridad" | "estado" | "visibilidad" | "fechaVencimiento" | "fechaCreacion" | "fechaActualizacion", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Task$clienteArgs<ExtArgs>
    asignado?: boolean | Task$asignadoArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      cliente: Prisma.$ClientPayload<ExtArgs> | null
      asignado: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descripcion: string | null
      clienteId: string | null
      asignadoA: string | null
      prioridad: $Enums.TaskPriority
      estado: $Enums.TaskStatus
      visibilidad: $Enums.TaskVisibility
      fechaVencimiento: Date | null
      fechaCreacion: Date
      fechaActualizacion: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends Task$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Task$clienteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    asignado<T extends Task$asignadoArgs<ExtArgs> = {}>(args?: Subset<T, Task$asignadoArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly titulo: FieldRef<"Task", 'String'>
    readonly descripcion: FieldRef<"Task", 'String'>
    readonly clienteId: FieldRef<"Task", 'String'>
    readonly asignadoA: FieldRef<"Task", 'String'>
    readonly prioridad: FieldRef<"Task", 'TaskPriority'>
    readonly estado: FieldRef<"Task", 'TaskStatus'>
    readonly visibilidad: FieldRef<"Task", 'TaskVisibility'>
    readonly fechaVencimiento: FieldRef<"Task", 'DateTime'>
    readonly fechaCreacion: FieldRef<"Task", 'DateTime'>
    readonly fechaActualizacion: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.cliente
   */
  export type Task$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Task.asignado
   */
  export type Task$asignadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Manual
   */

  export type AggregateManual = {
    _count: ManualCountAggregateOutputType | null
    _min: ManualMinAggregateOutputType | null
    _max: ManualMaxAggregateOutputType | null
  }

  export type ManualMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    contenidoHtml: string | null
    autorId: string | null
    etiquetas: string | null
    categoria: string | null
    status: $Enums.ManualStatus | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
    fechaPublicacion: Date | null
  }

  export type ManualMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    contenidoHtml: string | null
    autorId: string | null
    etiquetas: string | null
    categoria: string | null
    status: $Enums.ManualStatus | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
    fechaPublicacion: Date | null
  }

  export type ManualCountAggregateOutputType = {
    id: number
    titulo: number
    contenidoHtml: number
    autorId: number
    etiquetas: number
    categoria: number
    status: number
    fechaCreacion: number
    fechaActualizacion: number
    fechaPublicacion: number
    _all: number
  }


  export type ManualMinAggregateInputType = {
    id?: true
    titulo?: true
    contenidoHtml?: true
    autorId?: true
    etiquetas?: true
    categoria?: true
    status?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    fechaPublicacion?: true
  }

  export type ManualMaxAggregateInputType = {
    id?: true
    titulo?: true
    contenidoHtml?: true
    autorId?: true
    etiquetas?: true
    categoria?: true
    status?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    fechaPublicacion?: true
  }

  export type ManualCountAggregateInputType = {
    id?: true
    titulo?: true
    contenidoHtml?: true
    autorId?: true
    etiquetas?: true
    categoria?: true
    status?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    fechaPublicacion?: true
    _all?: true
  }

  export type ManualAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manual to aggregate.
     */
    where?: ManualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manuals to fetch.
     */
    orderBy?: ManualOrderByWithRelationInput | ManualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Manuals
    **/
    _count?: true | ManualCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualMaxAggregateInputType
  }

  export type GetManualAggregateType<T extends ManualAggregateArgs> = {
        [P in keyof T & keyof AggregateManual]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManual[P]>
      : GetScalarType<T[P], AggregateManual[P]>
  }




  export type ManualGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualWhereInput
    orderBy?: ManualOrderByWithAggregationInput | ManualOrderByWithAggregationInput[]
    by: ManualScalarFieldEnum[] | ManualScalarFieldEnum
    having?: ManualScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualCountAggregateInputType | true
    _min?: ManualMinAggregateInputType
    _max?: ManualMaxAggregateInputType
  }

  export type ManualGroupByOutputType = {
    id: string
    titulo: string
    contenidoHtml: string
    autorId: string
    etiquetas: string | null
    categoria: string | null
    status: $Enums.ManualStatus
    fechaCreacion: Date
    fechaActualizacion: Date
    fechaPublicacion: Date | null
    _count: ManualCountAggregateOutputType | null
    _min: ManualMinAggregateOutputType | null
    _max: ManualMaxAggregateOutputType | null
  }

  type GetManualGroupByPayload<T extends ManualGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualGroupByOutputType[P]>
            : GetScalarType<T[P], ManualGroupByOutputType[P]>
        }
      >
    >


  export type ManualSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    contenidoHtml?: boolean
    autorId?: boolean
    etiquetas?: boolean
    categoria?: boolean
    status?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    fechaPublicacion?: boolean
    autor?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Manual$attachmentsArgs<ExtArgs>
    versions?: boolean | Manual$versionsArgs<ExtArgs>
    _count?: boolean | ManualCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manual"]>



  export type ManualSelectScalar = {
    id?: boolean
    titulo?: boolean
    contenidoHtml?: boolean
    autorId?: boolean
    etiquetas?: boolean
    categoria?: boolean
    status?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    fechaPublicacion?: boolean
  }

  export type ManualOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titulo" | "contenidoHtml" | "autorId" | "etiquetas" | "categoria" | "status" | "fechaCreacion" | "fechaActualizacion" | "fechaPublicacion", ExtArgs["result"]["manual"]>
  export type ManualInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    autor?: boolean | UserDefaultArgs<ExtArgs>
    attachments?: boolean | Manual$attachmentsArgs<ExtArgs>
    versions?: boolean | Manual$versionsArgs<ExtArgs>
    _count?: boolean | ManualCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ManualPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manual"
    objects: {
      autor: Prisma.$UserPayload<ExtArgs>
      attachments: Prisma.$ManualAttachmentPayload<ExtArgs>[]
      versions: Prisma.$ManualVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      contenidoHtml: string
      autorId: string
      etiquetas: string | null
      categoria: string | null
      status: $Enums.ManualStatus
      fechaCreacion: Date
      fechaActualizacion: Date
      fechaPublicacion: Date | null
    }, ExtArgs["result"]["manual"]>
    composites: {}
  }

  type ManualGetPayload<S extends boolean | null | undefined | ManualDefaultArgs> = $Result.GetResult<Prisma.$ManualPayload, S>

  type ManualCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualCountAggregateInputType | true
    }

  export interface ManualDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manual'], meta: { name: 'Manual' } }
    /**
     * Find zero or one Manual that matches the filter.
     * @param {ManualFindUniqueArgs} args - Arguments to find a Manual
     * @example
     * // Get one Manual
     * const manual = await prisma.manual.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualFindUniqueArgs>(args: SelectSubset<T, ManualFindUniqueArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manual that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualFindUniqueOrThrowArgs} args - Arguments to find a Manual
     * @example
     * // Get one Manual
     * const manual = await prisma.manual.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualFindFirstArgs} args - Arguments to find a Manual
     * @example
     * // Get one Manual
     * const manual = await prisma.manual.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualFindFirstArgs>(args?: SelectSubset<T, ManualFindFirstArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manual that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualFindFirstOrThrowArgs} args - Arguments to find a Manual
     * @example
     * // Get one Manual
     * const manual = await prisma.manual.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manuals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manuals
     * const manuals = await prisma.manual.findMany()
     * 
     * // Get first 10 Manuals
     * const manuals = await prisma.manual.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualWithIdOnly = await prisma.manual.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualFindManyArgs>(args?: SelectSubset<T, ManualFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manual.
     * @param {ManualCreateArgs} args - Arguments to create a Manual.
     * @example
     * // Create one Manual
     * const Manual = await prisma.manual.create({
     *   data: {
     *     // ... data to create a Manual
     *   }
     * })
     * 
     */
    create<T extends ManualCreateArgs>(args: SelectSubset<T, ManualCreateArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manuals.
     * @param {ManualCreateManyArgs} args - Arguments to create many Manuals.
     * @example
     * // Create many Manuals
     * const manual = await prisma.manual.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualCreateManyArgs>(args?: SelectSubset<T, ManualCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manual.
     * @param {ManualDeleteArgs} args - Arguments to delete one Manual.
     * @example
     * // Delete one Manual
     * const Manual = await prisma.manual.delete({
     *   where: {
     *     // ... filter to delete one Manual
     *   }
     * })
     * 
     */
    delete<T extends ManualDeleteArgs>(args: SelectSubset<T, ManualDeleteArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manual.
     * @param {ManualUpdateArgs} args - Arguments to update one Manual.
     * @example
     * // Update one Manual
     * const manual = await prisma.manual.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualUpdateArgs>(args: SelectSubset<T, ManualUpdateArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manuals.
     * @param {ManualDeleteManyArgs} args - Arguments to filter Manuals to delete.
     * @example
     * // Delete a few Manuals
     * const { count } = await prisma.manual.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualDeleteManyArgs>(args?: SelectSubset<T, ManualDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manuals
     * const manual = await prisma.manual.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualUpdateManyArgs>(args: SelectSubset<T, ManualUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manual.
     * @param {ManualUpsertArgs} args - Arguments to update or create a Manual.
     * @example
     * // Update or create a Manual
     * const manual = await prisma.manual.upsert({
     *   create: {
     *     // ... data to create a Manual
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manual we want to update
     *   }
     * })
     */
    upsert<T extends ManualUpsertArgs>(args: SelectSubset<T, ManualUpsertArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manuals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualCountArgs} args - Arguments to filter Manuals to count.
     * @example
     * // Count the number of Manuals
     * const count = await prisma.manual.count({
     *   where: {
     *     // ... the filter for the Manuals we want to count
     *   }
     * })
    **/
    count<T extends ManualCountArgs>(
      args?: Subset<T, ManualCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualAggregateArgs>(args: Subset<T, ManualAggregateArgs>): Prisma.PrismaPromise<GetManualAggregateType<T>>

    /**
     * Group by Manual.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualGroupByArgs['orderBy'] }
        : { orderBy?: ManualGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manual model
   */
  readonly fields: ManualFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manual.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    autor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends Manual$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Manual$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Manual$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Manual$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manual model
   */
  interface ManualFieldRefs {
    readonly id: FieldRef<"Manual", 'String'>
    readonly titulo: FieldRef<"Manual", 'String'>
    readonly contenidoHtml: FieldRef<"Manual", 'String'>
    readonly autorId: FieldRef<"Manual", 'String'>
    readonly etiquetas: FieldRef<"Manual", 'String'>
    readonly categoria: FieldRef<"Manual", 'String'>
    readonly status: FieldRef<"Manual", 'ManualStatus'>
    readonly fechaCreacion: FieldRef<"Manual", 'DateTime'>
    readonly fechaActualizacion: FieldRef<"Manual", 'DateTime'>
    readonly fechaPublicacion: FieldRef<"Manual", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Manual findUnique
   */
  export type ManualFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter, which Manual to fetch.
     */
    where: ManualWhereUniqueInput
  }

  /**
   * Manual findUniqueOrThrow
   */
  export type ManualFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter, which Manual to fetch.
     */
    where: ManualWhereUniqueInput
  }

  /**
   * Manual findFirst
   */
  export type ManualFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter, which Manual to fetch.
     */
    where?: ManualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manuals to fetch.
     */
    orderBy?: ManualOrderByWithRelationInput | ManualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manuals.
     */
    cursor?: ManualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manuals.
     */
    distinct?: ManualScalarFieldEnum | ManualScalarFieldEnum[]
  }

  /**
   * Manual findFirstOrThrow
   */
  export type ManualFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter, which Manual to fetch.
     */
    where?: ManualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manuals to fetch.
     */
    orderBy?: ManualOrderByWithRelationInput | ManualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manuals.
     */
    cursor?: ManualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manuals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manuals.
     */
    distinct?: ManualScalarFieldEnum | ManualScalarFieldEnum[]
  }

  /**
   * Manual findMany
   */
  export type ManualFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter, which Manuals to fetch.
     */
    where?: ManualWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manuals to fetch.
     */
    orderBy?: ManualOrderByWithRelationInput | ManualOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Manuals.
     */
    cursor?: ManualWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manuals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manuals.
     */
    skip?: number
    distinct?: ManualScalarFieldEnum | ManualScalarFieldEnum[]
  }

  /**
   * Manual create
   */
  export type ManualCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * The data needed to create a Manual.
     */
    data: XOR<ManualCreateInput, ManualUncheckedCreateInput>
  }

  /**
   * Manual createMany
   */
  export type ManualCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Manuals.
     */
    data: ManualCreateManyInput | ManualCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manual update
   */
  export type ManualUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * The data needed to update a Manual.
     */
    data: XOR<ManualUpdateInput, ManualUncheckedUpdateInput>
    /**
     * Choose, which Manual to update.
     */
    where: ManualWhereUniqueInput
  }

  /**
   * Manual updateMany
   */
  export type ManualUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Manuals.
     */
    data: XOR<ManualUpdateManyMutationInput, ManualUncheckedUpdateManyInput>
    /**
     * Filter which Manuals to update
     */
    where?: ManualWhereInput
    /**
     * Limit how many Manuals to update.
     */
    limit?: number
  }

  /**
   * Manual upsert
   */
  export type ManualUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * The filter to search for the Manual to update in case it exists.
     */
    where: ManualWhereUniqueInput
    /**
     * In case the Manual found by the `where` argument doesn't exist, create a new Manual with this data.
     */
    create: XOR<ManualCreateInput, ManualUncheckedCreateInput>
    /**
     * In case the Manual was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualUpdateInput, ManualUncheckedUpdateInput>
  }

  /**
   * Manual delete
   */
  export type ManualDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
    /**
     * Filter which Manual to delete.
     */
    where: ManualWhereUniqueInput
  }

  /**
   * Manual deleteMany
   */
  export type ManualDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manuals to delete
     */
    where?: ManualWhereInput
    /**
     * Limit how many Manuals to delete.
     */
    limit?: number
  }

  /**
   * Manual.attachments
   */
  export type Manual$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    where?: ManualAttachmentWhereInput
    orderBy?: ManualAttachmentOrderByWithRelationInput | ManualAttachmentOrderByWithRelationInput[]
    cursor?: ManualAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualAttachmentScalarFieldEnum | ManualAttachmentScalarFieldEnum[]
  }

  /**
   * Manual.versions
   */
  export type Manual$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    where?: ManualVersionWhereInput
    orderBy?: ManualVersionOrderByWithRelationInput | ManualVersionOrderByWithRelationInput[]
    cursor?: ManualVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManualVersionScalarFieldEnum | ManualVersionScalarFieldEnum[]
  }

  /**
   * Manual without action
   */
  export type ManualDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manual
     */
    select?: ManualSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manual
     */
    omit?: ManualOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualInclude<ExtArgs> | null
  }


  /**
   * Model ManualAttachment
   */

  export type AggregateManualAttachment = {
    _count: ManualAttachmentCountAggregateOutputType | null
    _avg: ManualAttachmentAvgAggregateOutputType | null
    _sum: ManualAttachmentSumAggregateOutputType | null
    _min: ManualAttachmentMinAggregateOutputType | null
    _max: ManualAttachmentMaxAggregateOutputType | null
  }

  export type ManualAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ManualAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ManualAttachmentMinAggregateOutputType = {
    id: string | null
    manualId: string | null
    fileName: string | null
    originalName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type ManualAttachmentMaxAggregateOutputType = {
    id: string | null
    manualId: string | null
    fileName: string | null
    originalName: string | null
    filePath: string | null
    fileType: string | null
    fileSize: number | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type ManualAttachmentCountAggregateOutputType = {
    id: number
    manualId: number
    fileName: number
    originalName: number
    filePath: number
    fileType: number
    fileSize: number
    uploadedBy: number
    uploadedAt: number
    _all: number
  }


  export type ManualAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type ManualAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type ManualAttachmentMinAggregateInputType = {
    id?: true
    manualId?: true
    fileName?: true
    originalName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type ManualAttachmentMaxAggregateInputType = {
    id?: true
    manualId?: true
    fileName?: true
    originalName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type ManualAttachmentCountAggregateInputType = {
    id?: true
    manualId?: true
    fileName?: true
    originalName?: true
    filePath?: true
    fileType?: true
    fileSize?: true
    uploadedBy?: true
    uploadedAt?: true
    _all?: true
  }

  export type ManualAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualAttachment to aggregate.
     */
    where?: ManualAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualAttachments to fetch.
     */
    orderBy?: ManualAttachmentOrderByWithRelationInput | ManualAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualAttachments
    **/
    _count?: true | ManualAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManualAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManualAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualAttachmentMaxAggregateInputType
  }

  export type GetManualAttachmentAggregateType<T extends ManualAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateManualAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualAttachment[P]>
      : GetScalarType<T[P], AggregateManualAttachment[P]>
  }




  export type ManualAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualAttachmentWhereInput
    orderBy?: ManualAttachmentOrderByWithAggregationInput | ManualAttachmentOrderByWithAggregationInput[]
    by: ManualAttachmentScalarFieldEnum[] | ManualAttachmentScalarFieldEnum
    having?: ManualAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualAttachmentCountAggregateInputType | true
    _avg?: ManualAttachmentAvgAggregateInputType
    _sum?: ManualAttachmentSumAggregateInputType
    _min?: ManualAttachmentMinAggregateInputType
    _max?: ManualAttachmentMaxAggregateInputType
  }

  export type ManualAttachmentGroupByOutputType = {
    id: string
    manualId: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt: Date
    _count: ManualAttachmentCountAggregateOutputType | null
    _avg: ManualAttachmentAvgAggregateOutputType | null
    _sum: ManualAttachmentSumAggregateOutputType | null
    _min: ManualAttachmentMinAggregateOutputType | null
    _max: ManualAttachmentMaxAggregateOutputType | null
  }

  type GetManualAttachmentGroupByPayload<T extends ManualAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], ManualAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type ManualAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manualId?: boolean
    fileName?: boolean
    originalName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    manual?: boolean | ManualDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualAttachment"]>



  export type ManualAttachmentSelectScalar = {
    id?: boolean
    manualId?: boolean
    fileName?: boolean
    originalName?: boolean
    filePath?: boolean
    fileType?: boolean
    fileSize?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
  }

  export type ManualAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "manualId" | "fileName" | "originalName" | "filePath" | "fileType" | "fileSize" | "uploadedBy" | "uploadedAt", ExtArgs["result"]["manualAttachment"]>
  export type ManualAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manual?: boolean | ManualDefaultArgs<ExtArgs>
  }

  export type $ManualAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualAttachment"
    objects: {
      manual: Prisma.$ManualPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      manualId: string
      fileName: string
      originalName: string
      filePath: string
      fileType: string
      fileSize: number
      uploadedBy: string
      uploadedAt: Date
    }, ExtArgs["result"]["manualAttachment"]>
    composites: {}
  }

  type ManualAttachmentGetPayload<S extends boolean | null | undefined | ManualAttachmentDefaultArgs> = $Result.GetResult<Prisma.$ManualAttachmentPayload, S>

  type ManualAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualAttachmentCountAggregateInputType | true
    }

  export interface ManualAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualAttachment'], meta: { name: 'ManualAttachment' } }
    /**
     * Find zero or one ManualAttachment that matches the filter.
     * @param {ManualAttachmentFindUniqueArgs} args - Arguments to find a ManualAttachment
     * @example
     * // Get one ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualAttachmentFindUniqueArgs>(args: SelectSubset<T, ManualAttachmentFindUniqueArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualAttachmentFindUniqueOrThrowArgs} args - Arguments to find a ManualAttachment
     * @example
     * // Get one ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentFindFirstArgs} args - Arguments to find a ManualAttachment
     * @example
     * // Get one ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualAttachmentFindFirstArgs>(args?: SelectSubset<T, ManualAttachmentFindFirstArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentFindFirstOrThrowArgs} args - Arguments to find a ManualAttachment
     * @example
     * // Get one ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualAttachments
     * const manualAttachments = await prisma.manualAttachment.findMany()
     * 
     * // Get first 10 ManualAttachments
     * const manualAttachments = await prisma.manualAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualAttachmentWithIdOnly = await prisma.manualAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualAttachmentFindManyArgs>(args?: SelectSubset<T, ManualAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualAttachment.
     * @param {ManualAttachmentCreateArgs} args - Arguments to create a ManualAttachment.
     * @example
     * // Create one ManualAttachment
     * const ManualAttachment = await prisma.manualAttachment.create({
     *   data: {
     *     // ... data to create a ManualAttachment
     *   }
     * })
     * 
     */
    create<T extends ManualAttachmentCreateArgs>(args: SelectSubset<T, ManualAttachmentCreateArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualAttachments.
     * @param {ManualAttachmentCreateManyArgs} args - Arguments to create many ManualAttachments.
     * @example
     * // Create many ManualAttachments
     * const manualAttachment = await prisma.manualAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualAttachmentCreateManyArgs>(args?: SelectSubset<T, ManualAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManualAttachment.
     * @param {ManualAttachmentDeleteArgs} args - Arguments to delete one ManualAttachment.
     * @example
     * // Delete one ManualAttachment
     * const ManualAttachment = await prisma.manualAttachment.delete({
     *   where: {
     *     // ... filter to delete one ManualAttachment
     *   }
     * })
     * 
     */
    delete<T extends ManualAttachmentDeleteArgs>(args: SelectSubset<T, ManualAttachmentDeleteArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualAttachment.
     * @param {ManualAttachmentUpdateArgs} args - Arguments to update one ManualAttachment.
     * @example
     * // Update one ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualAttachmentUpdateArgs>(args: SelectSubset<T, ManualAttachmentUpdateArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualAttachments.
     * @param {ManualAttachmentDeleteManyArgs} args - Arguments to filter ManualAttachments to delete.
     * @example
     * // Delete a few ManualAttachments
     * const { count } = await prisma.manualAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualAttachmentDeleteManyArgs>(args?: SelectSubset<T, ManualAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualAttachments
     * const manualAttachment = await prisma.manualAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualAttachmentUpdateManyArgs>(args: SelectSubset<T, ManualAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManualAttachment.
     * @param {ManualAttachmentUpsertArgs} args - Arguments to update or create a ManualAttachment.
     * @example
     * // Update or create a ManualAttachment
     * const manualAttachment = await prisma.manualAttachment.upsert({
     *   create: {
     *     // ... data to create a ManualAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualAttachment we want to update
     *   }
     * })
     */
    upsert<T extends ManualAttachmentUpsertArgs>(args: SelectSubset<T, ManualAttachmentUpsertArgs<ExtArgs>>): Prisma__ManualAttachmentClient<$Result.GetResult<Prisma.$ManualAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentCountArgs} args - Arguments to filter ManualAttachments to count.
     * @example
     * // Count the number of ManualAttachments
     * const count = await prisma.manualAttachment.count({
     *   where: {
     *     // ... the filter for the ManualAttachments we want to count
     *   }
     * })
    **/
    count<T extends ManualAttachmentCountArgs>(
      args?: Subset<T, ManualAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualAttachmentAggregateArgs>(args: Subset<T, ManualAttachmentAggregateArgs>): Prisma.PrismaPromise<GetManualAttachmentAggregateType<T>>

    /**
     * Group by ManualAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: ManualAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualAttachment model
   */
  readonly fields: ManualAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manual<T extends ManualDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManualDefaultArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualAttachment model
   */
  interface ManualAttachmentFieldRefs {
    readonly id: FieldRef<"ManualAttachment", 'String'>
    readonly manualId: FieldRef<"ManualAttachment", 'String'>
    readonly fileName: FieldRef<"ManualAttachment", 'String'>
    readonly originalName: FieldRef<"ManualAttachment", 'String'>
    readonly filePath: FieldRef<"ManualAttachment", 'String'>
    readonly fileType: FieldRef<"ManualAttachment", 'String'>
    readonly fileSize: FieldRef<"ManualAttachment", 'Int'>
    readonly uploadedBy: FieldRef<"ManualAttachment", 'String'>
    readonly uploadedAt: FieldRef<"ManualAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualAttachment findUnique
   */
  export type ManualAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ManualAttachment to fetch.
     */
    where: ManualAttachmentWhereUniqueInput
  }

  /**
   * ManualAttachment findUniqueOrThrow
   */
  export type ManualAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ManualAttachment to fetch.
     */
    where: ManualAttachmentWhereUniqueInput
  }

  /**
   * ManualAttachment findFirst
   */
  export type ManualAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ManualAttachment to fetch.
     */
    where?: ManualAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualAttachments to fetch.
     */
    orderBy?: ManualAttachmentOrderByWithRelationInput | ManualAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualAttachments.
     */
    cursor?: ManualAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualAttachments.
     */
    distinct?: ManualAttachmentScalarFieldEnum | ManualAttachmentScalarFieldEnum[]
  }

  /**
   * ManualAttachment findFirstOrThrow
   */
  export type ManualAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ManualAttachment to fetch.
     */
    where?: ManualAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualAttachments to fetch.
     */
    orderBy?: ManualAttachmentOrderByWithRelationInput | ManualAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualAttachments.
     */
    cursor?: ManualAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualAttachments.
     */
    distinct?: ManualAttachmentScalarFieldEnum | ManualAttachmentScalarFieldEnum[]
  }

  /**
   * ManualAttachment findMany
   */
  export type ManualAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which ManualAttachments to fetch.
     */
    where?: ManualAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualAttachments to fetch.
     */
    orderBy?: ManualAttachmentOrderByWithRelationInput | ManualAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualAttachments.
     */
    cursor?: ManualAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualAttachments.
     */
    skip?: number
    distinct?: ManualAttachmentScalarFieldEnum | ManualAttachmentScalarFieldEnum[]
  }

  /**
   * ManualAttachment create
   */
  export type ManualAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualAttachment.
     */
    data: XOR<ManualAttachmentCreateInput, ManualAttachmentUncheckedCreateInput>
  }

  /**
   * ManualAttachment createMany
   */
  export type ManualAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualAttachments.
     */
    data: ManualAttachmentCreateManyInput | ManualAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualAttachment update
   */
  export type ManualAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualAttachment.
     */
    data: XOR<ManualAttachmentUpdateInput, ManualAttachmentUncheckedUpdateInput>
    /**
     * Choose, which ManualAttachment to update.
     */
    where: ManualAttachmentWhereUniqueInput
  }

  /**
   * ManualAttachment updateMany
   */
  export type ManualAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualAttachments.
     */
    data: XOR<ManualAttachmentUpdateManyMutationInput, ManualAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which ManualAttachments to update
     */
    where?: ManualAttachmentWhereInput
    /**
     * Limit how many ManualAttachments to update.
     */
    limit?: number
  }

  /**
   * ManualAttachment upsert
   */
  export type ManualAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualAttachment to update in case it exists.
     */
    where: ManualAttachmentWhereUniqueInput
    /**
     * In case the ManualAttachment found by the `where` argument doesn't exist, create a new ManualAttachment with this data.
     */
    create: XOR<ManualAttachmentCreateInput, ManualAttachmentUncheckedCreateInput>
    /**
     * In case the ManualAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualAttachmentUpdateInput, ManualAttachmentUncheckedUpdateInput>
  }

  /**
   * ManualAttachment delete
   */
  export type ManualAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
    /**
     * Filter which ManualAttachment to delete.
     */
    where: ManualAttachmentWhereUniqueInput
  }

  /**
   * ManualAttachment deleteMany
   */
  export type ManualAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualAttachments to delete
     */
    where?: ManualAttachmentWhereInput
    /**
     * Limit how many ManualAttachments to delete.
     */
    limit?: number
  }

  /**
   * ManualAttachment without action
   */
  export type ManualAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualAttachment
     */
    select?: ManualAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualAttachment
     */
    omit?: ManualAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model ManualVersion
   */

  export type AggregateManualVersion = {
    _count: ManualVersionCountAggregateOutputType | null
    _avg: ManualVersionAvgAggregateOutputType | null
    _sum: ManualVersionSumAggregateOutputType | null
    _min: ManualVersionMinAggregateOutputType | null
    _max: ManualVersionMaxAggregateOutputType | null
  }

  export type ManualVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type ManualVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type ManualVersionMinAggregateOutputType = {
    id: string | null
    manualId: string | null
    versionNumber: number | null
    titulo: string | null
    contenidoHtml: string | null
    etiquetas: string | null
    categoria: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ManualVersionMaxAggregateOutputType = {
    id: string | null
    manualId: string | null
    versionNumber: number | null
    titulo: string | null
    contenidoHtml: string | null
    etiquetas: string | null
    categoria: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type ManualVersionCountAggregateOutputType = {
    id: number
    manualId: number
    versionNumber: number
    titulo: number
    contenidoHtml: number
    etiquetas: number
    categoria: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type ManualVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type ManualVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type ManualVersionMinAggregateInputType = {
    id?: true
    manualId?: true
    versionNumber?: true
    titulo?: true
    contenidoHtml?: true
    etiquetas?: true
    categoria?: true
    createdBy?: true
    createdAt?: true
  }

  export type ManualVersionMaxAggregateInputType = {
    id?: true
    manualId?: true
    versionNumber?: true
    titulo?: true
    contenidoHtml?: true
    etiquetas?: true
    categoria?: true
    createdBy?: true
    createdAt?: true
  }

  export type ManualVersionCountAggregateInputType = {
    id?: true
    manualId?: true
    versionNumber?: true
    titulo?: true
    contenidoHtml?: true
    etiquetas?: true
    categoria?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type ManualVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualVersion to aggregate.
     */
    where?: ManualVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualVersions to fetch.
     */
    orderBy?: ManualVersionOrderByWithRelationInput | ManualVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManualVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManualVersions
    **/
    _count?: true | ManualVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManualVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManualVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManualVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManualVersionMaxAggregateInputType
  }

  export type GetManualVersionAggregateType<T extends ManualVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateManualVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManualVersion[P]>
      : GetScalarType<T[P], AggregateManualVersion[P]>
  }




  export type ManualVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManualVersionWhereInput
    orderBy?: ManualVersionOrderByWithAggregationInput | ManualVersionOrderByWithAggregationInput[]
    by: ManualVersionScalarFieldEnum[] | ManualVersionScalarFieldEnum
    having?: ManualVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManualVersionCountAggregateInputType | true
    _avg?: ManualVersionAvgAggregateInputType
    _sum?: ManualVersionSumAggregateInputType
    _min?: ManualVersionMinAggregateInputType
    _max?: ManualVersionMaxAggregateInputType
  }

  export type ManualVersionGroupByOutputType = {
    id: string
    manualId: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas: string | null
    categoria: string | null
    createdBy: string
    createdAt: Date
    _count: ManualVersionCountAggregateOutputType | null
    _avg: ManualVersionAvgAggregateOutputType | null
    _sum: ManualVersionSumAggregateOutputType | null
    _min: ManualVersionMinAggregateOutputType | null
    _max: ManualVersionMaxAggregateOutputType | null
  }

  type GetManualVersionGroupByPayload<T extends ManualVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManualVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManualVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManualVersionGroupByOutputType[P]>
            : GetScalarType<T[P], ManualVersionGroupByOutputType[P]>
        }
      >
    >


  export type ManualVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    manualId?: boolean
    versionNumber?: boolean
    titulo?: boolean
    contenidoHtml?: boolean
    etiquetas?: boolean
    categoria?: boolean
    createdBy?: boolean
    createdAt?: boolean
    manual?: boolean | ManualDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manualVersion"]>



  export type ManualVersionSelectScalar = {
    id?: boolean
    manualId?: boolean
    versionNumber?: boolean
    titulo?: boolean
    contenidoHtml?: boolean
    etiquetas?: boolean
    categoria?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type ManualVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "manualId" | "versionNumber" | "titulo" | "contenidoHtml" | "etiquetas" | "categoria" | "createdBy" | "createdAt", ExtArgs["result"]["manualVersion"]>
  export type ManualVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manual?: boolean | ManualDefaultArgs<ExtArgs>
  }

  export type $ManualVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManualVersion"
    objects: {
      manual: Prisma.$ManualPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      manualId: string
      versionNumber: number
      titulo: string
      contenidoHtml: string
      etiquetas: string | null
      categoria: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["manualVersion"]>
    composites: {}
  }

  type ManualVersionGetPayload<S extends boolean | null | undefined | ManualVersionDefaultArgs> = $Result.GetResult<Prisma.$ManualVersionPayload, S>

  type ManualVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManualVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManualVersionCountAggregateInputType | true
    }

  export interface ManualVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManualVersion'], meta: { name: 'ManualVersion' } }
    /**
     * Find zero or one ManualVersion that matches the filter.
     * @param {ManualVersionFindUniqueArgs} args - Arguments to find a ManualVersion
     * @example
     * // Get one ManualVersion
     * const manualVersion = await prisma.manualVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManualVersionFindUniqueArgs>(args: SelectSubset<T, ManualVersionFindUniqueArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ManualVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManualVersionFindUniqueOrThrowArgs} args - Arguments to find a ManualVersion
     * @example
     * // Get one ManualVersion
     * const manualVersion = await prisma.manualVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManualVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, ManualVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionFindFirstArgs} args - Arguments to find a ManualVersion
     * @example
     * // Get one ManualVersion
     * const manualVersion = await prisma.manualVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManualVersionFindFirstArgs>(args?: SelectSubset<T, ManualVersionFindFirstArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ManualVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionFindFirstOrThrowArgs} args - Arguments to find a ManualVersion
     * @example
     * // Get one ManualVersion
     * const manualVersion = await prisma.manualVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManualVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, ManualVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ManualVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManualVersions
     * const manualVersions = await prisma.manualVersion.findMany()
     * 
     * // Get first 10 ManualVersions
     * const manualVersions = await prisma.manualVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manualVersionWithIdOnly = await prisma.manualVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManualVersionFindManyArgs>(args?: SelectSubset<T, ManualVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ManualVersion.
     * @param {ManualVersionCreateArgs} args - Arguments to create a ManualVersion.
     * @example
     * // Create one ManualVersion
     * const ManualVersion = await prisma.manualVersion.create({
     *   data: {
     *     // ... data to create a ManualVersion
     *   }
     * })
     * 
     */
    create<T extends ManualVersionCreateArgs>(args: SelectSubset<T, ManualVersionCreateArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ManualVersions.
     * @param {ManualVersionCreateManyArgs} args - Arguments to create many ManualVersions.
     * @example
     * // Create many ManualVersions
     * const manualVersion = await prisma.manualVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManualVersionCreateManyArgs>(args?: SelectSubset<T, ManualVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManualVersion.
     * @param {ManualVersionDeleteArgs} args - Arguments to delete one ManualVersion.
     * @example
     * // Delete one ManualVersion
     * const ManualVersion = await prisma.manualVersion.delete({
     *   where: {
     *     // ... filter to delete one ManualVersion
     *   }
     * })
     * 
     */
    delete<T extends ManualVersionDeleteArgs>(args: SelectSubset<T, ManualVersionDeleteArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ManualVersion.
     * @param {ManualVersionUpdateArgs} args - Arguments to update one ManualVersion.
     * @example
     * // Update one ManualVersion
     * const manualVersion = await prisma.manualVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManualVersionUpdateArgs>(args: SelectSubset<T, ManualVersionUpdateArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ManualVersions.
     * @param {ManualVersionDeleteManyArgs} args - Arguments to filter ManualVersions to delete.
     * @example
     * // Delete a few ManualVersions
     * const { count } = await prisma.manualVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManualVersionDeleteManyArgs>(args?: SelectSubset<T, ManualVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManualVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManualVersions
     * const manualVersion = await prisma.manualVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManualVersionUpdateManyArgs>(args: SelectSubset<T, ManualVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManualVersion.
     * @param {ManualVersionUpsertArgs} args - Arguments to update or create a ManualVersion.
     * @example
     * // Update or create a ManualVersion
     * const manualVersion = await prisma.manualVersion.upsert({
     *   create: {
     *     // ... data to create a ManualVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManualVersion we want to update
     *   }
     * })
     */
    upsert<T extends ManualVersionUpsertArgs>(args: SelectSubset<T, ManualVersionUpsertArgs<ExtArgs>>): Prisma__ManualVersionClient<$Result.GetResult<Prisma.$ManualVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ManualVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionCountArgs} args - Arguments to filter ManualVersions to count.
     * @example
     * // Count the number of ManualVersions
     * const count = await prisma.manualVersion.count({
     *   where: {
     *     // ... the filter for the ManualVersions we want to count
     *   }
     * })
    **/
    count<T extends ManualVersionCountArgs>(
      args?: Subset<T, ManualVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManualVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManualVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManualVersionAggregateArgs>(args: Subset<T, ManualVersionAggregateArgs>): Prisma.PrismaPromise<GetManualVersionAggregateType<T>>

    /**
     * Group by ManualVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManualVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManualVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManualVersionGroupByArgs['orderBy'] }
        : { orderBy?: ManualVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManualVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManualVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManualVersion model
   */
  readonly fields: ManualVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManualVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManualVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manual<T extends ManualDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManualDefaultArgs<ExtArgs>>): Prisma__ManualClient<$Result.GetResult<Prisma.$ManualPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManualVersion model
   */
  interface ManualVersionFieldRefs {
    readonly id: FieldRef<"ManualVersion", 'String'>
    readonly manualId: FieldRef<"ManualVersion", 'String'>
    readonly versionNumber: FieldRef<"ManualVersion", 'Int'>
    readonly titulo: FieldRef<"ManualVersion", 'String'>
    readonly contenidoHtml: FieldRef<"ManualVersion", 'String'>
    readonly etiquetas: FieldRef<"ManualVersion", 'String'>
    readonly categoria: FieldRef<"ManualVersion", 'String'>
    readonly createdBy: FieldRef<"ManualVersion", 'String'>
    readonly createdAt: FieldRef<"ManualVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ManualVersion findUnique
   */
  export type ManualVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter, which ManualVersion to fetch.
     */
    where: ManualVersionWhereUniqueInput
  }

  /**
   * ManualVersion findUniqueOrThrow
   */
  export type ManualVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter, which ManualVersion to fetch.
     */
    where: ManualVersionWhereUniqueInput
  }

  /**
   * ManualVersion findFirst
   */
  export type ManualVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter, which ManualVersion to fetch.
     */
    where?: ManualVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualVersions to fetch.
     */
    orderBy?: ManualVersionOrderByWithRelationInput | ManualVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualVersions.
     */
    cursor?: ManualVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualVersions.
     */
    distinct?: ManualVersionScalarFieldEnum | ManualVersionScalarFieldEnum[]
  }

  /**
   * ManualVersion findFirstOrThrow
   */
  export type ManualVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter, which ManualVersion to fetch.
     */
    where?: ManualVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualVersions to fetch.
     */
    orderBy?: ManualVersionOrderByWithRelationInput | ManualVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManualVersions.
     */
    cursor?: ManualVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManualVersions.
     */
    distinct?: ManualVersionScalarFieldEnum | ManualVersionScalarFieldEnum[]
  }

  /**
   * ManualVersion findMany
   */
  export type ManualVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter, which ManualVersions to fetch.
     */
    where?: ManualVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManualVersions to fetch.
     */
    orderBy?: ManualVersionOrderByWithRelationInput | ManualVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManualVersions.
     */
    cursor?: ManualVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManualVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManualVersions.
     */
    skip?: number
    distinct?: ManualVersionScalarFieldEnum | ManualVersionScalarFieldEnum[]
  }

  /**
   * ManualVersion create
   */
  export type ManualVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a ManualVersion.
     */
    data: XOR<ManualVersionCreateInput, ManualVersionUncheckedCreateInput>
  }

  /**
   * ManualVersion createMany
   */
  export type ManualVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManualVersions.
     */
    data: ManualVersionCreateManyInput | ManualVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManualVersion update
   */
  export type ManualVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a ManualVersion.
     */
    data: XOR<ManualVersionUpdateInput, ManualVersionUncheckedUpdateInput>
    /**
     * Choose, which ManualVersion to update.
     */
    where: ManualVersionWhereUniqueInput
  }

  /**
   * ManualVersion updateMany
   */
  export type ManualVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManualVersions.
     */
    data: XOR<ManualVersionUpdateManyMutationInput, ManualVersionUncheckedUpdateManyInput>
    /**
     * Filter which ManualVersions to update
     */
    where?: ManualVersionWhereInput
    /**
     * Limit how many ManualVersions to update.
     */
    limit?: number
  }

  /**
   * ManualVersion upsert
   */
  export type ManualVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the ManualVersion to update in case it exists.
     */
    where: ManualVersionWhereUniqueInput
    /**
     * In case the ManualVersion found by the `where` argument doesn't exist, create a new ManualVersion with this data.
     */
    create: XOR<ManualVersionCreateInput, ManualVersionUncheckedCreateInput>
    /**
     * In case the ManualVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManualVersionUpdateInput, ManualVersionUncheckedUpdateInput>
  }

  /**
   * ManualVersion delete
   */
  export type ManualVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
    /**
     * Filter which ManualVersion to delete.
     */
    where: ManualVersionWhereUniqueInput
  }

  /**
   * ManualVersion deleteMany
   */
  export type ManualVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManualVersions to delete
     */
    where?: ManualVersionWhereInput
    /**
     * Limit how many ManualVersions to delete.
     */
    limit?: number
  }

  /**
   * ManualVersion without action
   */
  export type ManualVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManualVersion
     */
    select?: ManualVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ManualVersion
     */
    omit?: ManualVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManualVersionInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    accion: string | null
    modulo: string | null
    detalles: string | null
    fecha: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    accion: string | null
    modulo: string | null
    detalles: string | null
    fecha: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    usuarioId: number
    accion: number
    modulo: number
    detalles: number
    fecha: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    modulo?: true
    detalles?: true
    fecha?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    modulo?: true
    detalles?: true
    fecha?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    modulo?: true
    detalles?: true
    fecha?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    usuarioId: string
    accion: string
    modulo: string
    detalles: string | null
    fecha: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    modulo?: boolean
    detalles?: boolean
    fecha?: boolean
    usuario?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>



  export type ActivityLogSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    modulo?: boolean
    detalles?: boolean
    fecha?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "accion" | "modulo" | "detalles" | "fecha", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      usuario: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      accion: string
      modulo: string
      detalles: string | null
      fecha: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly usuarioId: FieldRef<"ActivityLog", 'String'>
    readonly accion: FieldRef<"ActivityLog", 'String'>
    readonly modulo: FieldRef<"ActivityLog", 'String'>
    readonly detalles: FieldRef<"ActivityLog", 'String'>
    readonly fecha: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditTrail
   */

  export type AggregateAuditTrail = {
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  export type AuditTrailMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    accion: $Enums.AuditAction | null
    tabla: string | null
    registroId: string | null
    valorAnterior: string | null
    valorNuevo: string | null
    cambios: string | null
    requestId: string | null
    fecha: Date | null
  }

  export type AuditTrailMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    accion: $Enums.AuditAction | null
    tabla: string | null
    registroId: string | null
    valorAnterior: string | null
    valorNuevo: string | null
    cambios: string | null
    requestId: string | null
    fecha: Date | null
  }

  export type AuditTrailCountAggregateOutputType = {
    id: number
    usuarioId: number
    accion: number
    tabla: number
    registroId: number
    valorAnterior: number
    valorNuevo: number
    cambios: number
    requestId: number
    fecha: number
    _all: number
  }


  export type AuditTrailMinAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    tabla?: true
    registroId?: true
    valorAnterior?: true
    valorNuevo?: true
    cambios?: true
    requestId?: true
    fecha?: true
  }

  export type AuditTrailMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    tabla?: true
    registroId?: true
    valorAnterior?: true
    valorNuevo?: true
    cambios?: true
    requestId?: true
    fecha?: true
  }

  export type AuditTrailCountAggregateInputType = {
    id?: true
    usuarioId?: true
    accion?: true
    tabla?: true
    registroId?: true
    valorAnterior?: true
    valorNuevo?: true
    cambios?: true
    requestId?: true
    fecha?: true
    _all?: true
  }

  export type AuditTrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrail to aggregate.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditTrails
    **/
    _count?: true | AuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditTrailMaxAggregateInputType
  }

  export type GetAuditTrailAggregateType<T extends AuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditTrail[P]>
      : GetScalarType<T[P], AggregateAuditTrail[P]>
  }




  export type AuditTrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithAggregationInput | AuditTrailOrderByWithAggregationInput[]
    by: AuditTrailScalarFieldEnum[] | AuditTrailScalarFieldEnum
    having?: AuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditTrailCountAggregateInputType | true
    _min?: AuditTrailMinAggregateInputType
    _max?: AuditTrailMaxAggregateInputType
  }

  export type AuditTrailGroupByOutputType = {
    id: string
    usuarioId: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior: string | null
    valorNuevo: string | null
    cambios: string | null
    requestId: string | null
    fecha: Date
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  type GetAuditTrailGroupByPayload<T extends AuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type AuditTrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    tabla?: boolean
    registroId?: boolean
    valorAnterior?: boolean
    valorNuevo?: boolean
    cambios?: boolean
    requestId?: boolean
    fecha?: boolean
    usuario?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>



  export type AuditTrailSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    accion?: boolean
    tabla?: boolean
    registroId?: boolean
    valorAnterior?: boolean
    valorNuevo?: boolean
    cambios?: boolean
    requestId?: boolean
    fecha?: boolean
  }

  export type AuditTrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "accion" | "tabla" | "registroId" | "valorAnterior" | "valorNuevo" | "cambios" | "requestId" | "fecha", ExtArgs["result"]["auditTrail"]>
  export type AuditTrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditTrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditTrail"
    objects: {
      usuario: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      accion: $Enums.AuditAction
      tabla: string
      registroId: string
      valorAnterior: string | null
      valorNuevo: string | null
      cambios: string | null
      requestId: string | null
      fecha: Date
    }, ExtArgs["result"]["auditTrail"]>
    composites: {}
  }

  type AuditTrailGetPayload<S extends boolean | null | undefined | AuditTrailDefaultArgs> = $Result.GetResult<Prisma.$AuditTrailPayload, S>

  type AuditTrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditTrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditTrailCountAggregateInputType | true
    }

  export interface AuditTrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditTrail'], meta: { name: 'AuditTrail' } }
    /**
     * Find zero or one AuditTrail that matches the filter.
     * @param {AuditTrailFindUniqueArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditTrailFindUniqueArgs>(args: SelectSubset<T, AuditTrailFindUniqueArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditTrail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditTrailFindUniqueOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditTrailFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditTrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditTrailFindFirstArgs>(args?: SelectSubset<T, AuditTrailFindFirstArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditTrailFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditTrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany()
     * 
     * // Get first 10 AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditTrailFindManyArgs>(args?: SelectSubset<T, AuditTrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditTrail.
     * @param {AuditTrailCreateArgs} args - Arguments to create a AuditTrail.
     * @example
     * // Create one AuditTrail
     * const AuditTrail = await prisma.auditTrail.create({
     *   data: {
     *     // ... data to create a AuditTrail
     *   }
     * })
     * 
     */
    create<T extends AuditTrailCreateArgs>(args: SelectSubset<T, AuditTrailCreateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditTrails.
     * @param {AuditTrailCreateManyArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditTrailCreateManyArgs>(args?: SelectSubset<T, AuditTrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditTrail.
     * @param {AuditTrailDeleteArgs} args - Arguments to delete one AuditTrail.
     * @example
     * // Delete one AuditTrail
     * const AuditTrail = await prisma.auditTrail.delete({
     *   where: {
     *     // ... filter to delete one AuditTrail
     *   }
     * })
     * 
     */
    delete<T extends AuditTrailDeleteArgs>(args: SelectSubset<T, AuditTrailDeleteArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditTrail.
     * @param {AuditTrailUpdateArgs} args - Arguments to update one AuditTrail.
     * @example
     * // Update one AuditTrail
     * const auditTrail = await prisma.auditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditTrailUpdateArgs>(args: SelectSubset<T, AuditTrailUpdateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditTrails.
     * @param {AuditTrailDeleteManyArgs} args - Arguments to filter AuditTrails to delete.
     * @example
     * // Delete a few AuditTrails
     * const { count } = await prisma.auditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditTrailDeleteManyArgs>(args?: SelectSubset<T, AuditTrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditTrailUpdateManyArgs>(args: SelectSubset<T, AuditTrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditTrail.
     * @param {AuditTrailUpsertArgs} args - Arguments to update or create a AuditTrail.
     * @example
     * // Update or create a AuditTrail
     * const auditTrail = await prisma.auditTrail.upsert({
     *   create: {
     *     // ... data to create a AuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditTrail we want to update
     *   }
     * })
     */
    upsert<T extends AuditTrailUpsertArgs>(args: SelectSubset<T, AuditTrailUpsertArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailCountArgs} args - Arguments to filter AuditTrails to count.
     * @example
     * // Count the number of AuditTrails
     * const count = await prisma.auditTrail.count({
     *   where: {
     *     // ... the filter for the AuditTrails we want to count
     *   }
     * })
    **/
    count<T extends AuditTrailCountArgs>(
      args?: Subset<T, AuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditTrailAggregateArgs>(args: Subset<T, AuditTrailAggregateArgs>): Prisma.PrismaPromise<GetAuditTrailAggregateType<T>>

    /**
     * Group by AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: AuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditTrail model
   */
  readonly fields: AuditTrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditTrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditTrail model
   */
  interface AuditTrailFieldRefs {
    readonly id: FieldRef<"AuditTrail", 'String'>
    readonly usuarioId: FieldRef<"AuditTrail", 'String'>
    readonly accion: FieldRef<"AuditTrail", 'AuditAction'>
    readonly tabla: FieldRef<"AuditTrail", 'String'>
    readonly registroId: FieldRef<"AuditTrail", 'String'>
    readonly valorAnterior: FieldRef<"AuditTrail", 'String'>
    readonly valorNuevo: FieldRef<"AuditTrail", 'String'>
    readonly cambios: FieldRef<"AuditTrail", 'String'>
    readonly requestId: FieldRef<"AuditTrail", 'String'>
    readonly fecha: FieldRef<"AuditTrail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditTrail findUnique
   */
  export type AuditTrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findUniqueOrThrow
   */
  export type AuditTrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findFirst
   */
  export type AuditTrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findFirstOrThrow
   */
  export type AuditTrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findMany
   */
  export type AuditTrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrails to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail create
   */
  export type AuditTrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditTrail.
     */
    data: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
  }

  /**
   * AuditTrail createMany
   */
  export type AuditTrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditTrail update
   */
  export type AuditTrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditTrail.
     */
    data: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
    /**
     * Choose, which AuditTrail to update.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail updateMany
   */
  export type AuditTrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to update.
     */
    limit?: number
  }

  /**
   * AuditTrail upsert
   */
  export type AuditTrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditTrail to update in case it exists.
     */
    where: AuditTrailWhereUniqueInput
    /**
     * In case the AuditTrail found by the `where` argument doesn't exist, create a new AuditTrail with this data.
     */
    create: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
    /**
     * In case the AuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
  }

  /**
   * AuditTrail delete
   */
  export type AuditTrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter which AuditTrail to delete.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail deleteMany
   */
  export type AuditTrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrails to delete
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to delete.
     */
    limit?: number
  }

  /**
   * AuditTrail without action
   */
  export type AuditTrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
  }


  /**
   * Model SmtpConfig
   */

  export type AggregateSmtpConfig = {
    _count: SmtpConfigCountAggregateOutputType | null
    _avg: SmtpConfigAvgAggregateOutputType | null
    _sum: SmtpConfigSumAggregateOutputType | null
    _min: SmtpConfigMinAggregateOutputType | null
    _max: SmtpConfigMaxAggregateOutputType | null
  }

  export type SmtpConfigAvgAggregateOutputType = {
    port: number | null
  }

  export type SmtpConfigSumAggregateOutputType = {
    port: number | null
  }

  export type SmtpConfigMinAggregateOutputType = {
    id: string | null
    host: string | null
    port: number | null
    user: string | null
    password: string | null
    secure: boolean | null
  }

  export type SmtpConfigMaxAggregateOutputType = {
    id: string | null
    host: string | null
    port: number | null
    user: string | null
    password: string | null
    secure: boolean | null
  }

  export type SmtpConfigCountAggregateOutputType = {
    id: number
    host: number
    port: number
    user: number
    password: number
    secure: number
    _all: number
  }


  export type SmtpConfigAvgAggregateInputType = {
    port?: true
  }

  export type SmtpConfigSumAggregateInputType = {
    port?: true
  }

  export type SmtpConfigMinAggregateInputType = {
    id?: true
    host?: true
    port?: true
    user?: true
    password?: true
    secure?: true
  }

  export type SmtpConfigMaxAggregateInputType = {
    id?: true
    host?: true
    port?: true
    user?: true
    password?: true
    secure?: true
  }

  export type SmtpConfigCountAggregateInputType = {
    id?: true
    host?: true
    port?: true
    user?: true
    password?: true
    secure?: true
    _all?: true
  }

  export type SmtpConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmtpConfig to aggregate.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SmtpConfigs
    **/
    _count?: true | SmtpConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmtpConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmtpConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmtpConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmtpConfigMaxAggregateInputType
  }

  export type GetSmtpConfigAggregateType<T extends SmtpConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSmtpConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmtpConfig[P]>
      : GetScalarType<T[P], AggregateSmtpConfig[P]>
  }




  export type SmtpConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SmtpConfigWhereInput
    orderBy?: SmtpConfigOrderByWithAggregationInput | SmtpConfigOrderByWithAggregationInput[]
    by: SmtpConfigScalarFieldEnum[] | SmtpConfigScalarFieldEnum
    having?: SmtpConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmtpConfigCountAggregateInputType | true
    _avg?: SmtpConfigAvgAggregateInputType
    _sum?: SmtpConfigSumAggregateInputType
    _min?: SmtpConfigMinAggregateInputType
    _max?: SmtpConfigMaxAggregateInputType
  }

  export type SmtpConfigGroupByOutputType = {
    id: string
    host: string
    port: number
    user: string
    password: string
    secure: boolean
    _count: SmtpConfigCountAggregateOutputType | null
    _avg: SmtpConfigAvgAggregateOutputType | null
    _sum: SmtpConfigSumAggregateOutputType | null
    _min: SmtpConfigMinAggregateOutputType | null
    _max: SmtpConfigMaxAggregateOutputType | null
  }

  type GetSmtpConfigGroupByPayload<T extends SmtpConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmtpConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmtpConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmtpConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SmtpConfigGroupByOutputType[P]>
        }
      >
    >


  export type SmtpConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    password?: boolean
    secure?: boolean
  }, ExtArgs["result"]["smtpConfig"]>



  export type SmtpConfigSelectScalar = {
    id?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    password?: boolean
    secure?: boolean
  }

  export type SmtpConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "host" | "port" | "user" | "password" | "secure", ExtArgs["result"]["smtpConfig"]>

  export type $SmtpConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SmtpConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      host: string
      port: number
      user: string
      password: string
      secure: boolean
    }, ExtArgs["result"]["smtpConfig"]>
    composites: {}
  }

  type SmtpConfigGetPayload<S extends boolean | null | undefined | SmtpConfigDefaultArgs> = $Result.GetResult<Prisma.$SmtpConfigPayload, S>

  type SmtpConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SmtpConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SmtpConfigCountAggregateInputType | true
    }

  export interface SmtpConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SmtpConfig'], meta: { name: 'SmtpConfig' } }
    /**
     * Find zero or one SmtpConfig that matches the filter.
     * @param {SmtpConfigFindUniqueArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SmtpConfigFindUniqueArgs>(args: SelectSubset<T, SmtpConfigFindUniqueArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SmtpConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SmtpConfigFindUniqueOrThrowArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SmtpConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SmtpConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmtpConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindFirstArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SmtpConfigFindFirstArgs>(args?: SelectSubset<T, SmtpConfigFindFirstArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SmtpConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindFirstOrThrowArgs} args - Arguments to find a SmtpConfig
     * @example
     * // Get one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SmtpConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SmtpConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SmtpConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmtpConfigs
     * const smtpConfigs = await prisma.smtpConfig.findMany()
     * 
     * // Get first 10 SmtpConfigs
     * const smtpConfigs = await prisma.smtpConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smtpConfigWithIdOnly = await prisma.smtpConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SmtpConfigFindManyArgs>(args?: SelectSubset<T, SmtpConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SmtpConfig.
     * @param {SmtpConfigCreateArgs} args - Arguments to create a SmtpConfig.
     * @example
     * // Create one SmtpConfig
     * const SmtpConfig = await prisma.smtpConfig.create({
     *   data: {
     *     // ... data to create a SmtpConfig
     *   }
     * })
     * 
     */
    create<T extends SmtpConfigCreateArgs>(args: SelectSubset<T, SmtpConfigCreateArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SmtpConfigs.
     * @param {SmtpConfigCreateManyArgs} args - Arguments to create many SmtpConfigs.
     * @example
     * // Create many SmtpConfigs
     * const smtpConfig = await prisma.smtpConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SmtpConfigCreateManyArgs>(args?: SelectSubset<T, SmtpConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SmtpConfig.
     * @param {SmtpConfigDeleteArgs} args - Arguments to delete one SmtpConfig.
     * @example
     * // Delete one SmtpConfig
     * const SmtpConfig = await prisma.smtpConfig.delete({
     *   where: {
     *     // ... filter to delete one SmtpConfig
     *   }
     * })
     * 
     */
    delete<T extends SmtpConfigDeleteArgs>(args: SelectSubset<T, SmtpConfigDeleteArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SmtpConfig.
     * @param {SmtpConfigUpdateArgs} args - Arguments to update one SmtpConfig.
     * @example
     * // Update one SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SmtpConfigUpdateArgs>(args: SelectSubset<T, SmtpConfigUpdateArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SmtpConfigs.
     * @param {SmtpConfigDeleteManyArgs} args - Arguments to filter SmtpConfigs to delete.
     * @example
     * // Delete a few SmtpConfigs
     * const { count } = await prisma.smtpConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SmtpConfigDeleteManyArgs>(args?: SelectSubset<T, SmtpConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmtpConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmtpConfigs
     * const smtpConfig = await prisma.smtpConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SmtpConfigUpdateManyArgs>(args: SelectSubset<T, SmtpConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SmtpConfig.
     * @param {SmtpConfigUpsertArgs} args - Arguments to update or create a SmtpConfig.
     * @example
     * // Update or create a SmtpConfig
     * const smtpConfig = await prisma.smtpConfig.upsert({
     *   create: {
     *     // ... data to create a SmtpConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmtpConfig we want to update
     *   }
     * })
     */
    upsert<T extends SmtpConfigUpsertArgs>(args: SelectSubset<T, SmtpConfigUpsertArgs<ExtArgs>>): Prisma__SmtpConfigClient<$Result.GetResult<Prisma.$SmtpConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SmtpConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigCountArgs} args - Arguments to filter SmtpConfigs to count.
     * @example
     * // Count the number of SmtpConfigs
     * const count = await prisma.smtpConfig.count({
     *   where: {
     *     // ... the filter for the SmtpConfigs we want to count
     *   }
     * })
    **/
    count<T extends SmtpConfigCountArgs>(
      args?: Subset<T, SmtpConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmtpConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmtpConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmtpConfigAggregateArgs>(args: Subset<T, SmtpConfigAggregateArgs>): Prisma.PrismaPromise<GetSmtpConfigAggregateType<T>>

    /**
     * Group by SmtpConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmtpConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SmtpConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SmtpConfigGroupByArgs['orderBy'] }
        : { orderBy?: SmtpConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SmtpConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmtpConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SmtpConfig model
   */
  readonly fields: SmtpConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SmtpConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SmtpConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SmtpConfig model
   */
  interface SmtpConfigFieldRefs {
    readonly id: FieldRef<"SmtpConfig", 'String'>
    readonly host: FieldRef<"SmtpConfig", 'String'>
    readonly port: FieldRef<"SmtpConfig", 'Int'>
    readonly user: FieldRef<"SmtpConfig", 'String'>
    readonly password: FieldRef<"SmtpConfig", 'String'>
    readonly secure: FieldRef<"SmtpConfig", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SmtpConfig findUnique
   */
  export type SmtpConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig findUniqueOrThrow
   */
  export type SmtpConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig findFirst
   */
  export type SmtpConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmtpConfigs.
     */
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig findFirstOrThrow
   */
  export type SmtpConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter, which SmtpConfig to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SmtpConfigs.
     */
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig findMany
   */
  export type SmtpConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter, which SmtpConfigs to fetch.
     */
    where?: SmtpConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SmtpConfigs to fetch.
     */
    orderBy?: SmtpConfigOrderByWithRelationInput | SmtpConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SmtpConfigs.
     */
    cursor?: SmtpConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SmtpConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SmtpConfigs.
     */
    skip?: number
    distinct?: SmtpConfigScalarFieldEnum | SmtpConfigScalarFieldEnum[]
  }

  /**
   * SmtpConfig create
   */
  export type SmtpConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SmtpConfig.
     */
    data: XOR<SmtpConfigCreateInput, SmtpConfigUncheckedCreateInput>
  }

  /**
   * SmtpConfig createMany
   */
  export type SmtpConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SmtpConfigs.
     */
    data: SmtpConfigCreateManyInput | SmtpConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SmtpConfig update
   */
  export type SmtpConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SmtpConfig.
     */
    data: XOR<SmtpConfigUpdateInput, SmtpConfigUncheckedUpdateInput>
    /**
     * Choose, which SmtpConfig to update.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig updateMany
   */
  export type SmtpConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SmtpConfigs.
     */
    data: XOR<SmtpConfigUpdateManyMutationInput, SmtpConfigUncheckedUpdateManyInput>
    /**
     * Filter which SmtpConfigs to update
     */
    where?: SmtpConfigWhereInput
    /**
     * Limit how many SmtpConfigs to update.
     */
    limit?: number
  }

  /**
   * SmtpConfig upsert
   */
  export type SmtpConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SmtpConfig to update in case it exists.
     */
    where: SmtpConfigWhereUniqueInput
    /**
     * In case the SmtpConfig found by the `where` argument doesn't exist, create a new SmtpConfig with this data.
     */
    create: XOR<SmtpConfigCreateInput, SmtpConfigUncheckedCreateInput>
    /**
     * In case the SmtpConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SmtpConfigUpdateInput, SmtpConfigUncheckedUpdateInput>
  }

  /**
   * SmtpConfig delete
   */
  export type SmtpConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
    /**
     * Filter which SmtpConfig to delete.
     */
    where: SmtpConfigWhereUniqueInput
  }

  /**
   * SmtpConfig deleteMany
   */
  export type SmtpConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SmtpConfigs to delete
     */
    where?: SmtpConfigWhereInput
    /**
     * Limit how many SmtpConfigs to delete.
     */
    limit?: number
  }

  /**
   * SmtpConfig without action
   */
  export type SmtpConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmtpConfig
     */
    select?: SmtpConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SmtpConfig
     */
    omit?: SmtpConfigOmit<ExtArgs> | null
  }


  /**
   * Model JobRun
   */

  export type AggregateJobRun = {
    _count: JobRunCountAggregateOutputType | null
    _avg: JobRunAvgAggregateOutputType | null
    _sum: JobRunSumAggregateOutputType | null
    _min: JobRunMinAggregateOutputType | null
    _max: JobRunMaxAggregateOutputType | null
  }

  export type JobRunAvgAggregateOutputType = {
    recordsProcessed: number | null
  }

  export type JobRunSumAggregateOutputType = {
    recordsProcessed: number | null
  }

  export type JobRunMinAggregateOutputType = {
    id: string | null
    jobName: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: string | null
    recordsProcessed: number | null
    errorMessage: string | null
    metadata: string | null
  }

  export type JobRunMaxAggregateOutputType = {
    id: string | null
    jobName: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: string | null
    recordsProcessed: number | null
    errorMessage: string | null
    metadata: string | null
  }

  export type JobRunCountAggregateOutputType = {
    id: number
    jobName: number
    startedAt: number
    completedAt: number
    status: number
    recordsProcessed: number
    errorMessage: number
    metadata: number
    _all: number
  }


  export type JobRunAvgAggregateInputType = {
    recordsProcessed?: true
  }

  export type JobRunSumAggregateInputType = {
    recordsProcessed?: true
  }

  export type JobRunMinAggregateInputType = {
    id?: true
    jobName?: true
    startedAt?: true
    completedAt?: true
    status?: true
    recordsProcessed?: true
    errorMessage?: true
    metadata?: true
  }

  export type JobRunMaxAggregateInputType = {
    id?: true
    jobName?: true
    startedAt?: true
    completedAt?: true
    status?: true
    recordsProcessed?: true
    errorMessage?: true
    metadata?: true
  }

  export type JobRunCountAggregateInputType = {
    id?: true
    jobName?: true
    startedAt?: true
    completedAt?: true
    status?: true
    recordsProcessed?: true
    errorMessage?: true
    metadata?: true
    _all?: true
  }

  export type JobRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRun to aggregate.
     */
    where?: JobRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRuns to fetch.
     */
    orderBy?: JobRunOrderByWithRelationInput | JobRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobRuns
    **/
    _count?: true | JobRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobRunMaxAggregateInputType
  }

  export type GetJobRunAggregateType<T extends JobRunAggregateArgs> = {
        [P in keyof T & keyof AggregateJobRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobRun[P]>
      : GetScalarType<T[P], AggregateJobRun[P]>
  }




  export type JobRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobRunWhereInput
    orderBy?: JobRunOrderByWithAggregationInput | JobRunOrderByWithAggregationInput[]
    by: JobRunScalarFieldEnum[] | JobRunScalarFieldEnum
    having?: JobRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobRunCountAggregateInputType | true
    _avg?: JobRunAvgAggregateInputType
    _sum?: JobRunSumAggregateInputType
    _min?: JobRunMinAggregateInputType
    _max?: JobRunMaxAggregateInputType
  }

  export type JobRunGroupByOutputType = {
    id: string
    jobName: string
    startedAt: Date
    completedAt: Date | null
    status: string
    recordsProcessed: number | null
    errorMessage: string | null
    metadata: string | null
    _count: JobRunCountAggregateOutputType | null
    _avg: JobRunAvgAggregateOutputType | null
    _sum: JobRunSumAggregateOutputType | null
    _min: JobRunMinAggregateOutputType | null
    _max: JobRunMaxAggregateOutputType | null
  }

  type GetJobRunGroupByPayload<T extends JobRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobRunGroupByOutputType[P]>
            : GetScalarType<T[P], JobRunGroupByOutputType[P]>
        }
      >
    >


  export type JobRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobName?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    recordsProcessed?: boolean
    errorMessage?: boolean
    metadata?: boolean
  }, ExtArgs["result"]["jobRun"]>



  export type JobRunSelectScalar = {
    id?: boolean
    jobName?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    recordsProcessed?: boolean
    errorMessage?: boolean
    metadata?: boolean
  }

  export type JobRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "jobName" | "startedAt" | "completedAt" | "status" | "recordsProcessed" | "errorMessage" | "metadata", ExtArgs["result"]["jobRun"]>

  export type $JobRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobRun"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jobName: string
      startedAt: Date
      completedAt: Date | null
      status: string
      recordsProcessed: number | null
      errorMessage: string | null
      metadata: string | null
    }, ExtArgs["result"]["jobRun"]>
    composites: {}
  }

  type JobRunGetPayload<S extends boolean | null | undefined | JobRunDefaultArgs> = $Result.GetResult<Prisma.$JobRunPayload, S>

  type JobRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobRunCountAggregateInputType | true
    }

  export interface JobRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobRun'], meta: { name: 'JobRun' } }
    /**
     * Find zero or one JobRun that matches the filter.
     * @param {JobRunFindUniqueArgs} args - Arguments to find a JobRun
     * @example
     * // Get one JobRun
     * const jobRun = await prisma.jobRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobRunFindUniqueArgs>(args: SelectSubset<T, JobRunFindUniqueArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobRunFindUniqueOrThrowArgs} args - Arguments to find a JobRun
     * @example
     * // Get one JobRun
     * const jobRun = await prisma.jobRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobRunFindUniqueOrThrowArgs>(args: SelectSubset<T, JobRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunFindFirstArgs} args - Arguments to find a JobRun
     * @example
     * // Get one JobRun
     * const jobRun = await prisma.jobRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobRunFindFirstArgs>(args?: SelectSubset<T, JobRunFindFirstArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunFindFirstOrThrowArgs} args - Arguments to find a JobRun
     * @example
     * // Get one JobRun
     * const jobRun = await prisma.jobRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobRunFindFirstOrThrowArgs>(args?: SelectSubset<T, JobRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobRuns
     * const jobRuns = await prisma.jobRun.findMany()
     * 
     * // Get first 10 JobRuns
     * const jobRuns = await prisma.jobRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobRunWithIdOnly = await prisma.jobRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobRunFindManyArgs>(args?: SelectSubset<T, JobRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobRun.
     * @param {JobRunCreateArgs} args - Arguments to create a JobRun.
     * @example
     * // Create one JobRun
     * const JobRun = await prisma.jobRun.create({
     *   data: {
     *     // ... data to create a JobRun
     *   }
     * })
     * 
     */
    create<T extends JobRunCreateArgs>(args: SelectSubset<T, JobRunCreateArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobRuns.
     * @param {JobRunCreateManyArgs} args - Arguments to create many JobRuns.
     * @example
     * // Create many JobRuns
     * const jobRun = await prisma.jobRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobRunCreateManyArgs>(args?: SelectSubset<T, JobRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobRun.
     * @param {JobRunDeleteArgs} args - Arguments to delete one JobRun.
     * @example
     * // Delete one JobRun
     * const JobRun = await prisma.jobRun.delete({
     *   where: {
     *     // ... filter to delete one JobRun
     *   }
     * })
     * 
     */
    delete<T extends JobRunDeleteArgs>(args: SelectSubset<T, JobRunDeleteArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobRun.
     * @param {JobRunUpdateArgs} args - Arguments to update one JobRun.
     * @example
     * // Update one JobRun
     * const jobRun = await prisma.jobRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobRunUpdateArgs>(args: SelectSubset<T, JobRunUpdateArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobRuns.
     * @param {JobRunDeleteManyArgs} args - Arguments to filter JobRuns to delete.
     * @example
     * // Delete a few JobRuns
     * const { count } = await prisma.jobRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobRunDeleteManyArgs>(args?: SelectSubset<T, JobRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobRuns
     * const jobRun = await prisma.jobRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobRunUpdateManyArgs>(args: SelectSubset<T, JobRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobRun.
     * @param {JobRunUpsertArgs} args - Arguments to update or create a JobRun.
     * @example
     * // Update or create a JobRun
     * const jobRun = await prisma.jobRun.upsert({
     *   create: {
     *     // ... data to create a JobRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobRun we want to update
     *   }
     * })
     */
    upsert<T extends JobRunUpsertArgs>(args: SelectSubset<T, JobRunUpsertArgs<ExtArgs>>): Prisma__JobRunClient<$Result.GetResult<Prisma.$JobRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunCountArgs} args - Arguments to filter JobRuns to count.
     * @example
     * // Count the number of JobRuns
     * const count = await prisma.jobRun.count({
     *   where: {
     *     // ... the filter for the JobRuns we want to count
     *   }
     * })
    **/
    count<T extends JobRunCountArgs>(
      args?: Subset<T, JobRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobRunAggregateArgs>(args: Subset<T, JobRunAggregateArgs>): Prisma.PrismaPromise<GetJobRunAggregateType<T>>

    /**
     * Group by JobRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobRunGroupByArgs['orderBy'] }
        : { orderBy?: JobRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobRun model
   */
  readonly fields: JobRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobRun model
   */
  interface JobRunFieldRefs {
    readonly id: FieldRef<"JobRun", 'String'>
    readonly jobName: FieldRef<"JobRun", 'String'>
    readonly startedAt: FieldRef<"JobRun", 'DateTime'>
    readonly completedAt: FieldRef<"JobRun", 'DateTime'>
    readonly status: FieldRef<"JobRun", 'String'>
    readonly recordsProcessed: FieldRef<"JobRun", 'Int'>
    readonly errorMessage: FieldRef<"JobRun", 'String'>
    readonly metadata: FieldRef<"JobRun", 'String'>
  }
    

  // Custom InputTypes
  /**
   * JobRun findUnique
   */
  export type JobRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter, which JobRun to fetch.
     */
    where: JobRunWhereUniqueInput
  }

  /**
   * JobRun findUniqueOrThrow
   */
  export type JobRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter, which JobRun to fetch.
     */
    where: JobRunWhereUniqueInput
  }

  /**
   * JobRun findFirst
   */
  export type JobRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter, which JobRun to fetch.
     */
    where?: JobRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRuns to fetch.
     */
    orderBy?: JobRunOrderByWithRelationInput | JobRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRuns.
     */
    cursor?: JobRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRuns.
     */
    distinct?: JobRunScalarFieldEnum | JobRunScalarFieldEnum[]
  }

  /**
   * JobRun findFirstOrThrow
   */
  export type JobRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter, which JobRun to fetch.
     */
    where?: JobRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRuns to fetch.
     */
    orderBy?: JobRunOrderByWithRelationInput | JobRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobRuns.
     */
    cursor?: JobRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobRuns.
     */
    distinct?: JobRunScalarFieldEnum | JobRunScalarFieldEnum[]
  }

  /**
   * JobRun findMany
   */
  export type JobRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter, which JobRuns to fetch.
     */
    where?: JobRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobRuns to fetch.
     */
    orderBy?: JobRunOrderByWithRelationInput | JobRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobRuns.
     */
    cursor?: JobRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobRuns.
     */
    skip?: number
    distinct?: JobRunScalarFieldEnum | JobRunScalarFieldEnum[]
  }

  /**
   * JobRun create
   */
  export type JobRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * The data needed to create a JobRun.
     */
    data: XOR<JobRunCreateInput, JobRunUncheckedCreateInput>
  }

  /**
   * JobRun createMany
   */
  export type JobRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobRuns.
     */
    data: JobRunCreateManyInput | JobRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobRun update
   */
  export type JobRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * The data needed to update a JobRun.
     */
    data: XOR<JobRunUpdateInput, JobRunUncheckedUpdateInput>
    /**
     * Choose, which JobRun to update.
     */
    where: JobRunWhereUniqueInput
  }

  /**
   * JobRun updateMany
   */
  export type JobRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobRuns.
     */
    data: XOR<JobRunUpdateManyMutationInput, JobRunUncheckedUpdateManyInput>
    /**
     * Filter which JobRuns to update
     */
    where?: JobRunWhereInput
    /**
     * Limit how many JobRuns to update.
     */
    limit?: number
  }

  /**
   * JobRun upsert
   */
  export type JobRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * The filter to search for the JobRun to update in case it exists.
     */
    where: JobRunWhereUniqueInput
    /**
     * In case the JobRun found by the `where` argument doesn't exist, create a new JobRun with this data.
     */
    create: XOR<JobRunCreateInput, JobRunUncheckedCreateInput>
    /**
     * In case the JobRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobRunUpdateInput, JobRunUncheckedUpdateInput>
  }

  /**
   * JobRun delete
   */
  export type JobRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
    /**
     * Filter which JobRun to delete.
     */
    where: JobRunWhereUniqueInput
  }

  /**
   * JobRun deleteMany
   */
  export type JobRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobRuns to delete
     */
    where?: JobRunWhereInput
    /**
     * Limit how many JobRuns to delete.
     */
    limit?: number
  }

  /**
   * JobRun without action
   */
  export type JobRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobRun
     */
    select?: JobRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JobRun
     */
    omit?: JobRunOmit<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    registrationEnabled: boolean | null
    updatedAt: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    registrationEnabled: boolean | null
    updatedAt: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    registrationEnabled: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    registrationEnabled?: true
    updatedAt?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    registrationEnabled?: true
    updatedAt?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    registrationEnabled?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    registrationEnabled: boolean
    updatedAt: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registrationEnabled?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSettings"]>



  export type SystemSettingsSelectScalar = {
    id?: boolean
    registrationEnabled?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registrationEnabled" | "updatedAt", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      registrationEnabled: boolean
      updatedAt: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly registrationEnabled: FieldRef<"SystemSettings", 'Boolean'>
    readonly updatedAt: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model SMTPAccount
   */

  export type AggregateSMTPAccount = {
    _count: SMTPAccountCountAggregateOutputType | null
    _avg: SMTPAccountAvgAggregateOutputType | null
    _sum: SMTPAccountSumAggregateOutputType | null
    _min: SMTPAccountMinAggregateOutputType | null
    _max: SMTPAccountMaxAggregateOutputType | null
  }

  export type SMTPAccountAvgAggregateOutputType = {
    port: number | null
  }

  export type SMTPAccountSumAggregateOutputType = {
    port: number | null
  }

  export type SMTPAccountMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    host: string | null
    port: number | null
    user: string | null
    password: string | null
    isPredeterminada: boolean | null
    activa: boolean | null
    creadaPor: string | null
    fechaCreacion: Date | null
  }

  export type SMTPAccountMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    host: string | null
    port: number | null
    user: string | null
    password: string | null
    isPredeterminada: boolean | null
    activa: boolean | null
    creadaPor: string | null
    fechaCreacion: Date | null
  }

  export type SMTPAccountCountAggregateOutputType = {
    id: number
    nombre: number
    host: number
    port: number
    user: number
    password: number
    isPredeterminada: number
    activa: number
    creadaPor: number
    fechaCreacion: number
    _all: number
  }


  export type SMTPAccountAvgAggregateInputType = {
    port?: true
  }

  export type SMTPAccountSumAggregateInputType = {
    port?: true
  }

  export type SMTPAccountMinAggregateInputType = {
    id?: true
    nombre?: true
    host?: true
    port?: true
    user?: true
    password?: true
    isPredeterminada?: true
    activa?: true
    creadaPor?: true
    fechaCreacion?: true
  }

  export type SMTPAccountMaxAggregateInputType = {
    id?: true
    nombre?: true
    host?: true
    port?: true
    user?: true
    password?: true
    isPredeterminada?: true
    activa?: true
    creadaPor?: true
    fechaCreacion?: true
  }

  export type SMTPAccountCountAggregateInputType = {
    id?: true
    nombre?: true
    host?: true
    port?: true
    user?: true
    password?: true
    isPredeterminada?: true
    activa?: true
    creadaPor?: true
    fechaCreacion?: true
    _all?: true
  }

  export type SMTPAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMTPAccount to aggregate.
     */
    where?: SMTPAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMTPAccounts to fetch.
     */
    orderBy?: SMTPAccountOrderByWithRelationInput | SMTPAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SMTPAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMTPAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMTPAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SMTPAccounts
    **/
    _count?: true | SMTPAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SMTPAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SMTPAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SMTPAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SMTPAccountMaxAggregateInputType
  }

  export type GetSMTPAccountAggregateType<T extends SMTPAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSMTPAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSMTPAccount[P]>
      : GetScalarType<T[P], AggregateSMTPAccount[P]>
  }




  export type SMTPAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SMTPAccountWhereInput
    orderBy?: SMTPAccountOrderByWithAggregationInput | SMTPAccountOrderByWithAggregationInput[]
    by: SMTPAccountScalarFieldEnum[] | SMTPAccountScalarFieldEnum
    having?: SMTPAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SMTPAccountCountAggregateInputType | true
    _avg?: SMTPAccountAvgAggregateInputType
    _sum?: SMTPAccountSumAggregateInputType
    _min?: SMTPAccountMinAggregateInputType
    _max?: SMTPAccountMaxAggregateInputType
  }

  export type SMTPAccountGroupByOutputType = {
    id: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada: boolean
    activa: boolean
    creadaPor: string | null
    fechaCreacion: Date
    _count: SMTPAccountCountAggregateOutputType | null
    _avg: SMTPAccountAvgAggregateOutputType | null
    _sum: SMTPAccountSumAggregateOutputType | null
    _min: SMTPAccountMinAggregateOutputType | null
    _max: SMTPAccountMaxAggregateOutputType | null
  }

  type GetSMTPAccountGroupByPayload<T extends SMTPAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SMTPAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SMTPAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SMTPAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SMTPAccountGroupByOutputType[P]>
        }
      >
    >


  export type SMTPAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    password?: boolean
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: boolean
    fechaCreacion?: boolean
    creador?: boolean | SMTPAccount$creadorArgs<ExtArgs>
    logs?: boolean | SMTPAccount$logsArgs<ExtArgs>
    scheduled?: boolean | SMTPAccount$scheduledArgs<ExtArgs>
    _count?: boolean | SMTPAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sMTPAccount"]>



  export type SMTPAccountSelectScalar = {
    id?: boolean
    nombre?: boolean
    host?: boolean
    port?: boolean
    user?: boolean
    password?: boolean
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: boolean
    fechaCreacion?: boolean
  }

  export type SMTPAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "host" | "port" | "user" | "password" | "isPredeterminada" | "activa" | "creadaPor" | "fechaCreacion", ExtArgs["result"]["sMTPAccount"]>
  export type SMTPAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creador?: boolean | SMTPAccount$creadorArgs<ExtArgs>
    logs?: boolean | SMTPAccount$logsArgs<ExtArgs>
    scheduled?: boolean | SMTPAccount$scheduledArgs<ExtArgs>
    _count?: boolean | SMTPAccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SMTPAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SMTPAccount"
    objects: {
      creador: Prisma.$UserPayload<ExtArgs> | null
      logs: Prisma.$NotificationLogPayload<ExtArgs>[]
      scheduled: Prisma.$ScheduledNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      host: string
      port: number
      user: string
      password: string
      isPredeterminada: boolean
      activa: boolean
      creadaPor: string | null
      fechaCreacion: Date
    }, ExtArgs["result"]["sMTPAccount"]>
    composites: {}
  }

  type SMTPAccountGetPayload<S extends boolean | null | undefined | SMTPAccountDefaultArgs> = $Result.GetResult<Prisma.$SMTPAccountPayload, S>

  type SMTPAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SMTPAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SMTPAccountCountAggregateInputType | true
    }

  export interface SMTPAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SMTPAccount'], meta: { name: 'SMTPAccount' } }
    /**
     * Find zero or one SMTPAccount that matches the filter.
     * @param {SMTPAccountFindUniqueArgs} args - Arguments to find a SMTPAccount
     * @example
     * // Get one SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SMTPAccountFindUniqueArgs>(args: SelectSubset<T, SMTPAccountFindUniqueArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SMTPAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SMTPAccountFindUniqueOrThrowArgs} args - Arguments to find a SMTPAccount
     * @example
     * // Get one SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SMTPAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SMTPAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMTPAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountFindFirstArgs} args - Arguments to find a SMTPAccount
     * @example
     * // Get one SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SMTPAccountFindFirstArgs>(args?: SelectSubset<T, SMTPAccountFindFirstArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SMTPAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountFindFirstOrThrowArgs} args - Arguments to find a SMTPAccount
     * @example
     * // Get one SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SMTPAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SMTPAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SMTPAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SMTPAccounts
     * const sMTPAccounts = await prisma.sMTPAccount.findMany()
     * 
     * // Get first 10 SMTPAccounts
     * const sMTPAccounts = await prisma.sMTPAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sMTPAccountWithIdOnly = await prisma.sMTPAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SMTPAccountFindManyArgs>(args?: SelectSubset<T, SMTPAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SMTPAccount.
     * @param {SMTPAccountCreateArgs} args - Arguments to create a SMTPAccount.
     * @example
     * // Create one SMTPAccount
     * const SMTPAccount = await prisma.sMTPAccount.create({
     *   data: {
     *     // ... data to create a SMTPAccount
     *   }
     * })
     * 
     */
    create<T extends SMTPAccountCreateArgs>(args: SelectSubset<T, SMTPAccountCreateArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SMTPAccounts.
     * @param {SMTPAccountCreateManyArgs} args - Arguments to create many SMTPAccounts.
     * @example
     * // Create many SMTPAccounts
     * const sMTPAccount = await prisma.sMTPAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SMTPAccountCreateManyArgs>(args?: SelectSubset<T, SMTPAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SMTPAccount.
     * @param {SMTPAccountDeleteArgs} args - Arguments to delete one SMTPAccount.
     * @example
     * // Delete one SMTPAccount
     * const SMTPAccount = await prisma.sMTPAccount.delete({
     *   where: {
     *     // ... filter to delete one SMTPAccount
     *   }
     * })
     * 
     */
    delete<T extends SMTPAccountDeleteArgs>(args: SelectSubset<T, SMTPAccountDeleteArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SMTPAccount.
     * @param {SMTPAccountUpdateArgs} args - Arguments to update one SMTPAccount.
     * @example
     * // Update one SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SMTPAccountUpdateArgs>(args: SelectSubset<T, SMTPAccountUpdateArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SMTPAccounts.
     * @param {SMTPAccountDeleteManyArgs} args - Arguments to filter SMTPAccounts to delete.
     * @example
     * // Delete a few SMTPAccounts
     * const { count } = await prisma.sMTPAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SMTPAccountDeleteManyArgs>(args?: SelectSubset<T, SMTPAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SMTPAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SMTPAccounts
     * const sMTPAccount = await prisma.sMTPAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SMTPAccountUpdateManyArgs>(args: SelectSubset<T, SMTPAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SMTPAccount.
     * @param {SMTPAccountUpsertArgs} args - Arguments to update or create a SMTPAccount.
     * @example
     * // Update or create a SMTPAccount
     * const sMTPAccount = await prisma.sMTPAccount.upsert({
     *   create: {
     *     // ... data to create a SMTPAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SMTPAccount we want to update
     *   }
     * })
     */
    upsert<T extends SMTPAccountUpsertArgs>(args: SelectSubset<T, SMTPAccountUpsertArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SMTPAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountCountArgs} args - Arguments to filter SMTPAccounts to count.
     * @example
     * // Count the number of SMTPAccounts
     * const count = await prisma.sMTPAccount.count({
     *   where: {
     *     // ... the filter for the SMTPAccounts we want to count
     *   }
     * })
    **/
    count<T extends SMTPAccountCountArgs>(
      args?: Subset<T, SMTPAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SMTPAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SMTPAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SMTPAccountAggregateArgs>(args: Subset<T, SMTPAccountAggregateArgs>): Prisma.PrismaPromise<GetSMTPAccountAggregateType<T>>

    /**
     * Group by SMTPAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SMTPAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SMTPAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SMTPAccountGroupByArgs['orderBy'] }
        : { orderBy?: SMTPAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SMTPAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSMTPAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SMTPAccount model
   */
  readonly fields: SMTPAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SMTPAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SMTPAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creador<T extends SMTPAccount$creadorArgs<ExtArgs> = {}>(args?: Subset<T, SMTPAccount$creadorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends SMTPAccount$logsArgs<ExtArgs> = {}>(args?: Subset<T, SMTPAccount$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduled<T extends SMTPAccount$scheduledArgs<ExtArgs> = {}>(args?: Subset<T, SMTPAccount$scheduledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SMTPAccount model
   */
  interface SMTPAccountFieldRefs {
    readonly id: FieldRef<"SMTPAccount", 'String'>
    readonly nombre: FieldRef<"SMTPAccount", 'String'>
    readonly host: FieldRef<"SMTPAccount", 'String'>
    readonly port: FieldRef<"SMTPAccount", 'Int'>
    readonly user: FieldRef<"SMTPAccount", 'String'>
    readonly password: FieldRef<"SMTPAccount", 'String'>
    readonly isPredeterminada: FieldRef<"SMTPAccount", 'Boolean'>
    readonly activa: FieldRef<"SMTPAccount", 'Boolean'>
    readonly creadaPor: FieldRef<"SMTPAccount", 'String'>
    readonly fechaCreacion: FieldRef<"SMTPAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SMTPAccount findUnique
   */
  export type SMTPAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter, which SMTPAccount to fetch.
     */
    where: SMTPAccountWhereUniqueInput
  }

  /**
   * SMTPAccount findUniqueOrThrow
   */
  export type SMTPAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter, which SMTPAccount to fetch.
     */
    where: SMTPAccountWhereUniqueInput
  }

  /**
   * SMTPAccount findFirst
   */
  export type SMTPAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter, which SMTPAccount to fetch.
     */
    where?: SMTPAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMTPAccounts to fetch.
     */
    orderBy?: SMTPAccountOrderByWithRelationInput | SMTPAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMTPAccounts.
     */
    cursor?: SMTPAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMTPAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMTPAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMTPAccounts.
     */
    distinct?: SMTPAccountScalarFieldEnum | SMTPAccountScalarFieldEnum[]
  }

  /**
   * SMTPAccount findFirstOrThrow
   */
  export type SMTPAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter, which SMTPAccount to fetch.
     */
    where?: SMTPAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMTPAccounts to fetch.
     */
    orderBy?: SMTPAccountOrderByWithRelationInput | SMTPAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SMTPAccounts.
     */
    cursor?: SMTPAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMTPAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMTPAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SMTPAccounts.
     */
    distinct?: SMTPAccountScalarFieldEnum | SMTPAccountScalarFieldEnum[]
  }

  /**
   * SMTPAccount findMany
   */
  export type SMTPAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter, which SMTPAccounts to fetch.
     */
    where?: SMTPAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SMTPAccounts to fetch.
     */
    orderBy?: SMTPAccountOrderByWithRelationInput | SMTPAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SMTPAccounts.
     */
    cursor?: SMTPAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SMTPAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SMTPAccounts.
     */
    skip?: number
    distinct?: SMTPAccountScalarFieldEnum | SMTPAccountScalarFieldEnum[]
  }

  /**
   * SMTPAccount create
   */
  export type SMTPAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SMTPAccount.
     */
    data: XOR<SMTPAccountCreateInput, SMTPAccountUncheckedCreateInput>
  }

  /**
   * SMTPAccount createMany
   */
  export type SMTPAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SMTPAccounts.
     */
    data: SMTPAccountCreateManyInput | SMTPAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SMTPAccount update
   */
  export type SMTPAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SMTPAccount.
     */
    data: XOR<SMTPAccountUpdateInput, SMTPAccountUncheckedUpdateInput>
    /**
     * Choose, which SMTPAccount to update.
     */
    where: SMTPAccountWhereUniqueInput
  }

  /**
   * SMTPAccount updateMany
   */
  export type SMTPAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SMTPAccounts.
     */
    data: XOR<SMTPAccountUpdateManyMutationInput, SMTPAccountUncheckedUpdateManyInput>
    /**
     * Filter which SMTPAccounts to update
     */
    where?: SMTPAccountWhereInput
    /**
     * Limit how many SMTPAccounts to update.
     */
    limit?: number
  }

  /**
   * SMTPAccount upsert
   */
  export type SMTPAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SMTPAccount to update in case it exists.
     */
    where: SMTPAccountWhereUniqueInput
    /**
     * In case the SMTPAccount found by the `where` argument doesn't exist, create a new SMTPAccount with this data.
     */
    create: XOR<SMTPAccountCreateInput, SMTPAccountUncheckedCreateInput>
    /**
     * In case the SMTPAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SMTPAccountUpdateInput, SMTPAccountUncheckedUpdateInput>
  }

  /**
   * SMTPAccount delete
   */
  export type SMTPAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    /**
     * Filter which SMTPAccount to delete.
     */
    where: SMTPAccountWhereUniqueInput
  }

  /**
   * SMTPAccount deleteMany
   */
  export type SMTPAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SMTPAccounts to delete
     */
    where?: SMTPAccountWhereInput
    /**
     * Limit how many SMTPAccounts to delete.
     */
    limit?: number
  }

  /**
   * SMTPAccount.creador
   */
  export type SMTPAccount$creadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SMTPAccount.logs
   */
  export type SMTPAccount$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * SMTPAccount.scheduled
   */
  export type SMTPAccount$scheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    where?: ScheduledNotificationWhereInput
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    cursor?: ScheduledNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * SMTPAccount without action
   */
  export type SMTPAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    asunto: string | null
    contenidoHTML: string | null
    tipo: string | null
    activa: boolean | null
    creadoPor: string | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    asunto: string | null
    contenidoHTML: string | null
    tipo: string | null
    activa: boolean | null
    creadoPor: string | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type NotificationTemplateCountAggregateOutputType = {
    id: number
    nombre: number
    asunto: number
    contenidoHTML: number
    variables: number
    tipo: number
    activa: number
    creadoPor: number
    fechaCreacion: number
    fechaActualizacion: number
    _all: number
  }


  export type NotificationTemplateMinAggregateInputType = {
    id?: true
    nombre?: true
    asunto?: true
    contenidoHTML?: true
    tipo?: true
    activa?: true
    creadoPor?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true
    nombre?: true
    asunto?: true
    contenidoHTML?: true
    tipo?: true
    activa?: true
    creadoPor?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type NotificationTemplateCountAggregateInputType = {
    id?: true
    nombre?: true
    asunto?: true
    contenidoHTML?: true
    variables?: true
    tipo?: true
    activa?: true
    creadoPor?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    _all?: true
  }

  export type NotificationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTemplates
    **/
    _count?: true | NotificationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>
  }




  export type NotificationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithAggregationInput | NotificationTemplateOrderByWithAggregationInput[]
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum
    having?: NotificationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTemplateCountAggregateInputType | true
    _min?: NotificationTemplateMinAggregateInputType
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type NotificationTemplateGroupByOutputType = {
    id: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables: JsonValue | null
    tipo: string
    activa: boolean
    creadoPor: string | null
    fechaCreacion: Date
    fechaActualizacion: Date
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    asunto?: boolean
    contenidoHTML?: boolean
    variables?: boolean
    tipo?: boolean
    activa?: boolean
    creadoPor?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    creador?: boolean | NotificationTemplate$creadorArgs<ExtArgs>
    logs?: boolean | NotificationTemplate$logsArgs<ExtArgs>
    scheduled?: boolean | NotificationTemplate$scheduledArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTemplate"]>



  export type NotificationTemplateSelectScalar = {
    id?: boolean
    nombre?: boolean
    asunto?: boolean
    contenidoHTML?: boolean
    variables?: boolean
    tipo?: boolean
    activa?: boolean
    creadoPor?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
  }

  export type NotificationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "asunto" | "contenidoHTML" | "variables" | "tipo" | "activa" | "creadoPor" | "fechaCreacion" | "fechaActualizacion", ExtArgs["result"]["notificationTemplate"]>
  export type NotificationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creador?: boolean | NotificationTemplate$creadorArgs<ExtArgs>
    logs?: boolean | NotificationTemplate$logsArgs<ExtArgs>
    scheduled?: boolean | NotificationTemplate$scheduledArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $NotificationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTemplate"
    objects: {
      creador: Prisma.$UserPayload<ExtArgs> | null
      logs: Prisma.$NotificationLogPayload<ExtArgs>[]
      scheduled: Prisma.$ScheduledNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      asunto: string
      contenidoHTML: string
      variables: Prisma.JsonValue | null
      tipo: string
      activa: boolean
      creadoPor: string | null
      fechaCreacion: Date
      fechaActualizacion: Date
    }, ExtArgs["result"]["notificationTemplate"]>
    composites: {}
  }

  type NotificationTemplateGetPayload<S extends boolean | null | undefined | NotificationTemplateDefaultArgs> = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>

  type NotificationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTemplateCountAggregateInputType | true
    }

  export interface NotificationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'], meta: { name: 'NotificationTemplate' } }
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     * 
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTemplateFindManyArgs>(args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     * 
     */
    create<T extends NotificationTemplateCreateArgs>(args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     * 
     */
    delete<T extends NotificationTemplateDeleteArgs>(args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTemplateUpdateArgs>(args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
    **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTemplateAggregateArgs>(args: Subset<T, NotificationTemplateAggregateArgs>): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTemplate model
   */
  readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creador<T extends NotificationTemplate$creadorArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$creadorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    logs<T extends NotificationTemplate$logsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduled<T extends NotificationTemplate$scheduledArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$scheduledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTemplate model
   */
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<"NotificationTemplate", 'String'>
    readonly nombre: FieldRef<"NotificationTemplate", 'String'>
    readonly asunto: FieldRef<"NotificationTemplate", 'String'>
    readonly contenidoHTML: FieldRef<"NotificationTemplate", 'String'>
    readonly variables: FieldRef<"NotificationTemplate", 'Json'>
    readonly tipo: FieldRef<"NotificationTemplate", 'String'>
    readonly activa: FieldRef<"NotificationTemplate", 'Boolean'>
    readonly creadoPor: FieldRef<"NotificationTemplate", 'String'>
    readonly fechaCreacion: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly fechaActualizacion: FieldRef<"NotificationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
  }

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
  }

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to delete.
     */
    limit?: number
  }

  /**
   * NotificationTemplate.creador
   */
  export type NotificationTemplate$creadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationTemplate.logs
   */
  export type NotificationTemplate$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    cursor?: NotificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationTemplate.scheduled
   */
  export type NotificationTemplate$scheduledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    where?: ScheduledNotificationWhereInput
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    cursor?: ScheduledNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model NotificationLog
   */

  export type AggregateNotificationLog = {
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  export type NotificationLogMinAggregateOutputType = {
    id: string | null
    plantillaId: string | null
    smtpAccountId: string | null
    asunto: string | null
    contenido: string | null
    tipo: string | null
    estado: string | null
    fechaEnvio: Date | null
    enviadoPor: string | null
  }

  export type NotificationLogMaxAggregateOutputType = {
    id: string | null
    plantillaId: string | null
    smtpAccountId: string | null
    asunto: string | null
    contenido: string | null
    tipo: string | null
    estado: string | null
    fechaEnvio: Date | null
    enviadoPor: string | null
  }

  export type NotificationLogCountAggregateOutputType = {
    id: number
    plantillaId: number
    smtpAccountId: number
    destinatarios: number
    asunto: number
    contenido: number
    tipo: number
    estado: number
    fechaEnvio: number
    enviadoPor: number
    metadata: number
    _all: number
  }


  export type NotificationLogMinAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    asunto?: true
    contenido?: true
    tipo?: true
    estado?: true
    fechaEnvio?: true
    enviadoPor?: true
  }

  export type NotificationLogMaxAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    asunto?: true
    contenido?: true
    tipo?: true
    estado?: true
    fechaEnvio?: true
    enviadoPor?: true
  }

  export type NotificationLogCountAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    destinatarios?: true
    asunto?: true
    contenido?: true
    tipo?: true
    estado?: true
    fechaEnvio?: true
    enviadoPor?: true
    metadata?: true
    _all?: true
  }

  export type NotificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLog to aggregate.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationLogs
    **/
    _count?: true | NotificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationLogMaxAggregateInputType
  }

  export type GetNotificationLogAggregateType<T extends NotificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationLog[P]>
      : GetScalarType<T[P], AggregateNotificationLog[P]>
  }




  export type NotificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationLogWhereInput
    orderBy?: NotificationLogOrderByWithAggregationInput | NotificationLogOrderByWithAggregationInput[]
    by: NotificationLogScalarFieldEnum[] | NotificationLogScalarFieldEnum
    having?: NotificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationLogCountAggregateInputType | true
    _min?: NotificationLogMinAggregateInputType
    _max?: NotificationLogMaxAggregateInputType
  }

  export type NotificationLogGroupByOutputType = {
    id: string
    plantillaId: string | null
    smtpAccountId: string | null
    destinatarios: JsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date
    enviadoPor: string | null
    metadata: JsonValue | null
    _count: NotificationLogCountAggregateOutputType | null
    _min: NotificationLogMinAggregateOutputType | null
    _max: NotificationLogMaxAggregateOutputType | null
  }

  type GetNotificationLogGroupByPayload<T extends NotificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationLogGroupByOutputType[P]>
        }
      >
    >


  export type NotificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantillaId?: boolean
    smtpAccountId?: boolean
    destinatarios?: boolean
    asunto?: boolean
    contenido?: boolean
    tipo?: boolean
    estado?: boolean
    fechaEnvio?: boolean
    enviadoPor?: boolean
    metadata?: boolean
    plantilla?: boolean | NotificationLog$plantillaArgs<ExtArgs>
    smtpAccount?: boolean | NotificationLog$smtpAccountArgs<ExtArgs>
    enviador?: boolean | NotificationLog$enviadorArgs<ExtArgs>
  }, ExtArgs["result"]["notificationLog"]>



  export type NotificationLogSelectScalar = {
    id?: boolean
    plantillaId?: boolean
    smtpAccountId?: boolean
    destinatarios?: boolean
    asunto?: boolean
    contenido?: boolean
    tipo?: boolean
    estado?: boolean
    fechaEnvio?: boolean
    enviadoPor?: boolean
    metadata?: boolean
  }

  export type NotificationLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantillaId" | "smtpAccountId" | "destinatarios" | "asunto" | "contenido" | "tipo" | "estado" | "fechaEnvio" | "enviadoPor" | "metadata", ExtArgs["result"]["notificationLog"]>
  export type NotificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantilla?: boolean | NotificationLog$plantillaArgs<ExtArgs>
    smtpAccount?: boolean | NotificationLog$smtpAccountArgs<ExtArgs>
    enviador?: boolean | NotificationLog$enviadorArgs<ExtArgs>
  }

  export type $NotificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationLog"
    objects: {
      plantilla: Prisma.$NotificationTemplatePayload<ExtArgs> | null
      smtpAccount: Prisma.$SMTPAccountPayload<ExtArgs> | null
      enviador: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plantillaId: string | null
      smtpAccountId: string | null
      destinatarios: Prisma.JsonValue
      asunto: string
      contenido: string
      tipo: string
      estado: string
      fechaEnvio: Date
      enviadoPor: string | null
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["notificationLog"]>
    composites: {}
  }

  type NotificationLogGetPayload<S extends boolean | null | undefined | NotificationLogDefaultArgs> = $Result.GetResult<Prisma.$NotificationLogPayload, S>

  type NotificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationLogCountAggregateInputType | true
    }

  export interface NotificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationLog'], meta: { name: 'NotificationLog' } }
    /**
     * Find zero or one NotificationLog that matches the filter.
     * @param {NotificationLogFindUniqueArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationLogFindUniqueArgs>(args: SelectSubset<T, NotificationLogFindUniqueArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationLogFindUniqueOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationLogFindFirstArgs>(args?: SelectSubset<T, NotificationLogFindFirstArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindFirstOrThrowArgs} args - Arguments to find a NotificationLog
     * @example
     * // Get one NotificationLog
     * const notificationLog = await prisma.notificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany()
     * 
     * // Get first 10 NotificationLogs
     * const notificationLogs = await prisma.notificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationLogWithIdOnly = await prisma.notificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationLogFindManyArgs>(args?: SelectSubset<T, NotificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationLog.
     * @param {NotificationLogCreateArgs} args - Arguments to create a NotificationLog.
     * @example
     * // Create one NotificationLog
     * const NotificationLog = await prisma.notificationLog.create({
     *   data: {
     *     // ... data to create a NotificationLog
     *   }
     * })
     * 
     */
    create<T extends NotificationLogCreateArgs>(args: SelectSubset<T, NotificationLogCreateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationLogs.
     * @param {NotificationLogCreateManyArgs} args - Arguments to create many NotificationLogs.
     * @example
     * // Create many NotificationLogs
     * const notificationLog = await prisma.notificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationLogCreateManyArgs>(args?: SelectSubset<T, NotificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NotificationLog.
     * @param {NotificationLogDeleteArgs} args - Arguments to delete one NotificationLog.
     * @example
     * // Delete one NotificationLog
     * const NotificationLog = await prisma.notificationLog.delete({
     *   where: {
     *     // ... filter to delete one NotificationLog
     *   }
     * })
     * 
     */
    delete<T extends NotificationLogDeleteArgs>(args: SelectSubset<T, NotificationLogDeleteArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationLog.
     * @param {NotificationLogUpdateArgs} args - Arguments to update one NotificationLog.
     * @example
     * // Update one NotificationLog
     * const notificationLog = await prisma.notificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationLogUpdateArgs>(args: SelectSubset<T, NotificationLogUpdateArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationLogs.
     * @param {NotificationLogDeleteManyArgs} args - Arguments to filter NotificationLogs to delete.
     * @example
     * // Delete a few NotificationLogs
     * const { count } = await prisma.notificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationLogDeleteManyArgs>(args?: SelectSubset<T, NotificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationLogs
     * const notificationLog = await prisma.notificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationLogUpdateManyArgs>(args: SelectSubset<T, NotificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NotificationLog.
     * @param {NotificationLogUpsertArgs} args - Arguments to update or create a NotificationLog.
     * @example
     * // Update or create a NotificationLog
     * const notificationLog = await prisma.notificationLog.upsert({
     *   create: {
     *     // ... data to create a NotificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationLog we want to update
     *   }
     * })
     */
    upsert<T extends NotificationLogUpsertArgs>(args: SelectSubset<T, NotificationLogUpsertArgs<ExtArgs>>): Prisma__NotificationLogClient<$Result.GetResult<Prisma.$NotificationLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogCountArgs} args - Arguments to filter NotificationLogs to count.
     * @example
     * // Count the number of NotificationLogs
     * const count = await prisma.notificationLog.count({
     *   where: {
     *     // ... the filter for the NotificationLogs we want to count
     *   }
     * })
    **/
    count<T extends NotificationLogCountArgs>(
      args?: Subset<T, NotificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationLogAggregateArgs>(args: Subset<T, NotificationLogAggregateArgs>): Prisma.PrismaPromise<GetNotificationLogAggregateType<T>>

    /**
     * Group by NotificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationLogGroupByArgs['orderBy'] }
        : { orderBy?: NotificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationLog model
   */
  readonly fields: NotificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plantilla<T extends NotificationLog$plantillaArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$plantillaArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    smtpAccount<T extends NotificationLog$smtpAccountArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$smtpAccountArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enviador<T extends NotificationLog$enviadorArgs<ExtArgs> = {}>(args?: Subset<T, NotificationLog$enviadorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationLog model
   */
  interface NotificationLogFieldRefs {
    readonly id: FieldRef<"NotificationLog", 'String'>
    readonly plantillaId: FieldRef<"NotificationLog", 'String'>
    readonly smtpAccountId: FieldRef<"NotificationLog", 'String'>
    readonly destinatarios: FieldRef<"NotificationLog", 'Json'>
    readonly asunto: FieldRef<"NotificationLog", 'String'>
    readonly contenido: FieldRef<"NotificationLog", 'String'>
    readonly tipo: FieldRef<"NotificationLog", 'String'>
    readonly estado: FieldRef<"NotificationLog", 'String'>
    readonly fechaEnvio: FieldRef<"NotificationLog", 'DateTime'>
    readonly enviadoPor: FieldRef<"NotificationLog", 'String'>
    readonly metadata: FieldRef<"NotificationLog", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * NotificationLog findUnique
   */
  export type NotificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findUniqueOrThrow
   */
  export type NotificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog findFirst
   */
  export type NotificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findFirstOrThrow
   */
  export type NotificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLog to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationLogs.
     */
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog findMany
   */
  export type NotificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter, which NotificationLogs to fetch.
     */
    where?: NotificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationLogs to fetch.
     */
    orderBy?: NotificationLogOrderByWithRelationInput | NotificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationLogs.
     */
    cursor?: NotificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationLogs.
     */
    skip?: number
    distinct?: NotificationLogScalarFieldEnum | NotificationLogScalarFieldEnum[]
  }

  /**
   * NotificationLog create
   */
  export type NotificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationLog.
     */
    data: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
  }

  /**
   * NotificationLog createMany
   */
  export type NotificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationLogs.
     */
    data: NotificationLogCreateManyInput | NotificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationLog update
   */
  export type NotificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationLog.
     */
    data: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
    /**
     * Choose, which NotificationLog to update.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog updateMany
   */
  export type NotificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationLogs.
     */
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyInput>
    /**
     * Filter which NotificationLogs to update
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to update.
     */
    limit?: number
  }

  /**
   * NotificationLog upsert
   */
  export type NotificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationLog to update in case it exists.
     */
    where: NotificationLogWhereUniqueInput
    /**
     * In case the NotificationLog found by the `where` argument doesn't exist, create a new NotificationLog with this data.
     */
    create: XOR<NotificationLogCreateInput, NotificationLogUncheckedCreateInput>
    /**
     * In case the NotificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationLogUpdateInput, NotificationLogUncheckedUpdateInput>
  }

  /**
   * NotificationLog delete
   */
  export type NotificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
    /**
     * Filter which NotificationLog to delete.
     */
    where: NotificationLogWhereUniqueInput
  }

  /**
   * NotificationLog deleteMany
   */
  export type NotificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationLogs to delete
     */
    where?: NotificationLogWhereInput
    /**
     * Limit how many NotificationLogs to delete.
     */
    limit?: number
  }

  /**
   * NotificationLog.plantilla
   */
  export type NotificationLog$plantillaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    where?: NotificationTemplateWhereInput
  }

  /**
   * NotificationLog.smtpAccount
   */
  export type NotificationLog$smtpAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    where?: SMTPAccountWhereInput
  }

  /**
   * NotificationLog.enviador
   */
  export type NotificationLog$enviadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NotificationLog without action
   */
  export type NotificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationLog
     */
    select?: NotificationLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationLog
     */
    omit?: NotificationLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationLogInclude<ExtArgs> | null
  }


  /**
   * Model ScheduledNotification
   */

  export type AggregateScheduledNotification = {
    _count: ScheduledNotificationCountAggregateOutputType | null
    _min: ScheduledNotificationMinAggregateOutputType | null
    _max: ScheduledNotificationMaxAggregateOutputType | null
  }

  export type ScheduledNotificationMinAggregateOutputType = {
    id: string | null
    plantillaId: string | null
    smtpAccountId: string | null
    fechaProgramada: Date | null
    estado: string | null
    recurrencia: string | null
    creadoPor: string | null
    fechaCreacion: Date | null
  }

  export type ScheduledNotificationMaxAggregateOutputType = {
    id: string | null
    plantillaId: string | null
    smtpAccountId: string | null
    fechaProgramada: Date | null
    estado: string | null
    recurrencia: string | null
    creadoPor: string | null
    fechaCreacion: Date | null
  }

  export type ScheduledNotificationCountAggregateOutputType = {
    id: number
    plantillaId: number
    smtpAccountId: number
    destinatariosSeleccionados: number
    fechaProgramada: number
    estado: number
    recurrencia: number
    creadoPor: number
    fechaCreacion: number
    _all: number
  }


  export type ScheduledNotificationMinAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    fechaProgramada?: true
    estado?: true
    recurrencia?: true
    creadoPor?: true
    fechaCreacion?: true
  }

  export type ScheduledNotificationMaxAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    fechaProgramada?: true
    estado?: true
    recurrencia?: true
    creadoPor?: true
    fechaCreacion?: true
  }

  export type ScheduledNotificationCountAggregateInputType = {
    id?: true
    plantillaId?: true
    smtpAccountId?: true
    destinatariosSeleccionados?: true
    fechaProgramada?: true
    estado?: true
    recurrencia?: true
    creadoPor?: true
    fechaCreacion?: true
    _all?: true
  }

  export type ScheduledNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledNotification to aggregate.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledNotifications
    **/
    _count?: true | ScheduledNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledNotificationMaxAggregateInputType
  }

  export type GetScheduledNotificationAggregateType<T extends ScheduledNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledNotification[P]>
      : GetScalarType<T[P], AggregateScheduledNotification[P]>
  }




  export type ScheduledNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledNotificationWhereInput
    orderBy?: ScheduledNotificationOrderByWithAggregationInput | ScheduledNotificationOrderByWithAggregationInput[]
    by: ScheduledNotificationScalarFieldEnum[] | ScheduledNotificationScalarFieldEnum
    having?: ScheduledNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledNotificationCountAggregateInputType | true
    _min?: ScheduledNotificationMinAggregateInputType
    _max?: ScheduledNotificationMaxAggregateInputType
  }

  export type ScheduledNotificationGroupByOutputType = {
    id: string
    plantillaId: string
    smtpAccountId: string | null
    destinatariosSeleccionados: JsonValue
    fechaProgramada: Date
    estado: string
    recurrencia: string
    creadoPor: string | null
    fechaCreacion: Date
    _count: ScheduledNotificationCountAggregateOutputType | null
    _min: ScheduledNotificationMinAggregateOutputType | null
    _max: ScheduledNotificationMaxAggregateOutputType | null
  }

  type GetScheduledNotificationGroupByPayload<T extends ScheduledNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledNotificationGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantillaId?: boolean
    smtpAccountId?: boolean
    destinatariosSeleccionados?: boolean
    fechaProgramada?: boolean
    estado?: boolean
    recurrencia?: boolean
    creadoPor?: boolean
    fechaCreacion?: boolean
    plantilla?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    smtpAccount?: boolean | ScheduledNotification$smtpAccountArgs<ExtArgs>
    creador?: boolean | ScheduledNotification$creadorArgs<ExtArgs>
  }, ExtArgs["result"]["scheduledNotification"]>



  export type ScheduledNotificationSelectScalar = {
    id?: boolean
    plantillaId?: boolean
    smtpAccountId?: boolean
    destinatariosSeleccionados?: boolean
    fechaProgramada?: boolean
    estado?: boolean
    recurrencia?: boolean
    creadoPor?: boolean
    fechaCreacion?: boolean
  }

  export type ScheduledNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantillaId" | "smtpAccountId" | "destinatariosSeleccionados" | "fechaProgramada" | "estado" | "recurrencia" | "creadoPor" | "fechaCreacion", ExtArgs["result"]["scheduledNotification"]>
  export type ScheduledNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plantilla?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    smtpAccount?: boolean | ScheduledNotification$smtpAccountArgs<ExtArgs>
    creador?: boolean | ScheduledNotification$creadorArgs<ExtArgs>
  }

  export type $ScheduledNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledNotification"
    objects: {
      plantilla: Prisma.$NotificationTemplatePayload<ExtArgs>
      smtpAccount: Prisma.$SMTPAccountPayload<ExtArgs> | null
      creador: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plantillaId: string
      smtpAccountId: string | null
      destinatariosSeleccionados: Prisma.JsonValue
      fechaProgramada: Date
      estado: string
      recurrencia: string
      creadoPor: string | null
      fechaCreacion: Date
    }, ExtArgs["result"]["scheduledNotification"]>
    composites: {}
  }

  type ScheduledNotificationGetPayload<S extends boolean | null | undefined | ScheduledNotificationDefaultArgs> = $Result.GetResult<Prisma.$ScheduledNotificationPayload, S>

  type ScheduledNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledNotificationCountAggregateInputType | true
    }

  export interface ScheduledNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledNotification'], meta: { name: 'ScheduledNotification' } }
    /**
     * Find zero or one ScheduledNotification that matches the filter.
     * @param {ScheduledNotificationFindUniqueArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledNotificationFindUniqueArgs>(args: SelectSubset<T, ScheduledNotificationFindUniqueArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledNotificationFindUniqueOrThrowArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindFirstArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledNotificationFindFirstArgs>(args?: SelectSubset<T, ScheduledNotificationFindFirstArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindFirstOrThrowArgs} args - Arguments to find a ScheduledNotification
     * @example
     * // Get one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledNotifications
     * const scheduledNotifications = await prisma.scheduledNotification.findMany()
     * 
     * // Get first 10 ScheduledNotifications
     * const scheduledNotifications = await prisma.scheduledNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledNotificationWithIdOnly = await prisma.scheduledNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledNotificationFindManyArgs>(args?: SelectSubset<T, ScheduledNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledNotification.
     * @param {ScheduledNotificationCreateArgs} args - Arguments to create a ScheduledNotification.
     * @example
     * // Create one ScheduledNotification
     * const ScheduledNotification = await prisma.scheduledNotification.create({
     *   data: {
     *     // ... data to create a ScheduledNotification
     *   }
     * })
     * 
     */
    create<T extends ScheduledNotificationCreateArgs>(args: SelectSubset<T, ScheduledNotificationCreateArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledNotifications.
     * @param {ScheduledNotificationCreateManyArgs} args - Arguments to create many ScheduledNotifications.
     * @example
     * // Create many ScheduledNotifications
     * const scheduledNotification = await prisma.scheduledNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledNotificationCreateManyArgs>(args?: SelectSubset<T, ScheduledNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScheduledNotification.
     * @param {ScheduledNotificationDeleteArgs} args - Arguments to delete one ScheduledNotification.
     * @example
     * // Delete one ScheduledNotification
     * const ScheduledNotification = await prisma.scheduledNotification.delete({
     *   where: {
     *     // ... filter to delete one ScheduledNotification
     *   }
     * })
     * 
     */
    delete<T extends ScheduledNotificationDeleteArgs>(args: SelectSubset<T, ScheduledNotificationDeleteArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledNotification.
     * @param {ScheduledNotificationUpdateArgs} args - Arguments to update one ScheduledNotification.
     * @example
     * // Update one ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledNotificationUpdateArgs>(args: SelectSubset<T, ScheduledNotificationUpdateArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledNotifications.
     * @param {ScheduledNotificationDeleteManyArgs} args - Arguments to filter ScheduledNotifications to delete.
     * @example
     * // Delete a few ScheduledNotifications
     * const { count } = await prisma.scheduledNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledNotificationDeleteManyArgs>(args?: SelectSubset<T, ScheduledNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledNotifications
     * const scheduledNotification = await prisma.scheduledNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledNotificationUpdateManyArgs>(args: SelectSubset<T, ScheduledNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledNotification.
     * @param {ScheduledNotificationUpsertArgs} args - Arguments to update or create a ScheduledNotification.
     * @example
     * // Update or create a ScheduledNotification
     * const scheduledNotification = await prisma.scheduledNotification.upsert({
     *   create: {
     *     // ... data to create a ScheduledNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledNotification we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledNotificationUpsertArgs>(args: SelectSubset<T, ScheduledNotificationUpsertArgs<ExtArgs>>): Prisma__ScheduledNotificationClient<$Result.GetResult<Prisma.$ScheduledNotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduledNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationCountArgs} args - Arguments to filter ScheduledNotifications to count.
     * @example
     * // Count the number of ScheduledNotifications
     * const count = await prisma.scheduledNotification.count({
     *   where: {
     *     // ... the filter for the ScheduledNotifications we want to count
     *   }
     * })
    **/
    count<T extends ScheduledNotificationCountArgs>(
      args?: Subset<T, ScheduledNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledNotificationAggregateArgs>(args: Subset<T, ScheduledNotificationAggregateArgs>): Prisma.PrismaPromise<GetScheduledNotificationAggregateType<T>>

    /**
     * Group by ScheduledNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledNotificationGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledNotification model
   */
  readonly fields: ScheduledNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plantilla<T extends NotificationTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplateDefaultArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    smtpAccount<T extends ScheduledNotification$smtpAccountArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledNotification$smtpAccountArgs<ExtArgs>>): Prisma__SMTPAccountClient<$Result.GetResult<Prisma.$SMTPAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creador<T extends ScheduledNotification$creadorArgs<ExtArgs> = {}>(args?: Subset<T, ScheduledNotification$creadorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledNotification model
   */
  interface ScheduledNotificationFieldRefs {
    readonly id: FieldRef<"ScheduledNotification", 'String'>
    readonly plantillaId: FieldRef<"ScheduledNotification", 'String'>
    readonly smtpAccountId: FieldRef<"ScheduledNotification", 'String'>
    readonly destinatariosSeleccionados: FieldRef<"ScheduledNotification", 'Json'>
    readonly fechaProgramada: FieldRef<"ScheduledNotification", 'DateTime'>
    readonly estado: FieldRef<"ScheduledNotification", 'String'>
    readonly recurrencia: FieldRef<"ScheduledNotification", 'String'>
    readonly creadoPor: FieldRef<"ScheduledNotification", 'String'>
    readonly fechaCreacion: FieldRef<"ScheduledNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledNotification findUnique
   */
  export type ScheduledNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification findUniqueOrThrow
   */
  export type ScheduledNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification findFirst
   */
  export type ScheduledNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledNotifications.
     */
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification findFirstOrThrow
   */
  export type ScheduledNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledNotification to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledNotifications.
     */
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification findMany
   */
  export type ScheduledNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter, which ScheduledNotifications to fetch.
     */
    where?: ScheduledNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledNotifications to fetch.
     */
    orderBy?: ScheduledNotificationOrderByWithRelationInput | ScheduledNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledNotifications.
     */
    cursor?: ScheduledNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledNotifications.
     */
    skip?: number
    distinct?: ScheduledNotificationScalarFieldEnum | ScheduledNotificationScalarFieldEnum[]
  }

  /**
   * ScheduledNotification create
   */
  export type ScheduledNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduledNotification.
     */
    data: XOR<ScheduledNotificationCreateInput, ScheduledNotificationUncheckedCreateInput>
  }

  /**
   * ScheduledNotification createMany
   */
  export type ScheduledNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledNotifications.
     */
    data: ScheduledNotificationCreateManyInput | ScheduledNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduledNotification update
   */
  export type ScheduledNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduledNotification.
     */
    data: XOR<ScheduledNotificationUpdateInput, ScheduledNotificationUncheckedUpdateInput>
    /**
     * Choose, which ScheduledNotification to update.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification updateMany
   */
  export type ScheduledNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledNotifications.
     */
    data: XOR<ScheduledNotificationUpdateManyMutationInput, ScheduledNotificationUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledNotifications to update
     */
    where?: ScheduledNotificationWhereInput
    /**
     * Limit how many ScheduledNotifications to update.
     */
    limit?: number
  }

  /**
   * ScheduledNotification upsert
   */
  export type ScheduledNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduledNotification to update in case it exists.
     */
    where: ScheduledNotificationWhereUniqueInput
    /**
     * In case the ScheduledNotification found by the `where` argument doesn't exist, create a new ScheduledNotification with this data.
     */
    create: XOR<ScheduledNotificationCreateInput, ScheduledNotificationUncheckedCreateInput>
    /**
     * In case the ScheduledNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledNotificationUpdateInput, ScheduledNotificationUncheckedUpdateInput>
  }

  /**
   * ScheduledNotification delete
   */
  export type ScheduledNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
    /**
     * Filter which ScheduledNotification to delete.
     */
    where: ScheduledNotificationWhereUniqueInput
  }

  /**
   * ScheduledNotification deleteMany
   */
  export type ScheduledNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledNotifications to delete
     */
    where?: ScheduledNotificationWhereInput
    /**
     * Limit how many ScheduledNotifications to delete.
     */
    limit?: number
  }

  /**
   * ScheduledNotification.smtpAccount
   */
  export type ScheduledNotification$smtpAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SMTPAccount
     */
    select?: SMTPAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SMTPAccount
     */
    omit?: SMTPAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SMTPAccountInclude<ExtArgs> | null
    where?: SMTPAccountWhereInput
  }

  /**
   * ScheduledNotification.creador
   */
  export type ScheduledNotification$creadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ScheduledNotification without action
   */
  export type ScheduledNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledNotification
     */
    select?: ScheduledNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledNotification
     */
    omit?: ScheduledNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduledNotificationInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    isEditable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    isEditable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    isEditable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isEditable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isEditable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    isEditable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    isEditable: boolean
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isEditable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>



  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    isEditable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "isEditable" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      isEditable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly isEditable: FieldRef<"SystemConfig", 'Boolean'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model SystemBackup
   */

  export type AggregateSystemBackup = {
    _count: SystemBackupCountAggregateOutputType | null
    _avg: SystemBackupAvgAggregateOutputType | null
    _sum: SystemBackupSumAggregateOutputType | null
    _min: SystemBackupMinAggregateOutputType | null
    _max: SystemBackupMaxAggregateOutputType | null
  }

  export type SystemBackupAvgAggregateOutputType = {
    dbSize: number | null
    filesSize: number | null
  }

  export type SystemBackupSumAggregateOutputType = {
    dbSize: bigint | null
    filesSize: bigint | null
  }

  export type SystemBackupMinAggregateOutputType = {
    id: string | null
    version: string | null
    dbFile: string | null
    filesFile: string | null
    dbSize: bigint | null
    filesSize: bigint | null
    status: $Enums.BackupStatus | null
    errorMessage: string | null
    createdBy: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type SystemBackupMaxAggregateOutputType = {
    id: string | null
    version: string | null
    dbFile: string | null
    filesFile: string | null
    dbSize: bigint | null
    filesSize: bigint | null
    status: $Enums.BackupStatus | null
    errorMessage: string | null
    createdBy: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type SystemBackupCountAggregateOutputType = {
    id: number
    version: number
    dbFile: number
    filesFile: number
    dbSize: number
    filesSize: number
    status: number
    errorMessage: number
    createdBy: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type SystemBackupAvgAggregateInputType = {
    dbSize?: true
    filesSize?: true
  }

  export type SystemBackupSumAggregateInputType = {
    dbSize?: true
    filesSize?: true
  }

  export type SystemBackupMinAggregateInputType = {
    id?: true
    version?: true
    dbFile?: true
    filesFile?: true
    dbSize?: true
    filesSize?: true
    status?: true
    errorMessage?: true
    createdBy?: true
    createdAt?: true
    completedAt?: true
  }

  export type SystemBackupMaxAggregateInputType = {
    id?: true
    version?: true
    dbFile?: true
    filesFile?: true
    dbSize?: true
    filesSize?: true
    status?: true
    errorMessage?: true
    createdBy?: true
    createdAt?: true
    completedAt?: true
  }

  export type SystemBackupCountAggregateInputType = {
    id?: true
    version?: true
    dbFile?: true
    filesFile?: true
    dbSize?: true
    filesSize?: true
    status?: true
    errorMessage?: true
    createdBy?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type SystemBackupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemBackup to aggregate.
     */
    where?: SystemBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemBackups to fetch.
     */
    orderBy?: SystemBackupOrderByWithRelationInput | SystemBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemBackups
    **/
    _count?: true | SystemBackupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemBackupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemBackupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemBackupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemBackupMaxAggregateInputType
  }

  export type GetSystemBackupAggregateType<T extends SystemBackupAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemBackup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemBackup[P]>
      : GetScalarType<T[P], AggregateSystemBackup[P]>
  }




  export type SystemBackupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemBackupWhereInput
    orderBy?: SystemBackupOrderByWithAggregationInput | SystemBackupOrderByWithAggregationInput[]
    by: SystemBackupScalarFieldEnum[] | SystemBackupScalarFieldEnum
    having?: SystemBackupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemBackupCountAggregateInputType | true
    _avg?: SystemBackupAvgAggregateInputType
    _sum?: SystemBackupSumAggregateInputType
    _min?: SystemBackupMinAggregateInputType
    _max?: SystemBackupMaxAggregateInputType
  }

  export type SystemBackupGroupByOutputType = {
    id: string
    version: string
    dbFile: string
    filesFile: string
    dbSize: bigint
    filesSize: bigint
    status: $Enums.BackupStatus
    errorMessage: string | null
    createdBy: string | null
    createdAt: Date
    completedAt: Date | null
    _count: SystemBackupCountAggregateOutputType | null
    _avg: SystemBackupAvgAggregateOutputType | null
    _sum: SystemBackupSumAggregateOutputType | null
    _min: SystemBackupMinAggregateOutputType | null
    _max: SystemBackupMaxAggregateOutputType | null
  }

  type GetSystemBackupGroupByPayload<T extends SystemBackupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemBackupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemBackupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemBackupGroupByOutputType[P]>
            : GetScalarType<T[P], SystemBackupGroupByOutputType[P]>
        }
      >
    >


  export type SystemBackupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    version?: boolean
    dbFile?: boolean
    filesFile?: boolean
    dbSize?: boolean
    filesSize?: boolean
    status?: boolean
    errorMessage?: boolean
    createdBy?: boolean
    createdAt?: boolean
    completedAt?: boolean
    creator?: boolean | SystemBackup$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["systemBackup"]>



  export type SystemBackupSelectScalar = {
    id?: boolean
    version?: boolean
    dbFile?: boolean
    filesFile?: boolean
    dbSize?: boolean
    filesSize?: boolean
    status?: boolean
    errorMessage?: boolean
    createdBy?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type SystemBackupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "version" | "dbFile" | "filesFile" | "dbSize" | "filesSize" | "status" | "errorMessage" | "createdBy" | "createdAt" | "completedAt", ExtArgs["result"]["systemBackup"]>
  export type SystemBackupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | SystemBackup$creatorArgs<ExtArgs>
  }

  export type $SystemBackupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemBackup"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      version: string
      dbFile: string
      filesFile: string
      dbSize: bigint
      filesSize: bigint
      status: $Enums.BackupStatus
      errorMessage: string | null
      createdBy: string | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["systemBackup"]>
    composites: {}
  }

  type SystemBackupGetPayload<S extends boolean | null | undefined | SystemBackupDefaultArgs> = $Result.GetResult<Prisma.$SystemBackupPayload, S>

  type SystemBackupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemBackupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemBackupCountAggregateInputType | true
    }

  export interface SystemBackupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemBackup'], meta: { name: 'SystemBackup' } }
    /**
     * Find zero or one SystemBackup that matches the filter.
     * @param {SystemBackupFindUniqueArgs} args - Arguments to find a SystemBackup
     * @example
     * // Get one SystemBackup
     * const systemBackup = await prisma.systemBackup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemBackupFindUniqueArgs>(args: SelectSubset<T, SystemBackupFindUniqueArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemBackup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemBackupFindUniqueOrThrowArgs} args - Arguments to find a SystemBackup
     * @example
     * // Get one SystemBackup
     * const systemBackup = await prisma.systemBackup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemBackupFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemBackupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemBackup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupFindFirstArgs} args - Arguments to find a SystemBackup
     * @example
     * // Get one SystemBackup
     * const systemBackup = await prisma.systemBackup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemBackupFindFirstArgs>(args?: SelectSubset<T, SystemBackupFindFirstArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemBackup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupFindFirstOrThrowArgs} args - Arguments to find a SystemBackup
     * @example
     * // Get one SystemBackup
     * const systemBackup = await prisma.systemBackup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemBackupFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemBackupFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemBackups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemBackups
     * const systemBackups = await prisma.systemBackup.findMany()
     * 
     * // Get first 10 SystemBackups
     * const systemBackups = await prisma.systemBackup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemBackupWithIdOnly = await prisma.systemBackup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemBackupFindManyArgs>(args?: SelectSubset<T, SystemBackupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemBackup.
     * @param {SystemBackupCreateArgs} args - Arguments to create a SystemBackup.
     * @example
     * // Create one SystemBackup
     * const SystemBackup = await prisma.systemBackup.create({
     *   data: {
     *     // ... data to create a SystemBackup
     *   }
     * })
     * 
     */
    create<T extends SystemBackupCreateArgs>(args: SelectSubset<T, SystemBackupCreateArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemBackups.
     * @param {SystemBackupCreateManyArgs} args - Arguments to create many SystemBackups.
     * @example
     * // Create many SystemBackups
     * const systemBackup = await prisma.systemBackup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemBackupCreateManyArgs>(args?: SelectSubset<T, SystemBackupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemBackup.
     * @param {SystemBackupDeleteArgs} args - Arguments to delete one SystemBackup.
     * @example
     * // Delete one SystemBackup
     * const SystemBackup = await prisma.systemBackup.delete({
     *   where: {
     *     // ... filter to delete one SystemBackup
     *   }
     * })
     * 
     */
    delete<T extends SystemBackupDeleteArgs>(args: SelectSubset<T, SystemBackupDeleteArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemBackup.
     * @param {SystemBackupUpdateArgs} args - Arguments to update one SystemBackup.
     * @example
     * // Update one SystemBackup
     * const systemBackup = await prisma.systemBackup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemBackupUpdateArgs>(args: SelectSubset<T, SystemBackupUpdateArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemBackups.
     * @param {SystemBackupDeleteManyArgs} args - Arguments to filter SystemBackups to delete.
     * @example
     * // Delete a few SystemBackups
     * const { count } = await prisma.systemBackup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemBackupDeleteManyArgs>(args?: SelectSubset<T, SystemBackupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemBackups
     * const systemBackup = await prisma.systemBackup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemBackupUpdateManyArgs>(args: SelectSubset<T, SystemBackupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemBackup.
     * @param {SystemBackupUpsertArgs} args - Arguments to update or create a SystemBackup.
     * @example
     * // Update or create a SystemBackup
     * const systemBackup = await prisma.systemBackup.upsert({
     *   create: {
     *     // ... data to create a SystemBackup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemBackup we want to update
     *   }
     * })
     */
    upsert<T extends SystemBackupUpsertArgs>(args: SelectSubset<T, SystemBackupUpsertArgs<ExtArgs>>): Prisma__SystemBackupClient<$Result.GetResult<Prisma.$SystemBackupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemBackups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupCountArgs} args - Arguments to filter SystemBackups to count.
     * @example
     * // Count the number of SystemBackups
     * const count = await prisma.systemBackup.count({
     *   where: {
     *     // ... the filter for the SystemBackups we want to count
     *   }
     * })
    **/
    count<T extends SystemBackupCountArgs>(
      args?: Subset<T, SystemBackupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemBackupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemBackupAggregateArgs>(args: Subset<T, SystemBackupAggregateArgs>): Prisma.PrismaPromise<GetSystemBackupAggregateType<T>>

    /**
     * Group by SystemBackup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemBackupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemBackupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemBackupGroupByArgs['orderBy'] }
        : { orderBy?: SystemBackupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemBackupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemBackupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemBackup model
   */
  readonly fields: SystemBackupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemBackup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemBackupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends SystemBackup$creatorArgs<ExtArgs> = {}>(args?: Subset<T, SystemBackup$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemBackup model
   */
  interface SystemBackupFieldRefs {
    readonly id: FieldRef<"SystemBackup", 'String'>
    readonly version: FieldRef<"SystemBackup", 'String'>
    readonly dbFile: FieldRef<"SystemBackup", 'String'>
    readonly filesFile: FieldRef<"SystemBackup", 'String'>
    readonly dbSize: FieldRef<"SystemBackup", 'BigInt'>
    readonly filesSize: FieldRef<"SystemBackup", 'BigInt'>
    readonly status: FieldRef<"SystemBackup", 'BackupStatus'>
    readonly errorMessage: FieldRef<"SystemBackup", 'String'>
    readonly createdBy: FieldRef<"SystemBackup", 'String'>
    readonly createdAt: FieldRef<"SystemBackup", 'DateTime'>
    readonly completedAt: FieldRef<"SystemBackup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemBackup findUnique
   */
  export type SystemBackupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter, which SystemBackup to fetch.
     */
    where: SystemBackupWhereUniqueInput
  }

  /**
   * SystemBackup findUniqueOrThrow
   */
  export type SystemBackupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter, which SystemBackup to fetch.
     */
    where: SystemBackupWhereUniqueInput
  }

  /**
   * SystemBackup findFirst
   */
  export type SystemBackupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter, which SystemBackup to fetch.
     */
    where?: SystemBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemBackups to fetch.
     */
    orderBy?: SystemBackupOrderByWithRelationInput | SystemBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemBackups.
     */
    cursor?: SystemBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemBackups.
     */
    distinct?: SystemBackupScalarFieldEnum | SystemBackupScalarFieldEnum[]
  }

  /**
   * SystemBackup findFirstOrThrow
   */
  export type SystemBackupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter, which SystemBackup to fetch.
     */
    where?: SystemBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemBackups to fetch.
     */
    orderBy?: SystemBackupOrderByWithRelationInput | SystemBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemBackups.
     */
    cursor?: SystemBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemBackups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemBackups.
     */
    distinct?: SystemBackupScalarFieldEnum | SystemBackupScalarFieldEnum[]
  }

  /**
   * SystemBackup findMany
   */
  export type SystemBackupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter, which SystemBackups to fetch.
     */
    where?: SystemBackupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemBackups to fetch.
     */
    orderBy?: SystemBackupOrderByWithRelationInput | SystemBackupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemBackups.
     */
    cursor?: SystemBackupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemBackups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemBackups.
     */
    skip?: number
    distinct?: SystemBackupScalarFieldEnum | SystemBackupScalarFieldEnum[]
  }

  /**
   * SystemBackup create
   */
  export type SystemBackupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemBackup.
     */
    data: XOR<SystemBackupCreateInput, SystemBackupUncheckedCreateInput>
  }

  /**
   * SystemBackup createMany
   */
  export type SystemBackupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemBackups.
     */
    data: SystemBackupCreateManyInput | SystemBackupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemBackup update
   */
  export type SystemBackupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemBackup.
     */
    data: XOR<SystemBackupUpdateInput, SystemBackupUncheckedUpdateInput>
    /**
     * Choose, which SystemBackup to update.
     */
    where: SystemBackupWhereUniqueInput
  }

  /**
   * SystemBackup updateMany
   */
  export type SystemBackupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemBackups.
     */
    data: XOR<SystemBackupUpdateManyMutationInput, SystemBackupUncheckedUpdateManyInput>
    /**
     * Filter which SystemBackups to update
     */
    where?: SystemBackupWhereInput
    /**
     * Limit how many SystemBackups to update.
     */
    limit?: number
  }

  /**
   * SystemBackup upsert
   */
  export type SystemBackupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemBackup to update in case it exists.
     */
    where: SystemBackupWhereUniqueInput
    /**
     * In case the SystemBackup found by the `where` argument doesn't exist, create a new SystemBackup with this data.
     */
    create: XOR<SystemBackupCreateInput, SystemBackupUncheckedCreateInput>
    /**
     * In case the SystemBackup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemBackupUpdateInput, SystemBackupUncheckedUpdateInput>
  }

  /**
   * SystemBackup delete
   */
  export type SystemBackupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
    /**
     * Filter which SystemBackup to delete.
     */
    where: SystemBackupWhereUniqueInput
  }

  /**
   * SystemBackup deleteMany
   */
  export type SystemBackupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemBackups to delete
     */
    where?: SystemBackupWhereInput
    /**
     * Limit how many SystemBackups to delete.
     */
    limit?: number
  }

  /**
   * SystemBackup.creator
   */
  export type SystemBackup$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemBackup without action
   */
  export type SystemBackupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemBackup
     */
    select?: SystemBackupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemBackup
     */
    omit?: SystemBackupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemBackupInclude<ExtArgs> | null
  }


  /**
   * Model SystemUpdate
   */

  export type AggregateSystemUpdate = {
    _count: SystemUpdateCountAggregateOutputType | null
    _min: SystemUpdateMinAggregateOutputType | null
    _max: SystemUpdateMaxAggregateOutputType | null
  }

  export type SystemUpdateMinAggregateOutputType = {
    id: string | null
    fromVersion: string | null
    toVersion: string | null
    status: $Enums.UpdateStatus | null
    backupId: string | null
    errorMessage: string | null
    initiatedBy: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateMaxAggregateOutputType = {
    id: string | null
    fromVersion: string | null
    toVersion: string | null
    status: $Enums.UpdateStatus | null
    backupId: string | null
    errorMessage: string | null
    initiatedBy: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type SystemUpdateCountAggregateOutputType = {
    id: number
    fromVersion: number
    toVersion: number
    status: number
    logs: number
    backupId: number
    errorMessage: number
    initiatedBy: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type SystemUpdateMinAggregateInputType = {
    id?: true
    fromVersion?: true
    toVersion?: true
    status?: true
    backupId?: true
    errorMessage?: true
    initiatedBy?: true
    createdAt?: true
    completedAt?: true
  }

  export type SystemUpdateMaxAggregateInputType = {
    id?: true
    fromVersion?: true
    toVersion?: true
    status?: true
    backupId?: true
    errorMessage?: true
    initiatedBy?: true
    createdAt?: true
    completedAt?: true
  }

  export type SystemUpdateCountAggregateInputType = {
    id?: true
    fromVersion?: true
    toVersion?: true
    status?: true
    logs?: true
    backupId?: true
    errorMessage?: true
    initiatedBy?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type SystemUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdate to aggregate.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemUpdates
    **/
    _count?: true | SystemUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemUpdateMaxAggregateInputType
  }

  export type GetSystemUpdateAggregateType<T extends SystemUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemUpdate[P]>
      : GetScalarType<T[P], AggregateSystemUpdate[P]>
  }




  export type SystemUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemUpdateWhereInput
    orderBy?: SystemUpdateOrderByWithAggregationInput | SystemUpdateOrderByWithAggregationInput[]
    by: SystemUpdateScalarFieldEnum[] | SystemUpdateScalarFieldEnum
    having?: SystemUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemUpdateCountAggregateInputType | true
    _min?: SystemUpdateMinAggregateInputType
    _max?: SystemUpdateMaxAggregateInputType
  }

  export type SystemUpdateGroupByOutputType = {
    id: string
    fromVersion: string
    toVersion: string
    status: $Enums.UpdateStatus
    logs: JsonValue | null
    backupId: string | null
    errorMessage: string | null
    initiatedBy: string | null
    createdAt: Date
    completedAt: Date | null
    _count: SystemUpdateCountAggregateOutputType | null
    _min: SystemUpdateMinAggregateOutputType | null
    _max: SystemUpdateMaxAggregateOutputType | null
  }

  type GetSystemUpdateGroupByPayload<T extends SystemUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], SystemUpdateGroupByOutputType[P]>
        }
      >
    >


  export type SystemUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    status?: boolean
    logs?: boolean
    backupId?: boolean
    errorMessage?: boolean
    initiatedBy?: boolean
    createdAt?: boolean
    completedAt?: boolean
    initiator?: boolean | SystemUpdate$initiatorArgs<ExtArgs>
  }, ExtArgs["result"]["systemUpdate"]>



  export type SystemUpdateSelectScalar = {
    id?: boolean
    fromVersion?: boolean
    toVersion?: boolean
    status?: boolean
    logs?: boolean
    backupId?: boolean
    errorMessage?: boolean
    initiatedBy?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type SystemUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromVersion" | "toVersion" | "status" | "logs" | "backupId" | "errorMessage" | "initiatedBy" | "createdAt" | "completedAt", ExtArgs["result"]["systemUpdate"]>
  export type SystemUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    initiator?: boolean | SystemUpdate$initiatorArgs<ExtArgs>
  }

  export type $SystemUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemUpdate"
    objects: {
      initiator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromVersion: string
      toVersion: string
      status: $Enums.UpdateStatus
      logs: Prisma.JsonValue | null
      backupId: string | null
      errorMessage: string | null
      initiatedBy: string | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["systemUpdate"]>
    composites: {}
  }

  type SystemUpdateGetPayload<S extends boolean | null | undefined | SystemUpdateDefaultArgs> = $Result.GetResult<Prisma.$SystemUpdatePayload, S>

  type SystemUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemUpdateCountAggregateInputType | true
    }

  export interface SystemUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemUpdate'], meta: { name: 'SystemUpdate' } }
    /**
     * Find zero or one SystemUpdate that matches the filter.
     * @param {SystemUpdateFindUniqueArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemUpdateFindUniqueArgs>(args: SelectSubset<T, SystemUpdateFindUniqueArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemUpdateFindUniqueOrThrowArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindFirstArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemUpdateFindFirstArgs>(args?: SelectSubset<T, SystemUpdateFindFirstArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindFirstOrThrowArgs} args - Arguments to find a SystemUpdate
     * @example
     * // Get one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemUpdates
     * const systemUpdates = await prisma.systemUpdate.findMany()
     * 
     * // Get first 10 SystemUpdates
     * const systemUpdates = await prisma.systemUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemUpdateWithIdOnly = await prisma.systemUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemUpdateFindManyArgs>(args?: SelectSubset<T, SystemUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemUpdate.
     * @param {SystemUpdateCreateArgs} args - Arguments to create a SystemUpdate.
     * @example
     * // Create one SystemUpdate
     * const SystemUpdate = await prisma.systemUpdate.create({
     *   data: {
     *     // ... data to create a SystemUpdate
     *   }
     * })
     * 
     */
    create<T extends SystemUpdateCreateArgs>(args: SelectSubset<T, SystemUpdateCreateArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemUpdates.
     * @param {SystemUpdateCreateManyArgs} args - Arguments to create many SystemUpdates.
     * @example
     * // Create many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemUpdateCreateManyArgs>(args?: SelectSubset<T, SystemUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemUpdate.
     * @param {SystemUpdateDeleteArgs} args - Arguments to delete one SystemUpdate.
     * @example
     * // Delete one SystemUpdate
     * const SystemUpdate = await prisma.systemUpdate.delete({
     *   where: {
     *     // ... filter to delete one SystemUpdate
     *   }
     * })
     * 
     */
    delete<T extends SystemUpdateDeleteArgs>(args: SelectSubset<T, SystemUpdateDeleteArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemUpdate.
     * @param {SystemUpdateUpdateArgs} args - Arguments to update one SystemUpdate.
     * @example
     * // Update one SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemUpdateUpdateArgs>(args: SelectSubset<T, SystemUpdateUpdateArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemUpdates.
     * @param {SystemUpdateDeleteManyArgs} args - Arguments to filter SystemUpdates to delete.
     * @example
     * // Delete a few SystemUpdates
     * const { count } = await prisma.systemUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemUpdateDeleteManyArgs>(args?: SelectSubset<T, SystemUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemUpdates
     * const systemUpdate = await prisma.systemUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemUpdateUpdateManyArgs>(args: SelectSubset<T, SystemUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemUpdate.
     * @param {SystemUpdateUpsertArgs} args - Arguments to update or create a SystemUpdate.
     * @example
     * // Update or create a SystemUpdate
     * const systemUpdate = await prisma.systemUpdate.upsert({
     *   create: {
     *     // ... data to create a SystemUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemUpdate we want to update
     *   }
     * })
     */
    upsert<T extends SystemUpdateUpsertArgs>(args: SelectSubset<T, SystemUpdateUpsertArgs<ExtArgs>>): Prisma__SystemUpdateClient<$Result.GetResult<Prisma.$SystemUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateCountArgs} args - Arguments to filter SystemUpdates to count.
     * @example
     * // Count the number of SystemUpdates
     * const count = await prisma.systemUpdate.count({
     *   where: {
     *     // ... the filter for the SystemUpdates we want to count
     *   }
     * })
    **/
    count<T extends SystemUpdateCountArgs>(
      args?: Subset<T, SystemUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemUpdateAggregateArgs>(args: Subset<T, SystemUpdateAggregateArgs>): Prisma.PrismaPromise<GetSystemUpdateAggregateType<T>>

    /**
     * Group by SystemUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemUpdateGroupByArgs['orderBy'] }
        : { orderBy?: SystemUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemUpdate model
   */
  readonly fields: SystemUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    initiator<T extends SystemUpdate$initiatorArgs<ExtArgs> = {}>(args?: Subset<T, SystemUpdate$initiatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemUpdate model
   */
  interface SystemUpdateFieldRefs {
    readonly id: FieldRef<"SystemUpdate", 'String'>
    readonly fromVersion: FieldRef<"SystemUpdate", 'String'>
    readonly toVersion: FieldRef<"SystemUpdate", 'String'>
    readonly status: FieldRef<"SystemUpdate", 'UpdateStatus'>
    readonly logs: FieldRef<"SystemUpdate", 'Json'>
    readonly backupId: FieldRef<"SystemUpdate", 'String'>
    readonly errorMessage: FieldRef<"SystemUpdate", 'String'>
    readonly initiatedBy: FieldRef<"SystemUpdate", 'String'>
    readonly createdAt: FieldRef<"SystemUpdate", 'DateTime'>
    readonly completedAt: FieldRef<"SystemUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemUpdate findUnique
   */
  export type SystemUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate findUniqueOrThrow
   */
  export type SystemUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate findFirst
   */
  export type SystemUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdates.
     */
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate findFirstOrThrow
   */
  export type SystemUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdate to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemUpdates.
     */
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate findMany
   */
  export type SystemUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter, which SystemUpdates to fetch.
     */
    where?: SystemUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemUpdates to fetch.
     */
    orderBy?: SystemUpdateOrderByWithRelationInput | SystemUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemUpdates.
     */
    cursor?: SystemUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemUpdates.
     */
    skip?: number
    distinct?: SystemUpdateScalarFieldEnum | SystemUpdateScalarFieldEnum[]
  }

  /**
   * SystemUpdate create
   */
  export type SystemUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemUpdate.
     */
    data: XOR<SystemUpdateCreateInput, SystemUpdateUncheckedCreateInput>
  }

  /**
   * SystemUpdate createMany
   */
  export type SystemUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemUpdates.
     */
    data: SystemUpdateCreateManyInput | SystemUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemUpdate update
   */
  export type SystemUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemUpdate.
     */
    data: XOR<SystemUpdateUpdateInput, SystemUpdateUncheckedUpdateInput>
    /**
     * Choose, which SystemUpdate to update.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate updateMany
   */
  export type SystemUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemUpdates.
     */
    data: XOR<SystemUpdateUpdateManyMutationInput, SystemUpdateUncheckedUpdateManyInput>
    /**
     * Filter which SystemUpdates to update
     */
    where?: SystemUpdateWhereInput
    /**
     * Limit how many SystemUpdates to update.
     */
    limit?: number
  }

  /**
   * SystemUpdate upsert
   */
  export type SystemUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemUpdate to update in case it exists.
     */
    where: SystemUpdateWhereUniqueInput
    /**
     * In case the SystemUpdate found by the `where` argument doesn't exist, create a new SystemUpdate with this data.
     */
    create: XOR<SystemUpdateCreateInput, SystemUpdateUncheckedCreateInput>
    /**
     * In case the SystemUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemUpdateUpdateInput, SystemUpdateUncheckedUpdateInput>
  }

  /**
   * SystemUpdate delete
   */
  export type SystemUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
    /**
     * Filter which SystemUpdate to delete.
     */
    where: SystemUpdateWhereUniqueInput
  }

  /**
   * SystemUpdate deleteMany
   */
  export type SystemUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemUpdates to delete
     */
    where?: SystemUpdateWhereInput
    /**
     * Limit how many SystemUpdates to delete.
     */
    limit?: number
  }

  /**
   * SystemUpdate.initiator
   */
  export type SystemUpdate$initiatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SystemUpdate without action
   */
  export type SystemUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemUpdate
     */
    select?: SystemUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemUpdate
     */
    omit?: SystemUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemUpdateInclude<ExtArgs> | null
  }


  /**
   * Model StorageConfig
   */

  export type AggregateStorageConfig = {
    _count: StorageConfigCountAggregateOutputType | null
    _avg: StorageConfigAvgAggregateOutputType | null
    _sum: StorageConfigSumAggregateOutputType | null
    _min: StorageConfigMinAggregateOutputType | null
    _max: StorageConfigMaxAggregateOutputType | null
  }

  export type StorageConfigAvgAggregateOutputType = {
    port: number | null
  }

  export type StorageConfigSumAggregateOutputType = {
    port: number | null
  }

  export type StorageConfigMinAggregateOutputType = {
    id: string | null
    type: $Enums.StorageType | null
    name: string | null
    host: string | null
    port: number | null
    username: string | null
    encryptedPassword: string | null
    basePath: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageConfigMaxAggregateOutputType = {
    id: string | null
    type: $Enums.StorageType | null
    name: string | null
    host: string | null
    port: number | null
    username: string | null
    encryptedPassword: string | null
    basePath: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageConfigCountAggregateOutputType = {
    id: number
    type: number
    name: number
    host: number
    port: number
    username: number
    encryptedPassword: number
    basePath: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageConfigAvgAggregateInputType = {
    port?: true
  }

  export type StorageConfigSumAggregateInputType = {
    port?: true
  }

  export type StorageConfigMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    host?: true
    port?: true
    username?: true
    encryptedPassword?: true
    basePath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageConfigMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    host?: true
    port?: true
    username?: true
    encryptedPassword?: true
    basePath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageConfigCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    host?: true
    port?: true
    username?: true
    encryptedPassword?: true
    basePath?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageConfig to aggregate.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageConfigs
    **/
    _count?: true | StorageConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageConfigMaxAggregateInputType
  }

  export type GetStorageConfigAggregateType<T extends StorageConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageConfig[P]>
      : GetScalarType<T[P], AggregateStorageConfig[P]>
  }




  export type StorageConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageConfigWhereInput
    orderBy?: StorageConfigOrderByWithAggregationInput | StorageConfigOrderByWithAggregationInput[]
    by: StorageConfigScalarFieldEnum[] | StorageConfigScalarFieldEnum
    having?: StorageConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageConfigCountAggregateInputType | true
    _avg?: StorageConfigAvgAggregateInputType
    _sum?: StorageConfigSumAggregateInputType
    _min?: StorageConfigMinAggregateInputType
    _max?: StorageConfigMaxAggregateInputType
  }

  export type StorageConfigGroupByOutputType = {
    id: string
    type: $Enums.StorageType
    name: string
    host: string | null
    port: number | null
    username: string | null
    encryptedPassword: string | null
    basePath: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StorageConfigCountAggregateOutputType | null
    _avg: StorageConfigAvgAggregateOutputType | null
    _sum: StorageConfigSumAggregateOutputType | null
    _min: StorageConfigMinAggregateOutputType | null
    _max: StorageConfigMaxAggregateOutputType | null
  }

  type GetStorageConfigGroupByPayload<T extends StorageConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageConfigGroupByOutputType[P]>
            : GetScalarType<T[P], StorageConfigGroupByOutputType[P]>
        }
      >
    >


  export type StorageConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    username?: boolean
    encryptedPassword?: boolean
    basePath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["storageConfig"]>



  export type StorageConfigSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    host?: boolean
    port?: boolean
    username?: boolean
    encryptedPassword?: boolean
    basePath?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorageConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "host" | "port" | "username" | "encryptedPassword" | "basePath" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["storageConfig"]>

  export type $StorageConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.StorageType
      name: string
      host: string | null
      port: number | null
      username: string | null
      encryptedPassword: string | null
      basePath: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageConfig"]>
    composites: {}
  }

  type StorageConfigGetPayload<S extends boolean | null | undefined | StorageConfigDefaultArgs> = $Result.GetResult<Prisma.$StorageConfigPayload, S>

  type StorageConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StorageConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StorageConfigCountAggregateInputType | true
    }

  export interface StorageConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageConfig'], meta: { name: 'StorageConfig' } }
    /**
     * Find zero or one StorageConfig that matches the filter.
     * @param {StorageConfigFindUniqueArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageConfigFindUniqueArgs>(args: SelectSubset<T, StorageConfigFindUniqueArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StorageConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StorageConfigFindUniqueOrThrowArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindFirstArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageConfigFindFirstArgs>(args?: SelectSubset<T, StorageConfigFindFirstArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindFirstOrThrowArgs} args - Arguments to find a StorageConfig
     * @example
     * // Get one StorageConfig
     * const storageConfig = await prisma.storageConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StorageConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageConfigs
     * const storageConfigs = await prisma.storageConfig.findMany()
     * 
     * // Get first 10 StorageConfigs
     * const storageConfigs = await prisma.storageConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageConfigWithIdOnly = await prisma.storageConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageConfigFindManyArgs>(args?: SelectSubset<T, StorageConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StorageConfig.
     * @param {StorageConfigCreateArgs} args - Arguments to create a StorageConfig.
     * @example
     * // Create one StorageConfig
     * const StorageConfig = await prisma.storageConfig.create({
     *   data: {
     *     // ... data to create a StorageConfig
     *   }
     * })
     * 
     */
    create<T extends StorageConfigCreateArgs>(args: SelectSubset<T, StorageConfigCreateArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StorageConfigs.
     * @param {StorageConfigCreateManyArgs} args - Arguments to create many StorageConfigs.
     * @example
     * // Create many StorageConfigs
     * const storageConfig = await prisma.storageConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageConfigCreateManyArgs>(args?: SelectSubset<T, StorageConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StorageConfig.
     * @param {StorageConfigDeleteArgs} args - Arguments to delete one StorageConfig.
     * @example
     * // Delete one StorageConfig
     * const StorageConfig = await prisma.storageConfig.delete({
     *   where: {
     *     // ... filter to delete one StorageConfig
     *   }
     * })
     * 
     */
    delete<T extends StorageConfigDeleteArgs>(args: SelectSubset<T, StorageConfigDeleteArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StorageConfig.
     * @param {StorageConfigUpdateArgs} args - Arguments to update one StorageConfig.
     * @example
     * // Update one StorageConfig
     * const storageConfig = await prisma.storageConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageConfigUpdateArgs>(args: SelectSubset<T, StorageConfigUpdateArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StorageConfigs.
     * @param {StorageConfigDeleteManyArgs} args - Arguments to filter StorageConfigs to delete.
     * @example
     * // Delete a few StorageConfigs
     * const { count } = await prisma.storageConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageConfigDeleteManyArgs>(args?: SelectSubset<T, StorageConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageConfigs
     * const storageConfig = await prisma.storageConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageConfigUpdateManyArgs>(args: SelectSubset<T, StorageConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StorageConfig.
     * @param {StorageConfigUpsertArgs} args - Arguments to update or create a StorageConfig.
     * @example
     * // Update or create a StorageConfig
     * const storageConfig = await prisma.storageConfig.upsert({
     *   create: {
     *     // ... data to create a StorageConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageConfig we want to update
     *   }
     * })
     */
    upsert<T extends StorageConfigUpsertArgs>(args: SelectSubset<T, StorageConfigUpsertArgs<ExtArgs>>): Prisma__StorageConfigClient<$Result.GetResult<Prisma.$StorageConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StorageConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigCountArgs} args - Arguments to filter StorageConfigs to count.
     * @example
     * // Count the number of StorageConfigs
     * const count = await prisma.storageConfig.count({
     *   where: {
     *     // ... the filter for the StorageConfigs we want to count
     *   }
     * })
    **/
    count<T extends StorageConfigCountArgs>(
      args?: Subset<T, StorageConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageConfigAggregateArgs>(args: Subset<T, StorageConfigAggregateArgs>): Prisma.PrismaPromise<GetStorageConfigAggregateType<T>>

    /**
     * Group by StorageConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageConfigGroupByArgs['orderBy'] }
        : { orderBy?: StorageConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageConfig model
   */
  readonly fields: StorageConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageConfig model
   */
  interface StorageConfigFieldRefs {
    readonly id: FieldRef<"StorageConfig", 'String'>
    readonly type: FieldRef<"StorageConfig", 'StorageType'>
    readonly name: FieldRef<"StorageConfig", 'String'>
    readonly host: FieldRef<"StorageConfig", 'String'>
    readonly port: FieldRef<"StorageConfig", 'Int'>
    readonly username: FieldRef<"StorageConfig", 'String'>
    readonly encryptedPassword: FieldRef<"StorageConfig", 'String'>
    readonly basePath: FieldRef<"StorageConfig", 'String'>
    readonly isActive: FieldRef<"StorageConfig", 'Boolean'>
    readonly createdAt: FieldRef<"StorageConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageConfig findUnique
   */
  export type StorageConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig findUniqueOrThrow
   */
  export type StorageConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig findFirst
   */
  export type StorageConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageConfigs.
     */
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig findFirstOrThrow
   */
  export type StorageConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter, which StorageConfig to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageConfigs.
     */
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig findMany
   */
  export type StorageConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter, which StorageConfigs to fetch.
     */
    where?: StorageConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageConfigs to fetch.
     */
    orderBy?: StorageConfigOrderByWithRelationInput | StorageConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageConfigs.
     */
    cursor?: StorageConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageConfigs.
     */
    skip?: number
    distinct?: StorageConfigScalarFieldEnum | StorageConfigScalarFieldEnum[]
  }

  /**
   * StorageConfig create
   */
  export type StorageConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a StorageConfig.
     */
    data: XOR<StorageConfigCreateInput, StorageConfigUncheckedCreateInput>
  }

  /**
   * StorageConfig createMany
   */
  export type StorageConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageConfigs.
     */
    data: StorageConfigCreateManyInput | StorageConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageConfig update
   */
  export type StorageConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a StorageConfig.
     */
    data: XOR<StorageConfigUpdateInput, StorageConfigUncheckedUpdateInput>
    /**
     * Choose, which StorageConfig to update.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig updateMany
   */
  export type StorageConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageConfigs.
     */
    data: XOR<StorageConfigUpdateManyMutationInput, StorageConfigUncheckedUpdateManyInput>
    /**
     * Filter which StorageConfigs to update
     */
    where?: StorageConfigWhereInput
    /**
     * Limit how many StorageConfigs to update.
     */
    limit?: number
  }

  /**
   * StorageConfig upsert
   */
  export type StorageConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the StorageConfig to update in case it exists.
     */
    where: StorageConfigWhereUniqueInput
    /**
     * In case the StorageConfig found by the `where` argument doesn't exist, create a new StorageConfig with this data.
     */
    create: XOR<StorageConfigCreateInput, StorageConfigUncheckedCreateInput>
    /**
     * In case the StorageConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageConfigUpdateInput, StorageConfigUncheckedUpdateInput>
  }

  /**
   * StorageConfig delete
   */
  export type StorageConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
    /**
     * Filter which StorageConfig to delete.
     */
    where: StorageConfigWhereUniqueInput
  }

  /**
   * StorageConfig deleteMany
   */
  export type StorageConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageConfigs to delete
     */
    where?: StorageConfigWhereInput
    /**
     * Limit how many StorageConfigs to delete.
     */
    limit?: number
  }

  /**
   * StorageConfig without action
   */
  export type StorageConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageConfig
     */
    select?: StorageConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageConfig
     */
    omit?: StorageConfigOmit<ExtArgs> | null
  }


  /**
   * Model Impuesto
   */

  export type AggregateImpuesto = {
    _count: ImpuestoCountAggregateOutputType | null
    _min: ImpuestoMinAggregateOutputType | null
    _max: ImpuestoMaxAggregateOutputType | null
  }

  export type ImpuestoMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    modelo: string | null
    descripcion: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpuestoMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    modelo: string | null
    descripcion: string | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ImpuestoCountAggregateOutputType = {
    id: number
    nombre: number
    modelo: number
    descripcion: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ImpuestoMinAggregateInputType = {
    id?: true
    nombre?: true
    modelo?: true
    descripcion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpuestoMaxAggregateInputType = {
    id?: true
    nombre?: true
    modelo?: true
    descripcion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ImpuestoCountAggregateInputType = {
    id?: true
    nombre?: true
    modelo?: true
    descripcion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ImpuestoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impuesto to aggregate.
     */
    where?: ImpuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impuestos to fetch.
     */
    orderBy?: ImpuestoOrderByWithRelationInput | ImpuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImpuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Impuestos
    **/
    _count?: true | ImpuestoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImpuestoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImpuestoMaxAggregateInputType
  }

  export type GetImpuestoAggregateType<T extends ImpuestoAggregateArgs> = {
        [P in keyof T & keyof AggregateImpuesto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImpuesto[P]>
      : GetScalarType<T[P], AggregateImpuesto[P]>
  }




  export type ImpuestoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImpuestoWhereInput
    orderBy?: ImpuestoOrderByWithAggregationInput | ImpuestoOrderByWithAggregationInput[]
    by: ImpuestoScalarFieldEnum[] | ImpuestoScalarFieldEnum
    having?: ImpuestoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImpuestoCountAggregateInputType | true
    _min?: ImpuestoMinAggregateInputType
    _max?: ImpuestoMaxAggregateInputType
  }

  export type ImpuestoGroupByOutputType = {
    id: string
    nombre: string
    modelo: string
    descripcion: string | null
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ImpuestoCountAggregateOutputType | null
    _min: ImpuestoMinAggregateOutputType | null
    _max: ImpuestoMaxAggregateOutputType | null
  }

  type GetImpuestoGroupByPayload<T extends ImpuestoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImpuestoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImpuestoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImpuestoGroupByOutputType[P]>
            : GetScalarType<T[P], ImpuestoGroupByOutputType[P]>
        }
      >
    >


  export type ImpuestoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    modelo?: boolean
    descripcion?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obligaciones?: boolean | Impuesto$obligacionesArgs<ExtArgs>
    _count?: boolean | ImpuestoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["impuesto"]>



  export type ImpuestoSelectScalar = {
    id?: boolean
    nombre?: boolean
    modelo?: boolean
    descripcion?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ImpuestoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "modelo" | "descripcion" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["impuesto"]>
  export type ImpuestoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obligaciones?: boolean | Impuesto$obligacionesArgs<ExtArgs>
    _count?: boolean | ImpuestoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ImpuestoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Impuesto"
    objects: {
      obligaciones: Prisma.$ObligacionFiscalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      modelo: string
      descripcion: string | null
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["impuesto"]>
    composites: {}
  }

  type ImpuestoGetPayload<S extends boolean | null | undefined | ImpuestoDefaultArgs> = $Result.GetResult<Prisma.$ImpuestoPayload, S>

  type ImpuestoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImpuestoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImpuestoCountAggregateInputType | true
    }

  export interface ImpuestoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Impuesto'], meta: { name: 'Impuesto' } }
    /**
     * Find zero or one Impuesto that matches the filter.
     * @param {ImpuestoFindUniqueArgs} args - Arguments to find a Impuesto
     * @example
     * // Get one Impuesto
     * const impuesto = await prisma.impuesto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImpuestoFindUniqueArgs>(args: SelectSubset<T, ImpuestoFindUniqueArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Impuesto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImpuestoFindUniqueOrThrowArgs} args - Arguments to find a Impuesto
     * @example
     * // Get one Impuesto
     * const impuesto = await prisma.impuesto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImpuestoFindUniqueOrThrowArgs>(args: SelectSubset<T, ImpuestoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impuesto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoFindFirstArgs} args - Arguments to find a Impuesto
     * @example
     * // Get one Impuesto
     * const impuesto = await prisma.impuesto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImpuestoFindFirstArgs>(args?: SelectSubset<T, ImpuestoFindFirstArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Impuesto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoFindFirstOrThrowArgs} args - Arguments to find a Impuesto
     * @example
     * // Get one Impuesto
     * const impuesto = await prisma.impuesto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImpuestoFindFirstOrThrowArgs>(args?: SelectSubset<T, ImpuestoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Impuestos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Impuestos
     * const impuestos = await prisma.impuesto.findMany()
     * 
     * // Get first 10 Impuestos
     * const impuestos = await prisma.impuesto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const impuestoWithIdOnly = await prisma.impuesto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImpuestoFindManyArgs>(args?: SelectSubset<T, ImpuestoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Impuesto.
     * @param {ImpuestoCreateArgs} args - Arguments to create a Impuesto.
     * @example
     * // Create one Impuesto
     * const Impuesto = await prisma.impuesto.create({
     *   data: {
     *     // ... data to create a Impuesto
     *   }
     * })
     * 
     */
    create<T extends ImpuestoCreateArgs>(args: SelectSubset<T, ImpuestoCreateArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Impuestos.
     * @param {ImpuestoCreateManyArgs} args - Arguments to create many Impuestos.
     * @example
     * // Create many Impuestos
     * const impuesto = await prisma.impuesto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImpuestoCreateManyArgs>(args?: SelectSubset<T, ImpuestoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Impuesto.
     * @param {ImpuestoDeleteArgs} args - Arguments to delete one Impuesto.
     * @example
     * // Delete one Impuesto
     * const Impuesto = await prisma.impuesto.delete({
     *   where: {
     *     // ... filter to delete one Impuesto
     *   }
     * })
     * 
     */
    delete<T extends ImpuestoDeleteArgs>(args: SelectSubset<T, ImpuestoDeleteArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Impuesto.
     * @param {ImpuestoUpdateArgs} args - Arguments to update one Impuesto.
     * @example
     * // Update one Impuesto
     * const impuesto = await prisma.impuesto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImpuestoUpdateArgs>(args: SelectSubset<T, ImpuestoUpdateArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Impuestos.
     * @param {ImpuestoDeleteManyArgs} args - Arguments to filter Impuestos to delete.
     * @example
     * // Delete a few Impuestos
     * const { count } = await prisma.impuesto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImpuestoDeleteManyArgs>(args?: SelectSubset<T, ImpuestoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Impuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Impuestos
     * const impuesto = await prisma.impuesto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImpuestoUpdateManyArgs>(args: SelectSubset<T, ImpuestoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Impuesto.
     * @param {ImpuestoUpsertArgs} args - Arguments to update or create a Impuesto.
     * @example
     * // Update or create a Impuesto
     * const impuesto = await prisma.impuesto.upsert({
     *   create: {
     *     // ... data to create a Impuesto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Impuesto we want to update
     *   }
     * })
     */
    upsert<T extends ImpuestoUpsertArgs>(args: SelectSubset<T, ImpuestoUpsertArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Impuestos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoCountArgs} args - Arguments to filter Impuestos to count.
     * @example
     * // Count the number of Impuestos
     * const count = await prisma.impuesto.count({
     *   where: {
     *     // ... the filter for the Impuestos we want to count
     *   }
     * })
    **/
    count<T extends ImpuestoCountArgs>(
      args?: Subset<T, ImpuestoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImpuestoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Impuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImpuestoAggregateArgs>(args: Subset<T, ImpuestoAggregateArgs>): Prisma.PrismaPromise<GetImpuestoAggregateType<T>>

    /**
     * Group by Impuesto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImpuestoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImpuestoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImpuestoGroupByArgs['orderBy'] }
        : { orderBy?: ImpuestoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImpuestoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImpuestoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Impuesto model
   */
  readonly fields: ImpuestoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Impuesto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImpuestoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obligaciones<T extends Impuesto$obligacionesArgs<ExtArgs> = {}>(args?: Subset<T, Impuesto$obligacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Impuesto model
   */
  interface ImpuestoFieldRefs {
    readonly id: FieldRef<"Impuesto", 'String'>
    readonly nombre: FieldRef<"Impuesto", 'String'>
    readonly modelo: FieldRef<"Impuesto", 'String'>
    readonly descripcion: FieldRef<"Impuesto", 'String'>
    readonly activo: FieldRef<"Impuesto", 'Boolean'>
    readonly createdAt: FieldRef<"Impuesto", 'DateTime'>
    readonly updatedAt: FieldRef<"Impuesto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Impuesto findUnique
   */
  export type ImpuestoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter, which Impuesto to fetch.
     */
    where: ImpuestoWhereUniqueInput
  }

  /**
   * Impuesto findUniqueOrThrow
   */
  export type ImpuestoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter, which Impuesto to fetch.
     */
    where: ImpuestoWhereUniqueInput
  }

  /**
   * Impuesto findFirst
   */
  export type ImpuestoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter, which Impuesto to fetch.
     */
    where?: ImpuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impuestos to fetch.
     */
    orderBy?: ImpuestoOrderByWithRelationInput | ImpuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impuestos.
     */
    cursor?: ImpuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impuestos.
     */
    distinct?: ImpuestoScalarFieldEnum | ImpuestoScalarFieldEnum[]
  }

  /**
   * Impuesto findFirstOrThrow
   */
  export type ImpuestoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter, which Impuesto to fetch.
     */
    where?: ImpuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impuestos to fetch.
     */
    orderBy?: ImpuestoOrderByWithRelationInput | ImpuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Impuestos.
     */
    cursor?: ImpuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impuestos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Impuestos.
     */
    distinct?: ImpuestoScalarFieldEnum | ImpuestoScalarFieldEnum[]
  }

  /**
   * Impuesto findMany
   */
  export type ImpuestoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter, which Impuestos to fetch.
     */
    where?: ImpuestoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Impuestos to fetch.
     */
    orderBy?: ImpuestoOrderByWithRelationInput | ImpuestoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Impuestos.
     */
    cursor?: ImpuestoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Impuestos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Impuestos.
     */
    skip?: number
    distinct?: ImpuestoScalarFieldEnum | ImpuestoScalarFieldEnum[]
  }

  /**
   * Impuesto create
   */
  export type ImpuestoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * The data needed to create a Impuesto.
     */
    data: XOR<ImpuestoCreateInput, ImpuestoUncheckedCreateInput>
  }

  /**
   * Impuesto createMany
   */
  export type ImpuestoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Impuestos.
     */
    data: ImpuestoCreateManyInput | ImpuestoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Impuesto update
   */
  export type ImpuestoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * The data needed to update a Impuesto.
     */
    data: XOR<ImpuestoUpdateInput, ImpuestoUncheckedUpdateInput>
    /**
     * Choose, which Impuesto to update.
     */
    where: ImpuestoWhereUniqueInput
  }

  /**
   * Impuesto updateMany
   */
  export type ImpuestoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Impuestos.
     */
    data: XOR<ImpuestoUpdateManyMutationInput, ImpuestoUncheckedUpdateManyInput>
    /**
     * Filter which Impuestos to update
     */
    where?: ImpuestoWhereInput
    /**
     * Limit how many Impuestos to update.
     */
    limit?: number
  }

  /**
   * Impuesto upsert
   */
  export type ImpuestoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * The filter to search for the Impuesto to update in case it exists.
     */
    where: ImpuestoWhereUniqueInput
    /**
     * In case the Impuesto found by the `where` argument doesn't exist, create a new Impuesto with this data.
     */
    create: XOR<ImpuestoCreateInput, ImpuestoUncheckedCreateInput>
    /**
     * In case the Impuesto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImpuestoUpdateInput, ImpuestoUncheckedUpdateInput>
  }

  /**
   * Impuesto delete
   */
  export type ImpuestoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
    /**
     * Filter which Impuesto to delete.
     */
    where: ImpuestoWhereUniqueInput
  }

  /**
   * Impuesto deleteMany
   */
  export type ImpuestoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Impuestos to delete
     */
    where?: ImpuestoWhereInput
    /**
     * Limit how many Impuestos to delete.
     */
    limit?: number
  }

  /**
   * Impuesto.obligaciones
   */
  export type Impuesto$obligacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    where?: ObligacionFiscalWhereInput
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    cursor?: ObligacionFiscalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObligacionFiscalScalarFieldEnum | ObligacionFiscalScalarFieldEnum[]
  }

  /**
   * Impuesto without action
   */
  export type ImpuestoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Impuesto
     */
    select?: ImpuestoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Impuesto
     */
    omit?: ImpuestoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImpuestoInclude<ExtArgs> | null
  }


  /**
   * Model ObligacionFiscal
   */

  export type AggregateObligacionFiscal = {
    _count: ObligacionFiscalCountAggregateOutputType | null
    _avg: ObligacionFiscalAvgAggregateOutputType | null
    _sum: ObligacionFiscalSumAggregateOutputType | null
    _min: ObligacionFiscalMinAggregateOutputType | null
    _max: ObligacionFiscalMaxAggregateOutputType | null
  }

  export type ObligacionFiscalAvgAggregateOutputType = {
    diaVencimiento: number | null
  }

  export type ObligacionFiscalSumAggregateOutputType = {
    diaVencimiento: number | null
  }

  export type ObligacionFiscalMinAggregateOutputType = {
    id: string | null
    clienteId: string | null
    impuestoId: string | null
    periodicidad: $Enums.Periodicidad | null
    diaVencimiento: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    observaciones: string | null
    fechaAsignacion: Date | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObligacionFiscalMaxAggregateOutputType = {
    id: string | null
    clienteId: string | null
    impuestoId: string | null
    periodicidad: $Enums.Periodicidad | null
    diaVencimiento: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    observaciones: string | null
    fechaAsignacion: Date | null
    activo: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ObligacionFiscalCountAggregateOutputType = {
    id: number
    clienteId: number
    impuestoId: number
    periodicidad: number
    diaVencimiento: number
    fechaInicio: number
    fechaFin: number
    observaciones: number
    fechaAsignacion: number
    activo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ObligacionFiscalAvgAggregateInputType = {
    diaVencimiento?: true
  }

  export type ObligacionFiscalSumAggregateInputType = {
    diaVencimiento?: true
  }

  export type ObligacionFiscalMinAggregateInputType = {
    id?: true
    clienteId?: true
    impuestoId?: true
    periodicidad?: true
    diaVencimiento?: true
    fechaInicio?: true
    fechaFin?: true
    observaciones?: true
    fechaAsignacion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObligacionFiscalMaxAggregateInputType = {
    id?: true
    clienteId?: true
    impuestoId?: true
    periodicidad?: true
    diaVencimiento?: true
    fechaInicio?: true
    fechaFin?: true
    observaciones?: true
    fechaAsignacion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ObligacionFiscalCountAggregateInputType = {
    id?: true
    clienteId?: true
    impuestoId?: true
    periodicidad?: true
    diaVencimiento?: true
    fechaInicio?: true
    fechaFin?: true
    observaciones?: true
    fechaAsignacion?: true
    activo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ObligacionFiscalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObligacionFiscal to aggregate.
     */
    where?: ObligacionFiscalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObligacionFiscals to fetch.
     */
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObligacionFiscalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObligacionFiscals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObligacionFiscals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObligacionFiscals
    **/
    _count?: true | ObligacionFiscalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObligacionFiscalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObligacionFiscalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObligacionFiscalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObligacionFiscalMaxAggregateInputType
  }

  export type GetObligacionFiscalAggregateType<T extends ObligacionFiscalAggregateArgs> = {
        [P in keyof T & keyof AggregateObligacionFiscal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObligacionFiscal[P]>
      : GetScalarType<T[P], AggregateObligacionFiscal[P]>
  }




  export type ObligacionFiscalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObligacionFiscalWhereInput
    orderBy?: ObligacionFiscalOrderByWithAggregationInput | ObligacionFiscalOrderByWithAggregationInput[]
    by: ObligacionFiscalScalarFieldEnum[] | ObligacionFiscalScalarFieldEnum
    having?: ObligacionFiscalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObligacionFiscalCountAggregateInputType | true
    _avg?: ObligacionFiscalAvgAggregateInputType
    _sum?: ObligacionFiscalSumAggregateInputType
    _min?: ObligacionFiscalMinAggregateInputType
    _max?: ObligacionFiscalMaxAggregateInputType
  }

  export type ObligacionFiscalGroupByOutputType = {
    id: string
    clienteId: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento: number | null
    fechaInicio: Date
    fechaFin: Date | null
    observaciones: string | null
    fechaAsignacion: Date
    activo: boolean
    createdAt: Date
    updatedAt: Date
    _count: ObligacionFiscalCountAggregateOutputType | null
    _avg: ObligacionFiscalAvgAggregateOutputType | null
    _sum: ObligacionFiscalSumAggregateOutputType | null
    _min: ObligacionFiscalMinAggregateOutputType | null
    _max: ObligacionFiscalMaxAggregateOutputType | null
  }

  type GetObligacionFiscalGroupByPayload<T extends ObligacionFiscalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObligacionFiscalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObligacionFiscalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObligacionFiscalGroupByOutputType[P]>
            : GetScalarType<T[P], ObligacionFiscalGroupByOutputType[P]>
        }
      >
    >


  export type ObligacionFiscalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    impuestoId?: boolean
    periodicidad?: boolean
    diaVencimiento?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    observaciones?: boolean
    fechaAsignacion?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
    impuesto?: boolean | ImpuestoDefaultArgs<ExtArgs>
    declaraciones?: boolean | ObligacionFiscal$declaracionesArgs<ExtArgs>
    _count?: boolean | ObligacionFiscalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obligacionFiscal"]>



  export type ObligacionFiscalSelectScalar = {
    id?: boolean
    clienteId?: boolean
    impuestoId?: boolean
    periodicidad?: boolean
    diaVencimiento?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    observaciones?: boolean
    fechaAsignacion?: boolean
    activo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ObligacionFiscalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clienteId" | "impuestoId" | "periodicidad" | "diaVencimiento" | "fechaInicio" | "fechaFin" | "observaciones" | "fechaAsignacion" | "activo" | "createdAt" | "updatedAt", ExtArgs["result"]["obligacionFiscal"]>
  export type ObligacionFiscalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
    impuesto?: boolean | ImpuestoDefaultArgs<ExtArgs>
    declaraciones?: boolean | ObligacionFiscal$declaracionesArgs<ExtArgs>
    _count?: boolean | ObligacionFiscalCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ObligacionFiscalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObligacionFiscal"
    objects: {
      cliente: Prisma.$ClientPayload<ExtArgs>
      impuesto: Prisma.$ImpuestoPayload<ExtArgs>
      declaraciones: Prisma.$DeclaracionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clienteId: string
      impuestoId: string
      periodicidad: $Enums.Periodicidad
      diaVencimiento: number | null
      fechaInicio: Date
      fechaFin: Date | null
      observaciones: string | null
      fechaAsignacion: Date
      activo: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["obligacionFiscal"]>
    composites: {}
  }

  type ObligacionFiscalGetPayload<S extends boolean | null | undefined | ObligacionFiscalDefaultArgs> = $Result.GetResult<Prisma.$ObligacionFiscalPayload, S>

  type ObligacionFiscalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ObligacionFiscalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ObligacionFiscalCountAggregateInputType | true
    }

  export interface ObligacionFiscalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObligacionFiscal'], meta: { name: 'ObligacionFiscal' } }
    /**
     * Find zero or one ObligacionFiscal that matches the filter.
     * @param {ObligacionFiscalFindUniqueArgs} args - Arguments to find a ObligacionFiscal
     * @example
     * // Get one ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObligacionFiscalFindUniqueArgs>(args: SelectSubset<T, ObligacionFiscalFindUniqueArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ObligacionFiscal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ObligacionFiscalFindUniqueOrThrowArgs} args - Arguments to find a ObligacionFiscal
     * @example
     * // Get one ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObligacionFiscalFindUniqueOrThrowArgs>(args: SelectSubset<T, ObligacionFiscalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObligacionFiscal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalFindFirstArgs} args - Arguments to find a ObligacionFiscal
     * @example
     * // Get one ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObligacionFiscalFindFirstArgs>(args?: SelectSubset<T, ObligacionFiscalFindFirstArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ObligacionFiscal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalFindFirstOrThrowArgs} args - Arguments to find a ObligacionFiscal
     * @example
     * // Get one ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObligacionFiscalFindFirstOrThrowArgs>(args?: SelectSubset<T, ObligacionFiscalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ObligacionFiscals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObligacionFiscals
     * const obligacionFiscals = await prisma.obligacionFiscal.findMany()
     * 
     * // Get first 10 ObligacionFiscals
     * const obligacionFiscals = await prisma.obligacionFiscal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obligacionFiscalWithIdOnly = await prisma.obligacionFiscal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObligacionFiscalFindManyArgs>(args?: SelectSubset<T, ObligacionFiscalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ObligacionFiscal.
     * @param {ObligacionFiscalCreateArgs} args - Arguments to create a ObligacionFiscal.
     * @example
     * // Create one ObligacionFiscal
     * const ObligacionFiscal = await prisma.obligacionFiscal.create({
     *   data: {
     *     // ... data to create a ObligacionFiscal
     *   }
     * })
     * 
     */
    create<T extends ObligacionFiscalCreateArgs>(args: SelectSubset<T, ObligacionFiscalCreateArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ObligacionFiscals.
     * @param {ObligacionFiscalCreateManyArgs} args - Arguments to create many ObligacionFiscals.
     * @example
     * // Create many ObligacionFiscals
     * const obligacionFiscal = await prisma.obligacionFiscal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObligacionFiscalCreateManyArgs>(args?: SelectSubset<T, ObligacionFiscalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ObligacionFiscal.
     * @param {ObligacionFiscalDeleteArgs} args - Arguments to delete one ObligacionFiscal.
     * @example
     * // Delete one ObligacionFiscal
     * const ObligacionFiscal = await prisma.obligacionFiscal.delete({
     *   where: {
     *     // ... filter to delete one ObligacionFiscal
     *   }
     * })
     * 
     */
    delete<T extends ObligacionFiscalDeleteArgs>(args: SelectSubset<T, ObligacionFiscalDeleteArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ObligacionFiscal.
     * @param {ObligacionFiscalUpdateArgs} args - Arguments to update one ObligacionFiscal.
     * @example
     * // Update one ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObligacionFiscalUpdateArgs>(args: SelectSubset<T, ObligacionFiscalUpdateArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ObligacionFiscals.
     * @param {ObligacionFiscalDeleteManyArgs} args - Arguments to filter ObligacionFiscals to delete.
     * @example
     * // Delete a few ObligacionFiscals
     * const { count } = await prisma.obligacionFiscal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObligacionFiscalDeleteManyArgs>(args?: SelectSubset<T, ObligacionFiscalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObligacionFiscals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObligacionFiscals
     * const obligacionFiscal = await prisma.obligacionFiscal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObligacionFiscalUpdateManyArgs>(args: SelectSubset<T, ObligacionFiscalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObligacionFiscal.
     * @param {ObligacionFiscalUpsertArgs} args - Arguments to update or create a ObligacionFiscal.
     * @example
     * // Update or create a ObligacionFiscal
     * const obligacionFiscal = await prisma.obligacionFiscal.upsert({
     *   create: {
     *     // ... data to create a ObligacionFiscal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObligacionFiscal we want to update
     *   }
     * })
     */
    upsert<T extends ObligacionFiscalUpsertArgs>(args: SelectSubset<T, ObligacionFiscalUpsertArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ObligacionFiscals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalCountArgs} args - Arguments to filter ObligacionFiscals to count.
     * @example
     * // Count the number of ObligacionFiscals
     * const count = await prisma.obligacionFiscal.count({
     *   where: {
     *     // ... the filter for the ObligacionFiscals we want to count
     *   }
     * })
    **/
    count<T extends ObligacionFiscalCountArgs>(
      args?: Subset<T, ObligacionFiscalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObligacionFiscalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObligacionFiscal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObligacionFiscalAggregateArgs>(args: Subset<T, ObligacionFiscalAggregateArgs>): Prisma.PrismaPromise<GetObligacionFiscalAggregateType<T>>

    /**
     * Group by ObligacionFiscal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObligacionFiscalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObligacionFiscalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObligacionFiscalGroupByArgs['orderBy'] }
        : { orderBy?: ObligacionFiscalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObligacionFiscalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObligacionFiscalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObligacionFiscal model
   */
  readonly fields: ObligacionFiscalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObligacionFiscal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObligacionFiscalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    impuesto<T extends ImpuestoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImpuestoDefaultArgs<ExtArgs>>): Prisma__ImpuestoClient<$Result.GetResult<Prisma.$ImpuestoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    declaraciones<T extends ObligacionFiscal$declaracionesArgs<ExtArgs> = {}>(args?: Subset<T, ObligacionFiscal$declaracionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObligacionFiscal model
   */
  interface ObligacionFiscalFieldRefs {
    readonly id: FieldRef<"ObligacionFiscal", 'String'>
    readonly clienteId: FieldRef<"ObligacionFiscal", 'String'>
    readonly impuestoId: FieldRef<"ObligacionFiscal", 'String'>
    readonly periodicidad: FieldRef<"ObligacionFiscal", 'Periodicidad'>
    readonly diaVencimiento: FieldRef<"ObligacionFiscal", 'Int'>
    readonly fechaInicio: FieldRef<"ObligacionFiscal", 'DateTime'>
    readonly fechaFin: FieldRef<"ObligacionFiscal", 'DateTime'>
    readonly observaciones: FieldRef<"ObligacionFiscal", 'String'>
    readonly fechaAsignacion: FieldRef<"ObligacionFiscal", 'DateTime'>
    readonly activo: FieldRef<"ObligacionFiscal", 'Boolean'>
    readonly createdAt: FieldRef<"ObligacionFiscal", 'DateTime'>
    readonly updatedAt: FieldRef<"ObligacionFiscal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ObligacionFiscal findUnique
   */
  export type ObligacionFiscalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter, which ObligacionFiscal to fetch.
     */
    where: ObligacionFiscalWhereUniqueInput
  }

  /**
   * ObligacionFiscal findUniqueOrThrow
   */
  export type ObligacionFiscalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter, which ObligacionFiscal to fetch.
     */
    where: ObligacionFiscalWhereUniqueInput
  }

  /**
   * ObligacionFiscal findFirst
   */
  export type ObligacionFiscalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter, which ObligacionFiscal to fetch.
     */
    where?: ObligacionFiscalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObligacionFiscals to fetch.
     */
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObligacionFiscals.
     */
    cursor?: ObligacionFiscalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObligacionFiscals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObligacionFiscals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObligacionFiscals.
     */
    distinct?: ObligacionFiscalScalarFieldEnum | ObligacionFiscalScalarFieldEnum[]
  }

  /**
   * ObligacionFiscal findFirstOrThrow
   */
  export type ObligacionFiscalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter, which ObligacionFiscal to fetch.
     */
    where?: ObligacionFiscalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObligacionFiscals to fetch.
     */
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObligacionFiscals.
     */
    cursor?: ObligacionFiscalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObligacionFiscals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObligacionFiscals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObligacionFiscals.
     */
    distinct?: ObligacionFiscalScalarFieldEnum | ObligacionFiscalScalarFieldEnum[]
  }

  /**
   * ObligacionFiscal findMany
   */
  export type ObligacionFiscalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter, which ObligacionFiscals to fetch.
     */
    where?: ObligacionFiscalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObligacionFiscals to fetch.
     */
    orderBy?: ObligacionFiscalOrderByWithRelationInput | ObligacionFiscalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObligacionFiscals.
     */
    cursor?: ObligacionFiscalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObligacionFiscals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObligacionFiscals.
     */
    skip?: number
    distinct?: ObligacionFiscalScalarFieldEnum | ObligacionFiscalScalarFieldEnum[]
  }

  /**
   * ObligacionFiscal create
   */
  export type ObligacionFiscalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * The data needed to create a ObligacionFiscal.
     */
    data: XOR<ObligacionFiscalCreateInput, ObligacionFiscalUncheckedCreateInput>
  }

  /**
   * ObligacionFiscal createMany
   */
  export type ObligacionFiscalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObligacionFiscals.
     */
    data: ObligacionFiscalCreateManyInput | ObligacionFiscalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObligacionFiscal update
   */
  export type ObligacionFiscalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * The data needed to update a ObligacionFiscal.
     */
    data: XOR<ObligacionFiscalUpdateInput, ObligacionFiscalUncheckedUpdateInput>
    /**
     * Choose, which ObligacionFiscal to update.
     */
    where: ObligacionFiscalWhereUniqueInput
  }

  /**
   * ObligacionFiscal updateMany
   */
  export type ObligacionFiscalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObligacionFiscals.
     */
    data: XOR<ObligacionFiscalUpdateManyMutationInput, ObligacionFiscalUncheckedUpdateManyInput>
    /**
     * Filter which ObligacionFiscals to update
     */
    where?: ObligacionFiscalWhereInput
    /**
     * Limit how many ObligacionFiscals to update.
     */
    limit?: number
  }

  /**
   * ObligacionFiscal upsert
   */
  export type ObligacionFiscalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * The filter to search for the ObligacionFiscal to update in case it exists.
     */
    where: ObligacionFiscalWhereUniqueInput
    /**
     * In case the ObligacionFiscal found by the `where` argument doesn't exist, create a new ObligacionFiscal with this data.
     */
    create: XOR<ObligacionFiscalCreateInput, ObligacionFiscalUncheckedCreateInput>
    /**
     * In case the ObligacionFiscal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObligacionFiscalUpdateInput, ObligacionFiscalUncheckedUpdateInput>
  }

  /**
   * ObligacionFiscal delete
   */
  export type ObligacionFiscalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
    /**
     * Filter which ObligacionFiscal to delete.
     */
    where: ObligacionFiscalWhereUniqueInput
  }

  /**
   * ObligacionFiscal deleteMany
   */
  export type ObligacionFiscalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObligacionFiscals to delete
     */
    where?: ObligacionFiscalWhereInput
    /**
     * Limit how many ObligacionFiscals to delete.
     */
    limit?: number
  }

  /**
   * ObligacionFiscal.declaraciones
   */
  export type ObligacionFiscal$declaracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    where?: DeclaracionWhereInput
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    cursor?: DeclaracionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeclaracionScalarFieldEnum | DeclaracionScalarFieldEnum[]
  }

  /**
   * ObligacionFiscal without action
   */
  export type ObligacionFiscalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObligacionFiscal
     */
    select?: ObligacionFiscalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ObligacionFiscal
     */
    omit?: ObligacionFiscalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObligacionFiscalInclude<ExtArgs> | null
  }


  /**
   * Model CalendarioAEAT
   */

  export type AggregateCalendarioAEAT = {
    _count: CalendarioAEATCountAggregateOutputType | null
    _min: CalendarioAEATMinAggregateOutputType | null
    _max: CalendarioAEATMaxAggregateOutputType | null
  }

  export type CalendarioAEATMinAggregateOutputType = {
    id: string | null
    modelo: string | null
    periodicidad: $Enums.Periodicidad | null
    periodoContable: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarioAEATMaxAggregateOutputType = {
    id: string | null
    modelo: string | null
    periodicidad: $Enums.Periodicidad | null
    periodoContable: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CalendarioAEATCountAggregateOutputType = {
    id: number
    modelo: number
    periodicidad: number
    periodoContable: number
    fechaInicio: number
    fechaFin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CalendarioAEATMinAggregateInputType = {
    id?: true
    modelo?: true
    periodicidad?: true
    periodoContable?: true
    fechaInicio?: true
    fechaFin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarioAEATMaxAggregateInputType = {
    id?: true
    modelo?: true
    periodicidad?: true
    periodoContable?: true
    fechaInicio?: true
    fechaFin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CalendarioAEATCountAggregateInputType = {
    id?: true
    modelo?: true
    periodicidad?: true
    periodoContable?: true
    fechaInicio?: true
    fechaFin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CalendarioAEATAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarioAEAT to aggregate.
     */
    where?: CalendarioAEATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarioAEATS to fetch.
     */
    orderBy?: CalendarioAEATOrderByWithRelationInput | CalendarioAEATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CalendarioAEATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarioAEATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarioAEATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CalendarioAEATS
    **/
    _count?: true | CalendarioAEATCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarioAEATMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarioAEATMaxAggregateInputType
  }

  export type GetCalendarioAEATAggregateType<T extends CalendarioAEATAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendarioAEAT]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendarioAEAT[P]>
      : GetScalarType<T[P], AggregateCalendarioAEAT[P]>
  }




  export type CalendarioAEATGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CalendarioAEATWhereInput
    orderBy?: CalendarioAEATOrderByWithAggregationInput | CalendarioAEATOrderByWithAggregationInput[]
    by: CalendarioAEATScalarFieldEnum[] | CalendarioAEATScalarFieldEnum
    having?: CalendarioAEATScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarioAEATCountAggregateInputType | true
    _min?: CalendarioAEATMinAggregateInputType
    _max?: CalendarioAEATMaxAggregateInputType
  }

  export type CalendarioAEATGroupByOutputType = {
    id: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date
    fechaFin: Date
    createdAt: Date
    updatedAt: Date
    _count: CalendarioAEATCountAggregateOutputType | null
    _min: CalendarioAEATMinAggregateOutputType | null
    _max: CalendarioAEATMaxAggregateOutputType | null
  }

  type GetCalendarioAEATGroupByPayload<T extends CalendarioAEATGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarioAEATGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarioAEATGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarioAEATGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarioAEATGroupByOutputType[P]>
        }
      >
    >


  export type CalendarioAEATSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelo?: boolean
    periodicidad?: boolean
    periodoContable?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    declaraciones?: boolean | CalendarioAEAT$declaracionesArgs<ExtArgs>
    _count?: boolean | CalendarioAEATCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendarioAEAT"]>



  export type CalendarioAEATSelectScalar = {
    id?: boolean
    modelo?: boolean
    periodicidad?: boolean
    periodoContable?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CalendarioAEATOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelo" | "periodicidad" | "periodoContable" | "fechaInicio" | "fechaFin" | "createdAt" | "updatedAt", ExtArgs["result"]["calendarioAEAT"]>
  export type CalendarioAEATInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    declaraciones?: boolean | CalendarioAEAT$declaracionesArgs<ExtArgs>
    _count?: boolean | CalendarioAEATCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CalendarioAEATPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CalendarioAEAT"
    objects: {
      declaraciones: Prisma.$DeclaracionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelo: string
      periodicidad: $Enums.Periodicidad
      periodoContable: string
      fechaInicio: Date
      fechaFin: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["calendarioAEAT"]>
    composites: {}
  }

  type CalendarioAEATGetPayload<S extends boolean | null | undefined | CalendarioAEATDefaultArgs> = $Result.GetResult<Prisma.$CalendarioAEATPayload, S>

  type CalendarioAEATCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CalendarioAEATFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarioAEATCountAggregateInputType | true
    }

  export interface CalendarioAEATDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CalendarioAEAT'], meta: { name: 'CalendarioAEAT' } }
    /**
     * Find zero or one CalendarioAEAT that matches the filter.
     * @param {CalendarioAEATFindUniqueArgs} args - Arguments to find a CalendarioAEAT
     * @example
     * // Get one CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CalendarioAEATFindUniqueArgs>(args: SelectSubset<T, CalendarioAEATFindUniqueArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CalendarioAEAT that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CalendarioAEATFindUniqueOrThrowArgs} args - Arguments to find a CalendarioAEAT
     * @example
     * // Get one CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CalendarioAEATFindUniqueOrThrowArgs>(args: SelectSubset<T, CalendarioAEATFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarioAEAT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATFindFirstArgs} args - Arguments to find a CalendarioAEAT
     * @example
     * // Get one CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CalendarioAEATFindFirstArgs>(args?: SelectSubset<T, CalendarioAEATFindFirstArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CalendarioAEAT that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATFindFirstOrThrowArgs} args - Arguments to find a CalendarioAEAT
     * @example
     * // Get one CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CalendarioAEATFindFirstOrThrowArgs>(args?: SelectSubset<T, CalendarioAEATFindFirstOrThrowArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CalendarioAEATS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CalendarioAEATS
     * const calendarioAEATS = await prisma.calendarioAEAT.findMany()
     * 
     * // Get first 10 CalendarioAEATS
     * const calendarioAEATS = await prisma.calendarioAEAT.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarioAEATWithIdOnly = await prisma.calendarioAEAT.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CalendarioAEATFindManyArgs>(args?: SelectSubset<T, CalendarioAEATFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CalendarioAEAT.
     * @param {CalendarioAEATCreateArgs} args - Arguments to create a CalendarioAEAT.
     * @example
     * // Create one CalendarioAEAT
     * const CalendarioAEAT = await prisma.calendarioAEAT.create({
     *   data: {
     *     // ... data to create a CalendarioAEAT
     *   }
     * })
     * 
     */
    create<T extends CalendarioAEATCreateArgs>(args: SelectSubset<T, CalendarioAEATCreateArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CalendarioAEATS.
     * @param {CalendarioAEATCreateManyArgs} args - Arguments to create many CalendarioAEATS.
     * @example
     * // Create many CalendarioAEATS
     * const calendarioAEAT = await prisma.calendarioAEAT.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CalendarioAEATCreateManyArgs>(args?: SelectSubset<T, CalendarioAEATCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CalendarioAEAT.
     * @param {CalendarioAEATDeleteArgs} args - Arguments to delete one CalendarioAEAT.
     * @example
     * // Delete one CalendarioAEAT
     * const CalendarioAEAT = await prisma.calendarioAEAT.delete({
     *   where: {
     *     // ... filter to delete one CalendarioAEAT
     *   }
     * })
     * 
     */
    delete<T extends CalendarioAEATDeleteArgs>(args: SelectSubset<T, CalendarioAEATDeleteArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CalendarioAEAT.
     * @param {CalendarioAEATUpdateArgs} args - Arguments to update one CalendarioAEAT.
     * @example
     * // Update one CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CalendarioAEATUpdateArgs>(args: SelectSubset<T, CalendarioAEATUpdateArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CalendarioAEATS.
     * @param {CalendarioAEATDeleteManyArgs} args - Arguments to filter CalendarioAEATS to delete.
     * @example
     * // Delete a few CalendarioAEATS
     * const { count } = await prisma.calendarioAEAT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CalendarioAEATDeleteManyArgs>(args?: SelectSubset<T, CalendarioAEATDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CalendarioAEATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CalendarioAEATS
     * const calendarioAEAT = await prisma.calendarioAEAT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CalendarioAEATUpdateManyArgs>(args: SelectSubset<T, CalendarioAEATUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CalendarioAEAT.
     * @param {CalendarioAEATUpsertArgs} args - Arguments to update or create a CalendarioAEAT.
     * @example
     * // Update or create a CalendarioAEAT
     * const calendarioAEAT = await prisma.calendarioAEAT.upsert({
     *   create: {
     *     // ... data to create a CalendarioAEAT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CalendarioAEAT we want to update
     *   }
     * })
     */
    upsert<T extends CalendarioAEATUpsertArgs>(args: SelectSubset<T, CalendarioAEATUpsertArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CalendarioAEATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATCountArgs} args - Arguments to filter CalendarioAEATS to count.
     * @example
     * // Count the number of CalendarioAEATS
     * const count = await prisma.calendarioAEAT.count({
     *   where: {
     *     // ... the filter for the CalendarioAEATS we want to count
     *   }
     * })
    **/
    count<T extends CalendarioAEATCountArgs>(
      args?: Subset<T, CalendarioAEATCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarioAEATCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CalendarioAEAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarioAEATAggregateArgs>(args: Subset<T, CalendarioAEATAggregateArgs>): Prisma.PrismaPromise<GetCalendarioAEATAggregateType<T>>

    /**
     * Group by CalendarioAEAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarioAEATGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalendarioAEATGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalendarioAEATGroupByArgs['orderBy'] }
        : { orderBy?: CalendarioAEATGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalendarioAEATGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarioAEATGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CalendarioAEAT model
   */
  readonly fields: CalendarioAEATFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CalendarioAEAT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CalendarioAEATClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    declaraciones<T extends CalendarioAEAT$declaracionesArgs<ExtArgs> = {}>(args?: Subset<T, CalendarioAEAT$declaracionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CalendarioAEAT model
   */
  interface CalendarioAEATFieldRefs {
    readonly id: FieldRef<"CalendarioAEAT", 'String'>
    readonly modelo: FieldRef<"CalendarioAEAT", 'String'>
    readonly periodicidad: FieldRef<"CalendarioAEAT", 'Periodicidad'>
    readonly periodoContable: FieldRef<"CalendarioAEAT", 'String'>
    readonly fechaInicio: FieldRef<"CalendarioAEAT", 'DateTime'>
    readonly fechaFin: FieldRef<"CalendarioAEAT", 'DateTime'>
    readonly createdAt: FieldRef<"CalendarioAEAT", 'DateTime'>
    readonly updatedAt: FieldRef<"CalendarioAEAT", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CalendarioAEAT findUnique
   */
  export type CalendarioAEATFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter, which CalendarioAEAT to fetch.
     */
    where: CalendarioAEATWhereUniqueInput
  }

  /**
   * CalendarioAEAT findUniqueOrThrow
   */
  export type CalendarioAEATFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter, which CalendarioAEAT to fetch.
     */
    where: CalendarioAEATWhereUniqueInput
  }

  /**
   * CalendarioAEAT findFirst
   */
  export type CalendarioAEATFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter, which CalendarioAEAT to fetch.
     */
    where?: CalendarioAEATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarioAEATS to fetch.
     */
    orderBy?: CalendarioAEATOrderByWithRelationInput | CalendarioAEATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarioAEATS.
     */
    cursor?: CalendarioAEATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarioAEATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarioAEATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarioAEATS.
     */
    distinct?: CalendarioAEATScalarFieldEnum | CalendarioAEATScalarFieldEnum[]
  }

  /**
   * CalendarioAEAT findFirstOrThrow
   */
  export type CalendarioAEATFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter, which CalendarioAEAT to fetch.
     */
    where?: CalendarioAEATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarioAEATS to fetch.
     */
    orderBy?: CalendarioAEATOrderByWithRelationInput | CalendarioAEATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CalendarioAEATS.
     */
    cursor?: CalendarioAEATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarioAEATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarioAEATS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CalendarioAEATS.
     */
    distinct?: CalendarioAEATScalarFieldEnum | CalendarioAEATScalarFieldEnum[]
  }

  /**
   * CalendarioAEAT findMany
   */
  export type CalendarioAEATFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter, which CalendarioAEATS to fetch.
     */
    where?: CalendarioAEATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CalendarioAEATS to fetch.
     */
    orderBy?: CalendarioAEATOrderByWithRelationInput | CalendarioAEATOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CalendarioAEATS.
     */
    cursor?: CalendarioAEATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CalendarioAEATS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CalendarioAEATS.
     */
    skip?: number
    distinct?: CalendarioAEATScalarFieldEnum | CalendarioAEATScalarFieldEnum[]
  }

  /**
   * CalendarioAEAT create
   */
  export type CalendarioAEATCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * The data needed to create a CalendarioAEAT.
     */
    data: XOR<CalendarioAEATCreateInput, CalendarioAEATUncheckedCreateInput>
  }

  /**
   * CalendarioAEAT createMany
   */
  export type CalendarioAEATCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CalendarioAEATS.
     */
    data: CalendarioAEATCreateManyInput | CalendarioAEATCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CalendarioAEAT update
   */
  export type CalendarioAEATUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * The data needed to update a CalendarioAEAT.
     */
    data: XOR<CalendarioAEATUpdateInput, CalendarioAEATUncheckedUpdateInput>
    /**
     * Choose, which CalendarioAEAT to update.
     */
    where: CalendarioAEATWhereUniqueInput
  }

  /**
   * CalendarioAEAT updateMany
   */
  export type CalendarioAEATUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CalendarioAEATS.
     */
    data: XOR<CalendarioAEATUpdateManyMutationInput, CalendarioAEATUncheckedUpdateManyInput>
    /**
     * Filter which CalendarioAEATS to update
     */
    where?: CalendarioAEATWhereInput
    /**
     * Limit how many CalendarioAEATS to update.
     */
    limit?: number
  }

  /**
   * CalendarioAEAT upsert
   */
  export type CalendarioAEATUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * The filter to search for the CalendarioAEAT to update in case it exists.
     */
    where: CalendarioAEATWhereUniqueInput
    /**
     * In case the CalendarioAEAT found by the `where` argument doesn't exist, create a new CalendarioAEAT with this data.
     */
    create: XOR<CalendarioAEATCreateInput, CalendarioAEATUncheckedCreateInput>
    /**
     * In case the CalendarioAEAT was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CalendarioAEATUpdateInput, CalendarioAEATUncheckedUpdateInput>
  }

  /**
   * CalendarioAEAT delete
   */
  export type CalendarioAEATDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
    /**
     * Filter which CalendarioAEAT to delete.
     */
    where: CalendarioAEATWhereUniqueInput
  }

  /**
   * CalendarioAEAT deleteMany
   */
  export type CalendarioAEATDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CalendarioAEATS to delete
     */
    where?: CalendarioAEATWhereInput
    /**
     * Limit how many CalendarioAEATS to delete.
     */
    limit?: number
  }

  /**
   * CalendarioAEAT.declaraciones
   */
  export type CalendarioAEAT$declaracionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    where?: DeclaracionWhereInput
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    cursor?: DeclaracionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeclaracionScalarFieldEnum | DeclaracionScalarFieldEnum[]
  }

  /**
   * CalendarioAEAT without action
   */
  export type CalendarioAEATDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarioAEAT
     */
    select?: CalendarioAEATSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CalendarioAEAT
     */
    omit?: CalendarioAEATOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CalendarioAEATInclude<ExtArgs> | null
  }


  /**
   * Model Declaracion
   */

  export type AggregateDeclaracion = {
    _count: DeclaracionCountAggregateOutputType | null
    _min: DeclaracionMinAggregateOutputType | null
    _max: DeclaracionMaxAggregateOutputType | null
  }

  export type DeclaracionMinAggregateOutputType = {
    id: string | null
    obligacionId: string | null
    calendarioId: string | null
    estado: $Enums.EstadoDeclaracion | null
    fechaPresentacion: Date | null
    archivoPdf: string | null
    notas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeclaracionMaxAggregateOutputType = {
    id: string | null
    obligacionId: string | null
    calendarioId: string | null
    estado: $Enums.EstadoDeclaracion | null
    fechaPresentacion: Date | null
    archivoPdf: string | null
    notas: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeclaracionCountAggregateOutputType = {
    id: number
    obligacionId: number
    calendarioId: number
    estado: number
    fechaPresentacion: number
    archivoPdf: number
    notas: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeclaracionMinAggregateInputType = {
    id?: true
    obligacionId?: true
    calendarioId?: true
    estado?: true
    fechaPresentacion?: true
    archivoPdf?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeclaracionMaxAggregateInputType = {
    id?: true
    obligacionId?: true
    calendarioId?: true
    estado?: true
    fechaPresentacion?: true
    archivoPdf?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeclaracionCountAggregateInputType = {
    id?: true
    obligacionId?: true
    calendarioId?: true
    estado?: true
    fechaPresentacion?: true
    archivoPdf?: true
    notas?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeclaracionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Declaracion to aggregate.
     */
    where?: DeclaracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declaracions to fetch.
     */
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeclaracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declaracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declaracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Declaracions
    **/
    _count?: true | DeclaracionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeclaracionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeclaracionMaxAggregateInputType
  }

  export type GetDeclaracionAggregateType<T extends DeclaracionAggregateArgs> = {
        [P in keyof T & keyof AggregateDeclaracion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeclaracion[P]>
      : GetScalarType<T[P], AggregateDeclaracion[P]>
  }




  export type DeclaracionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeclaracionWhereInput
    orderBy?: DeclaracionOrderByWithAggregationInput | DeclaracionOrderByWithAggregationInput[]
    by: DeclaracionScalarFieldEnum[] | DeclaracionScalarFieldEnum
    having?: DeclaracionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeclaracionCountAggregateInputType | true
    _min?: DeclaracionMinAggregateInputType
    _max?: DeclaracionMaxAggregateInputType
  }

  export type DeclaracionGroupByOutputType = {
    id: string
    obligacionId: string
    calendarioId: string
    estado: $Enums.EstadoDeclaracion
    fechaPresentacion: Date | null
    archivoPdf: string | null
    notas: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeclaracionCountAggregateOutputType | null
    _min: DeclaracionMinAggregateOutputType | null
    _max: DeclaracionMaxAggregateOutputType | null
  }

  type GetDeclaracionGroupByPayload<T extends DeclaracionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeclaracionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeclaracionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeclaracionGroupByOutputType[P]>
            : GetScalarType<T[P], DeclaracionGroupByOutputType[P]>
        }
      >
    >


  export type DeclaracionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    obligacionId?: boolean
    calendarioId?: boolean
    estado?: boolean
    fechaPresentacion?: boolean
    archivoPdf?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    obligacion?: boolean | ObligacionFiscalDefaultArgs<ExtArgs>
    calendario?: boolean | CalendarioAEATDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["declaracion"]>



  export type DeclaracionSelectScalar = {
    id?: boolean
    obligacionId?: boolean
    calendarioId?: boolean
    estado?: boolean
    fechaPresentacion?: boolean
    archivoPdf?: boolean
    notas?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeclaracionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "obligacionId" | "calendarioId" | "estado" | "fechaPresentacion" | "archivoPdf" | "notas" | "createdAt" | "updatedAt", ExtArgs["result"]["declaracion"]>
  export type DeclaracionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obligacion?: boolean | ObligacionFiscalDefaultArgs<ExtArgs>
    calendario?: boolean | CalendarioAEATDefaultArgs<ExtArgs>
  }

  export type $DeclaracionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Declaracion"
    objects: {
      obligacion: Prisma.$ObligacionFiscalPayload<ExtArgs>
      calendario: Prisma.$CalendarioAEATPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      obligacionId: string
      calendarioId: string
      estado: $Enums.EstadoDeclaracion
      fechaPresentacion: Date | null
      archivoPdf: string | null
      notas: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["declaracion"]>
    composites: {}
  }

  type DeclaracionGetPayload<S extends boolean | null | undefined | DeclaracionDefaultArgs> = $Result.GetResult<Prisma.$DeclaracionPayload, S>

  type DeclaracionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeclaracionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeclaracionCountAggregateInputType | true
    }

  export interface DeclaracionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Declaracion'], meta: { name: 'Declaracion' } }
    /**
     * Find zero or one Declaracion that matches the filter.
     * @param {DeclaracionFindUniqueArgs} args - Arguments to find a Declaracion
     * @example
     * // Get one Declaracion
     * const declaracion = await prisma.declaracion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeclaracionFindUniqueArgs>(args: SelectSubset<T, DeclaracionFindUniqueArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Declaracion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeclaracionFindUniqueOrThrowArgs} args - Arguments to find a Declaracion
     * @example
     * // Get one Declaracion
     * const declaracion = await prisma.declaracion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeclaracionFindUniqueOrThrowArgs>(args: SelectSubset<T, DeclaracionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Declaracion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionFindFirstArgs} args - Arguments to find a Declaracion
     * @example
     * // Get one Declaracion
     * const declaracion = await prisma.declaracion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeclaracionFindFirstArgs>(args?: SelectSubset<T, DeclaracionFindFirstArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Declaracion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionFindFirstOrThrowArgs} args - Arguments to find a Declaracion
     * @example
     * // Get one Declaracion
     * const declaracion = await prisma.declaracion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeclaracionFindFirstOrThrowArgs>(args?: SelectSubset<T, DeclaracionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Declaracions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Declaracions
     * const declaracions = await prisma.declaracion.findMany()
     * 
     * // Get first 10 Declaracions
     * const declaracions = await prisma.declaracion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const declaracionWithIdOnly = await prisma.declaracion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeclaracionFindManyArgs>(args?: SelectSubset<T, DeclaracionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Declaracion.
     * @param {DeclaracionCreateArgs} args - Arguments to create a Declaracion.
     * @example
     * // Create one Declaracion
     * const Declaracion = await prisma.declaracion.create({
     *   data: {
     *     // ... data to create a Declaracion
     *   }
     * })
     * 
     */
    create<T extends DeclaracionCreateArgs>(args: SelectSubset<T, DeclaracionCreateArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Declaracions.
     * @param {DeclaracionCreateManyArgs} args - Arguments to create many Declaracions.
     * @example
     * // Create many Declaracions
     * const declaracion = await prisma.declaracion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeclaracionCreateManyArgs>(args?: SelectSubset<T, DeclaracionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Declaracion.
     * @param {DeclaracionDeleteArgs} args - Arguments to delete one Declaracion.
     * @example
     * // Delete one Declaracion
     * const Declaracion = await prisma.declaracion.delete({
     *   where: {
     *     // ... filter to delete one Declaracion
     *   }
     * })
     * 
     */
    delete<T extends DeclaracionDeleteArgs>(args: SelectSubset<T, DeclaracionDeleteArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Declaracion.
     * @param {DeclaracionUpdateArgs} args - Arguments to update one Declaracion.
     * @example
     * // Update one Declaracion
     * const declaracion = await prisma.declaracion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeclaracionUpdateArgs>(args: SelectSubset<T, DeclaracionUpdateArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Declaracions.
     * @param {DeclaracionDeleteManyArgs} args - Arguments to filter Declaracions to delete.
     * @example
     * // Delete a few Declaracions
     * const { count } = await prisma.declaracion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeclaracionDeleteManyArgs>(args?: SelectSubset<T, DeclaracionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Declaracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Declaracions
     * const declaracion = await prisma.declaracion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeclaracionUpdateManyArgs>(args: SelectSubset<T, DeclaracionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Declaracion.
     * @param {DeclaracionUpsertArgs} args - Arguments to update or create a Declaracion.
     * @example
     * // Update or create a Declaracion
     * const declaracion = await prisma.declaracion.upsert({
     *   create: {
     *     // ... data to create a Declaracion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Declaracion we want to update
     *   }
     * })
     */
    upsert<T extends DeclaracionUpsertArgs>(args: SelectSubset<T, DeclaracionUpsertArgs<ExtArgs>>): Prisma__DeclaracionClient<$Result.GetResult<Prisma.$DeclaracionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Declaracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionCountArgs} args - Arguments to filter Declaracions to count.
     * @example
     * // Count the number of Declaracions
     * const count = await prisma.declaracion.count({
     *   where: {
     *     // ... the filter for the Declaracions we want to count
     *   }
     * })
    **/
    count<T extends DeclaracionCountArgs>(
      args?: Subset<T, DeclaracionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeclaracionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Declaracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeclaracionAggregateArgs>(args: Subset<T, DeclaracionAggregateArgs>): Prisma.PrismaPromise<GetDeclaracionAggregateType<T>>

    /**
     * Group by Declaracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeclaracionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeclaracionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeclaracionGroupByArgs['orderBy'] }
        : { orderBy?: DeclaracionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeclaracionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeclaracionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Declaracion model
   */
  readonly fields: DeclaracionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Declaracion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeclaracionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    obligacion<T extends ObligacionFiscalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ObligacionFiscalDefaultArgs<ExtArgs>>): Prisma__ObligacionFiscalClient<$Result.GetResult<Prisma.$ObligacionFiscalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    calendario<T extends CalendarioAEATDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CalendarioAEATDefaultArgs<ExtArgs>>): Prisma__CalendarioAEATClient<$Result.GetResult<Prisma.$CalendarioAEATPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Declaracion model
   */
  interface DeclaracionFieldRefs {
    readonly id: FieldRef<"Declaracion", 'String'>
    readonly obligacionId: FieldRef<"Declaracion", 'String'>
    readonly calendarioId: FieldRef<"Declaracion", 'String'>
    readonly estado: FieldRef<"Declaracion", 'EstadoDeclaracion'>
    readonly fechaPresentacion: FieldRef<"Declaracion", 'DateTime'>
    readonly archivoPdf: FieldRef<"Declaracion", 'String'>
    readonly notas: FieldRef<"Declaracion", 'String'>
    readonly createdAt: FieldRef<"Declaracion", 'DateTime'>
    readonly updatedAt: FieldRef<"Declaracion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Declaracion findUnique
   */
  export type DeclaracionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter, which Declaracion to fetch.
     */
    where: DeclaracionWhereUniqueInput
  }

  /**
   * Declaracion findUniqueOrThrow
   */
  export type DeclaracionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter, which Declaracion to fetch.
     */
    where: DeclaracionWhereUniqueInput
  }

  /**
   * Declaracion findFirst
   */
  export type DeclaracionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter, which Declaracion to fetch.
     */
    where?: DeclaracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declaracions to fetch.
     */
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Declaracions.
     */
    cursor?: DeclaracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declaracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declaracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Declaracions.
     */
    distinct?: DeclaracionScalarFieldEnum | DeclaracionScalarFieldEnum[]
  }

  /**
   * Declaracion findFirstOrThrow
   */
  export type DeclaracionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter, which Declaracion to fetch.
     */
    where?: DeclaracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declaracions to fetch.
     */
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Declaracions.
     */
    cursor?: DeclaracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declaracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declaracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Declaracions.
     */
    distinct?: DeclaracionScalarFieldEnum | DeclaracionScalarFieldEnum[]
  }

  /**
   * Declaracion findMany
   */
  export type DeclaracionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter, which Declaracions to fetch.
     */
    where?: DeclaracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Declaracions to fetch.
     */
    orderBy?: DeclaracionOrderByWithRelationInput | DeclaracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Declaracions.
     */
    cursor?: DeclaracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Declaracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Declaracions.
     */
    skip?: number
    distinct?: DeclaracionScalarFieldEnum | DeclaracionScalarFieldEnum[]
  }

  /**
   * Declaracion create
   */
  export type DeclaracionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * The data needed to create a Declaracion.
     */
    data: XOR<DeclaracionCreateInput, DeclaracionUncheckedCreateInput>
  }

  /**
   * Declaracion createMany
   */
  export type DeclaracionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Declaracions.
     */
    data: DeclaracionCreateManyInput | DeclaracionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Declaracion update
   */
  export type DeclaracionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * The data needed to update a Declaracion.
     */
    data: XOR<DeclaracionUpdateInput, DeclaracionUncheckedUpdateInput>
    /**
     * Choose, which Declaracion to update.
     */
    where: DeclaracionWhereUniqueInput
  }

  /**
   * Declaracion updateMany
   */
  export type DeclaracionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Declaracions.
     */
    data: XOR<DeclaracionUpdateManyMutationInput, DeclaracionUncheckedUpdateManyInput>
    /**
     * Filter which Declaracions to update
     */
    where?: DeclaracionWhereInput
    /**
     * Limit how many Declaracions to update.
     */
    limit?: number
  }

  /**
   * Declaracion upsert
   */
  export type DeclaracionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * The filter to search for the Declaracion to update in case it exists.
     */
    where: DeclaracionWhereUniqueInput
    /**
     * In case the Declaracion found by the `where` argument doesn't exist, create a new Declaracion with this data.
     */
    create: XOR<DeclaracionCreateInput, DeclaracionUncheckedCreateInput>
    /**
     * In case the Declaracion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeclaracionUpdateInput, DeclaracionUncheckedUpdateInput>
  }

  /**
   * Declaracion delete
   */
  export type DeclaracionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
    /**
     * Filter which Declaracion to delete.
     */
    where: DeclaracionWhereUniqueInput
  }

  /**
   * Declaracion deleteMany
   */
  export type DeclaracionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Declaracions to delete
     */
    where?: DeclaracionWhereInput
    /**
     * Limit how many Declaracions to delete.
     */
    limit?: number
  }

  /**
   * Declaracion without action
   */
  export type DeclaracionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Declaracion
     */
    select?: DeclaracionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Declaracion
     */
    omit?: DeclaracionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeclaracionInclude<ExtArgs> | null
  }


  /**
   * Model Notificacion
   */

  export type AggregateNotificacion = {
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  export type NotificacionMinAggregateOutputType = {
    id: string | null
    clienteId: string | null
    periodo: string | null
    tipo: $Enums.TipoNotificacion | null
    fechaEnvio: Date | null
    enviada: boolean | null
    asunto: string | null
    mensaje: string | null
    createdAt: Date | null
  }

  export type NotificacionMaxAggregateOutputType = {
    id: string | null
    clienteId: string | null
    periodo: string | null
    tipo: $Enums.TipoNotificacion | null
    fechaEnvio: Date | null
    enviada: boolean | null
    asunto: string | null
    mensaje: string | null
    createdAt: Date | null
  }

  export type NotificacionCountAggregateOutputType = {
    id: number
    clienteId: number
    periodo: number
    tipo: number
    fechaEnvio: number
    enviada: number
    asunto: number
    mensaje: number
    createdAt: number
    _all: number
  }


  export type NotificacionMinAggregateInputType = {
    id?: true
    clienteId?: true
    periodo?: true
    tipo?: true
    fechaEnvio?: true
    enviada?: true
    asunto?: true
    mensaje?: true
    createdAt?: true
  }

  export type NotificacionMaxAggregateInputType = {
    id?: true
    clienteId?: true
    periodo?: true
    tipo?: true
    fechaEnvio?: true
    enviada?: true
    asunto?: true
    mensaje?: true
    createdAt?: true
  }

  export type NotificacionCountAggregateInputType = {
    id?: true
    clienteId?: true
    periodo?: true
    tipo?: true
    fechaEnvio?: true
    enviada?: true
    asunto?: true
    mensaje?: true
    createdAt?: true
    _all?: true
  }

  export type NotificacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacion to aggregate.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notificacions
    **/
    _count?: true | NotificacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificacionMaxAggregateInputType
  }

  export type GetNotificacionAggregateType<T extends NotificacionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificacion[P]>
      : GetScalarType<T[P], AggregateNotificacion[P]>
  }




  export type NotificacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificacionWhereInput
    orderBy?: NotificacionOrderByWithAggregationInput | NotificacionOrderByWithAggregationInput[]
    by: NotificacionScalarFieldEnum[] | NotificacionScalarFieldEnum
    having?: NotificacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificacionCountAggregateInputType | true
    _min?: NotificacionMinAggregateInputType
    _max?: NotificacionMaxAggregateInputType
  }

  export type NotificacionGroupByOutputType = {
    id: string
    clienteId: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date
    enviada: boolean
    asunto: string | null
    mensaje: string | null
    createdAt: Date
    _count: NotificacionCountAggregateOutputType | null
    _min: NotificacionMinAggregateOutputType | null
    _max: NotificacionMaxAggregateOutputType | null
  }

  type GetNotificacionGroupByPayload<T extends NotificacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificacionGroupByOutputType[P]>
        }
      >
    >


  export type NotificacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clienteId?: boolean
    periodo?: boolean
    tipo?: boolean
    fechaEnvio?: boolean
    enviada?: boolean
    asunto?: boolean
    mensaje?: boolean
    createdAt?: boolean
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificacion"]>



  export type NotificacionSelectScalar = {
    id?: boolean
    clienteId?: boolean
    periodo?: boolean
    tipo?: boolean
    fechaEnvio?: boolean
    enviada?: boolean
    asunto?: boolean
    mensaje?: boolean
    createdAt?: boolean
  }

  export type NotificacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clienteId" | "periodo" | "tipo" | "fechaEnvio" | "enviada" | "asunto" | "mensaje" | "createdAt", ExtArgs["result"]["notificacion"]>
  export type NotificacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $NotificacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notificacion"
    objects: {
      cliente: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clienteId: string
      periodo: string
      tipo: $Enums.TipoNotificacion
      fechaEnvio: Date
      enviada: boolean
      asunto: string | null
      mensaje: string | null
      createdAt: Date
    }, ExtArgs["result"]["notificacion"]>
    composites: {}
  }

  type NotificacionGetPayload<S extends boolean | null | undefined | NotificacionDefaultArgs> = $Result.GetResult<Prisma.$NotificacionPayload, S>

  type NotificacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificacionCountAggregateInputType | true
    }

  export interface NotificacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notificacion'], meta: { name: 'Notificacion' } }
    /**
     * Find zero or one Notificacion that matches the filter.
     * @param {NotificacionFindUniqueArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificacionFindUniqueArgs>(args: SelectSubset<T, NotificacionFindUniqueArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notificacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificacionFindUniqueOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificacionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificacionFindFirstArgs>(args?: SelectSubset<T, NotificacionFindFirstArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notificacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindFirstOrThrowArgs} args - Arguments to find a Notificacion
     * @example
     * // Get one Notificacion
     * const notificacion = await prisma.notificacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificacionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notificacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notificacions
     * const notificacions = await prisma.notificacion.findMany()
     * 
     * // Get first 10 Notificacions
     * const notificacions = await prisma.notificacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificacionWithIdOnly = await prisma.notificacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificacionFindManyArgs>(args?: SelectSubset<T, NotificacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notificacion.
     * @param {NotificacionCreateArgs} args - Arguments to create a Notificacion.
     * @example
     * // Create one Notificacion
     * const Notificacion = await prisma.notificacion.create({
     *   data: {
     *     // ... data to create a Notificacion
     *   }
     * })
     * 
     */
    create<T extends NotificacionCreateArgs>(args: SelectSubset<T, NotificacionCreateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notificacions.
     * @param {NotificacionCreateManyArgs} args - Arguments to create many Notificacions.
     * @example
     * // Create many Notificacions
     * const notificacion = await prisma.notificacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificacionCreateManyArgs>(args?: SelectSubset<T, NotificacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notificacion.
     * @param {NotificacionDeleteArgs} args - Arguments to delete one Notificacion.
     * @example
     * // Delete one Notificacion
     * const Notificacion = await prisma.notificacion.delete({
     *   where: {
     *     // ... filter to delete one Notificacion
     *   }
     * })
     * 
     */
    delete<T extends NotificacionDeleteArgs>(args: SelectSubset<T, NotificacionDeleteArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notificacion.
     * @param {NotificacionUpdateArgs} args - Arguments to update one Notificacion.
     * @example
     * // Update one Notificacion
     * const notificacion = await prisma.notificacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificacionUpdateArgs>(args: SelectSubset<T, NotificacionUpdateArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notificacions.
     * @param {NotificacionDeleteManyArgs} args - Arguments to filter Notificacions to delete.
     * @example
     * // Delete a few Notificacions
     * const { count } = await prisma.notificacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificacionDeleteManyArgs>(args?: SelectSubset<T, NotificacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notificacions
     * const notificacion = await prisma.notificacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificacionUpdateManyArgs>(args: SelectSubset<T, NotificacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notificacion.
     * @param {NotificacionUpsertArgs} args - Arguments to update or create a Notificacion.
     * @example
     * // Update or create a Notificacion
     * const notificacion = await prisma.notificacion.upsert({
     *   create: {
     *     // ... data to create a Notificacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notificacion we want to update
     *   }
     * })
     */
    upsert<T extends NotificacionUpsertArgs>(args: SelectSubset<T, NotificacionUpsertArgs<ExtArgs>>): Prisma__NotificacionClient<$Result.GetResult<Prisma.$NotificacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notificacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionCountArgs} args - Arguments to filter Notificacions to count.
     * @example
     * // Count the number of Notificacions
     * const count = await prisma.notificacion.count({
     *   where: {
     *     // ... the filter for the Notificacions we want to count
     *   }
     * })
    **/
    count<T extends NotificacionCountArgs>(
      args?: Subset<T, NotificacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificacionAggregateArgs>(args: Subset<T, NotificacionAggregateArgs>): Prisma.PrismaPromise<GetNotificacionAggregateType<T>>

    /**
     * Group by Notificacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificacionGroupByArgs['orderBy'] }
        : { orderBy?: NotificacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notificacion model
   */
  readonly fields: NotificacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notificacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notificacion model
   */
  interface NotificacionFieldRefs {
    readonly id: FieldRef<"Notificacion", 'String'>
    readonly clienteId: FieldRef<"Notificacion", 'String'>
    readonly periodo: FieldRef<"Notificacion", 'String'>
    readonly tipo: FieldRef<"Notificacion", 'TipoNotificacion'>
    readonly fechaEnvio: FieldRef<"Notificacion", 'DateTime'>
    readonly enviada: FieldRef<"Notificacion", 'Boolean'>
    readonly asunto: FieldRef<"Notificacion", 'String'>
    readonly mensaje: FieldRef<"Notificacion", 'String'>
    readonly createdAt: FieldRef<"Notificacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notificacion findUnique
   */
  export type NotificacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findUniqueOrThrow
   */
  export type NotificacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion findFirst
   */
  export type NotificacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findFirstOrThrow
   */
  export type NotificacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacion to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notificacions.
     */
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion findMany
   */
  export type NotificacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter, which Notificacions to fetch.
     */
    where?: NotificacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notificacions to fetch.
     */
    orderBy?: NotificacionOrderByWithRelationInput | NotificacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notificacions.
     */
    cursor?: NotificacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notificacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notificacions.
     */
    skip?: number
    distinct?: NotificacionScalarFieldEnum | NotificacionScalarFieldEnum[]
  }

  /**
   * Notificacion create
   */
  export type NotificacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Notificacion.
     */
    data: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
  }

  /**
   * Notificacion createMany
   */
  export type NotificacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notificacions.
     */
    data: NotificacionCreateManyInput | NotificacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notificacion update
   */
  export type NotificacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Notificacion.
     */
    data: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
    /**
     * Choose, which Notificacion to update.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion updateMany
   */
  export type NotificacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notificacions.
     */
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyInput>
    /**
     * Filter which Notificacions to update
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to update.
     */
    limit?: number
  }

  /**
   * Notificacion upsert
   */
  export type NotificacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Notificacion to update in case it exists.
     */
    where: NotificacionWhereUniqueInput
    /**
     * In case the Notificacion found by the `where` argument doesn't exist, create a new Notificacion with this data.
     */
    create: XOR<NotificacionCreateInput, NotificacionUncheckedCreateInput>
    /**
     * In case the Notificacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificacionUpdateInput, NotificacionUncheckedUpdateInput>
  }

  /**
   * Notificacion delete
   */
  export type NotificacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
    /**
     * Filter which Notificacion to delete.
     */
    where: NotificacionWhereUniqueInput
  }

  /**
   * Notificacion deleteMany
   */
  export type NotificacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notificacions to delete
     */
    where?: NotificacionWhereInput
    /**
     * Limit how many Notificacions to delete.
     */
    limit?: number
  }

  /**
   * Notificacion without action
   */
  export type NotificacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notificacion
     */
    select?: NotificacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notificacion
     */
    omit?: NotificacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificacionInclude<ExtArgs> | null
  }


  /**
   * Model taxModel
   */

  export type AggregateTaxModel = {
    _count: TaxModelCountAggregateOutputType | null
    _min: TaxModelMinAggregateOutputType | null
    _max: TaxModelMaxAggregateOutputType | null
  }

  export type TaxModelMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type TaxModelMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
  }

  export type TaxModelCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type TaxModelMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type TaxModelMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type TaxModelCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type TaxModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxModel to aggregate.
     */
    where?: taxModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxModels to fetch.
     */
    orderBy?: taxModelOrderByWithRelationInput | taxModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taxModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taxModels
    **/
    _count?: true | TaxModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxModelMaxAggregateInputType
  }

  export type GetTaxModelAggregateType<T extends TaxModelAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxModel[P]>
      : GetScalarType<T[P], AggregateTaxModel[P]>
  }




  export type taxModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taxModelWhereInput
    orderBy?: taxModelOrderByWithAggregationInput | taxModelOrderByWithAggregationInput[]
    by: TaxModelScalarFieldEnum[] | TaxModelScalarFieldEnum
    having?: taxModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxModelCountAggregateInputType | true
    _min?: TaxModelMinAggregateInputType
    _max?: TaxModelMaxAggregateInputType
  }

  export type TaxModelGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    _count: TaxModelCountAggregateOutputType | null
    _min: TaxModelMinAggregateOutputType | null
    _max: TaxModelMaxAggregateOutputType | null
  }

  type GetTaxModelGroupByPayload<T extends taxModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxModelGroupByOutputType[P]>
            : GetScalarType<T[P], TaxModelGroupByOutputType[P]>
        }
      >
    >


  export type taxModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    periods?: boolean | taxModel$periodsArgs<ExtArgs>
    _count?: boolean | TaxModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxModel"]>



  export type taxModelSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type taxModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion", ExtArgs["result"]["taxModel"]>
  export type taxModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periods?: boolean | taxModel$periodsArgs<ExtArgs>
    _count?: boolean | TaxModelCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $taxModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taxModel"
    objects: {
      periods: Prisma.$taxPeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["taxModel"]>
    composites: {}
  }

  type taxModelGetPayload<S extends boolean | null | undefined | taxModelDefaultArgs> = $Result.GetResult<Prisma.$taxModelPayload, S>

  type taxModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<taxModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxModelCountAggregateInputType | true
    }

  export interface taxModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taxModel'], meta: { name: 'taxModel' } }
    /**
     * Find zero or one TaxModel that matches the filter.
     * @param {taxModelFindUniqueArgs} args - Arguments to find a TaxModel
     * @example
     * // Get one TaxModel
     * const taxModel = await prisma.taxModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends taxModelFindUniqueArgs>(args: SelectSubset<T, taxModelFindUniqueArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {taxModelFindUniqueOrThrowArgs} args - Arguments to find a TaxModel
     * @example
     * // Get one TaxModel
     * const taxModel = await prisma.taxModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends taxModelFindUniqueOrThrowArgs>(args: SelectSubset<T, taxModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelFindFirstArgs} args - Arguments to find a TaxModel
     * @example
     * // Get one TaxModel
     * const taxModel = await prisma.taxModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends taxModelFindFirstArgs>(args?: SelectSubset<T, taxModelFindFirstArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelFindFirstOrThrowArgs} args - Arguments to find a TaxModel
     * @example
     * // Get one TaxModel
     * const taxModel = await prisma.taxModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends taxModelFindFirstOrThrowArgs>(args?: SelectSubset<T, taxModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxModels
     * const taxModels = await prisma.taxModel.findMany()
     * 
     * // Get first 10 TaxModels
     * const taxModels = await prisma.taxModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxModelWithIdOnly = await prisma.taxModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends taxModelFindManyArgs>(args?: SelectSubset<T, taxModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxModel.
     * @param {taxModelCreateArgs} args - Arguments to create a TaxModel.
     * @example
     * // Create one TaxModel
     * const TaxModel = await prisma.taxModel.create({
     *   data: {
     *     // ... data to create a TaxModel
     *   }
     * })
     * 
     */
    create<T extends taxModelCreateArgs>(args: SelectSubset<T, taxModelCreateArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxModels.
     * @param {taxModelCreateManyArgs} args - Arguments to create many TaxModels.
     * @example
     * // Create many TaxModels
     * const taxModel = await prisma.taxModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends taxModelCreateManyArgs>(args?: SelectSubset<T, taxModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaxModel.
     * @param {taxModelDeleteArgs} args - Arguments to delete one TaxModel.
     * @example
     * // Delete one TaxModel
     * const TaxModel = await prisma.taxModel.delete({
     *   where: {
     *     // ... filter to delete one TaxModel
     *   }
     * })
     * 
     */
    delete<T extends taxModelDeleteArgs>(args: SelectSubset<T, taxModelDeleteArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxModel.
     * @param {taxModelUpdateArgs} args - Arguments to update one TaxModel.
     * @example
     * // Update one TaxModel
     * const taxModel = await prisma.taxModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends taxModelUpdateArgs>(args: SelectSubset<T, taxModelUpdateArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxModels.
     * @param {taxModelDeleteManyArgs} args - Arguments to filter TaxModels to delete.
     * @example
     * // Delete a few TaxModels
     * const { count } = await prisma.taxModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends taxModelDeleteManyArgs>(args?: SelectSubset<T, taxModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxModels
     * const taxModel = await prisma.taxModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends taxModelUpdateManyArgs>(args: SelectSubset<T, taxModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxModel.
     * @param {taxModelUpsertArgs} args - Arguments to update or create a TaxModel.
     * @example
     * // Update or create a TaxModel
     * const taxModel = await prisma.taxModel.upsert({
     *   create: {
     *     // ... data to create a TaxModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxModel we want to update
     *   }
     * })
     */
    upsert<T extends taxModelUpsertArgs>(args: SelectSubset<T, taxModelUpsertArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelCountArgs} args - Arguments to filter TaxModels to count.
     * @example
     * // Count the number of TaxModels
     * const count = await prisma.taxModel.count({
     *   where: {
     *     // ... the filter for the TaxModels we want to count
     *   }
     * })
    **/
    count<T extends taxModelCountArgs>(
      args?: Subset<T, taxModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxModelAggregateArgs>(args: Subset<T, TaxModelAggregateArgs>): Prisma.PrismaPromise<GetTaxModelAggregateType<T>>

    /**
     * Group by TaxModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends taxModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: taxModelGroupByArgs['orderBy'] }
        : { orderBy?: taxModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, taxModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taxModel model
   */
  readonly fields: taxModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taxModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__taxModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    periods<T extends taxModel$periodsArgs<ExtArgs> = {}>(args?: Subset<T, taxModel$periodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taxModel model
   */
  interface taxModelFieldRefs {
    readonly id: FieldRef<"taxModel", 'String'>
    readonly nombre: FieldRef<"taxModel", 'String'>
    readonly descripcion: FieldRef<"taxModel", 'String'>
  }
    

  // Custom InputTypes
  /**
   * taxModel findUnique
   */
  export type taxModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter, which taxModel to fetch.
     */
    where: taxModelWhereUniqueInput
  }

  /**
   * taxModel findUniqueOrThrow
   */
  export type taxModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter, which taxModel to fetch.
     */
    where: taxModelWhereUniqueInput
  }

  /**
   * taxModel findFirst
   */
  export type taxModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter, which taxModel to fetch.
     */
    where?: taxModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxModels to fetch.
     */
    orderBy?: taxModelOrderByWithRelationInput | taxModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxModels.
     */
    cursor?: taxModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxModels.
     */
    distinct?: TaxModelScalarFieldEnum | TaxModelScalarFieldEnum[]
  }

  /**
   * taxModel findFirstOrThrow
   */
  export type taxModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter, which taxModel to fetch.
     */
    where?: taxModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxModels to fetch.
     */
    orderBy?: taxModelOrderByWithRelationInput | taxModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxModels.
     */
    cursor?: taxModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxModels.
     */
    distinct?: TaxModelScalarFieldEnum | TaxModelScalarFieldEnum[]
  }

  /**
   * taxModel findMany
   */
  export type taxModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter, which taxModels to fetch.
     */
    where?: taxModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxModels to fetch.
     */
    orderBy?: taxModelOrderByWithRelationInput | taxModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taxModels.
     */
    cursor?: taxModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxModels.
     */
    skip?: number
    distinct?: TaxModelScalarFieldEnum | TaxModelScalarFieldEnum[]
  }

  /**
   * taxModel create
   */
  export type taxModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * The data needed to create a taxModel.
     */
    data: XOR<taxModelCreateInput, taxModelUncheckedCreateInput>
  }

  /**
   * taxModel createMany
   */
  export type taxModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many taxModels.
     */
    data: taxModelCreateManyInput | taxModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taxModel update
   */
  export type taxModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * The data needed to update a taxModel.
     */
    data: XOR<taxModelUpdateInput, taxModelUncheckedUpdateInput>
    /**
     * Choose, which taxModel to update.
     */
    where: taxModelWhereUniqueInput
  }

  /**
   * taxModel updateMany
   */
  export type taxModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update taxModels.
     */
    data: XOR<taxModelUpdateManyMutationInput, taxModelUncheckedUpdateManyInput>
    /**
     * Filter which taxModels to update
     */
    where?: taxModelWhereInput
    /**
     * Limit how many taxModels to update.
     */
    limit?: number
  }

  /**
   * taxModel upsert
   */
  export type taxModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * The filter to search for the taxModel to update in case it exists.
     */
    where: taxModelWhereUniqueInput
    /**
     * In case the taxModel found by the `where` argument doesn't exist, create a new taxModel with this data.
     */
    create: XOR<taxModelCreateInput, taxModelUncheckedCreateInput>
    /**
     * In case the taxModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taxModelUpdateInput, taxModelUncheckedUpdateInput>
  }

  /**
   * taxModel delete
   */
  export type taxModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
    /**
     * Filter which taxModel to delete.
     */
    where: taxModelWhereUniqueInput
  }

  /**
   * taxModel deleteMany
   */
  export type taxModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxModels to delete
     */
    where?: taxModelWhereInput
    /**
     * Limit how many taxModels to delete.
     */
    limit?: number
  }

  /**
   * taxModel.periods
   */
  export type taxModel$periodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    where?: taxPeriodWhereInput
    orderBy?: taxPeriodOrderByWithRelationInput | taxPeriodOrderByWithRelationInput[]
    cursor?: taxPeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxPeriodScalarFieldEnum | TaxPeriodScalarFieldEnum[]
  }

  /**
   * taxModel without action
   */
  export type taxModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxModel
     */
    select?: taxModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxModel
     */
    omit?: taxModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxModelInclude<ExtArgs> | null
  }


  /**
   * Model taxPeriod
   */

  export type AggregateTaxPeriod = {
    _count: TaxPeriodCountAggregateOutputType | null
    _avg: TaxPeriodAvgAggregateOutputType | null
    _sum: TaxPeriodSumAggregateOutputType | null
    _min: TaxPeriodMinAggregateOutputType | null
    _max: TaxPeriodMaxAggregateOutputType | null
  }

  export type TaxPeriodAvgAggregateOutputType = {
    anio: number | null
    trimestre: number | null
    mes: number | null
  }

  export type TaxPeriodSumAggregateOutputType = {
    anio: number | null
    trimestre: number | null
    mes: number | null
  }

  export type TaxPeriodMinAggregateOutputType = {
    id: string | null
    modeloId: string | null
    anio: number | null
    trimestre: number | null
    mes: number | null
    inicioPresentacion: Date | null
    finPresentacion: Date | null
  }

  export type TaxPeriodMaxAggregateOutputType = {
    id: string | null
    modeloId: string | null
    anio: number | null
    trimestre: number | null
    mes: number | null
    inicioPresentacion: Date | null
    finPresentacion: Date | null
  }

  export type TaxPeriodCountAggregateOutputType = {
    id: number
    modeloId: number
    anio: number
    trimestre: number
    mes: number
    inicioPresentacion: number
    finPresentacion: number
    _all: number
  }


  export type TaxPeriodAvgAggregateInputType = {
    anio?: true
    trimestre?: true
    mes?: true
  }

  export type TaxPeriodSumAggregateInputType = {
    anio?: true
    trimestre?: true
    mes?: true
  }

  export type TaxPeriodMinAggregateInputType = {
    id?: true
    modeloId?: true
    anio?: true
    trimestre?: true
    mes?: true
    inicioPresentacion?: true
    finPresentacion?: true
  }

  export type TaxPeriodMaxAggregateInputType = {
    id?: true
    modeloId?: true
    anio?: true
    trimestre?: true
    mes?: true
    inicioPresentacion?: true
    finPresentacion?: true
  }

  export type TaxPeriodCountAggregateInputType = {
    id?: true
    modeloId?: true
    anio?: true
    trimestre?: true
    mes?: true
    inicioPresentacion?: true
    finPresentacion?: true
    _all?: true
  }

  export type TaxPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxPeriod to aggregate.
     */
    where?: taxPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxPeriods to fetch.
     */
    orderBy?: taxPeriodOrderByWithRelationInput | taxPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taxPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taxPeriods
    **/
    _count?: true | TaxPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxPeriodMaxAggregateInputType
  }

  export type GetTaxPeriodAggregateType<T extends TaxPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxPeriod[P]>
      : GetScalarType<T[P], AggregateTaxPeriod[P]>
  }




  export type taxPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taxPeriodWhereInput
    orderBy?: taxPeriodOrderByWithAggregationInput | taxPeriodOrderByWithAggregationInput[]
    by: TaxPeriodScalarFieldEnum[] | TaxPeriodScalarFieldEnum
    having?: taxPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxPeriodCountAggregateInputType | true
    _avg?: TaxPeriodAvgAggregateInputType
    _sum?: TaxPeriodSumAggregateInputType
    _min?: TaxPeriodMinAggregateInputType
    _max?: TaxPeriodMaxAggregateInputType
  }

  export type TaxPeriodGroupByOutputType = {
    id: string
    modeloId: string
    anio: number
    trimestre: number | null
    mes: number | null
    inicioPresentacion: Date
    finPresentacion: Date
    _count: TaxPeriodCountAggregateOutputType | null
    _avg: TaxPeriodAvgAggregateOutputType | null
    _sum: TaxPeriodSumAggregateOutputType | null
    _min: TaxPeriodMinAggregateOutputType | null
    _max: TaxPeriodMaxAggregateOutputType | null
  }

  type GetTaxPeriodGroupByPayload<T extends taxPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], TaxPeriodGroupByOutputType[P]>
        }
      >
    >


  export type taxPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modeloId?: boolean
    anio?: boolean
    trimestre?: boolean
    mes?: boolean
    inicioPresentacion?: boolean
    finPresentacion?: boolean
    modelo?: boolean | taxModelDefaultArgs<ExtArgs>
    clientTaxes?: boolean | taxPeriod$clientTaxesArgs<ExtArgs>
    _count?: boolean | TaxPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxPeriod"]>



  export type taxPeriodSelectScalar = {
    id?: boolean
    modeloId?: boolean
    anio?: boolean
    trimestre?: boolean
    mes?: boolean
    inicioPresentacion?: boolean
    finPresentacion?: boolean
  }

  export type taxPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modeloId" | "anio" | "trimestre" | "mes" | "inicioPresentacion" | "finPresentacion", ExtArgs["result"]["taxPeriod"]>
  export type taxPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    modelo?: boolean | taxModelDefaultArgs<ExtArgs>
    clientTaxes?: boolean | taxPeriod$clientTaxesArgs<ExtArgs>
    _count?: boolean | TaxPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $taxPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taxPeriod"
    objects: {
      modelo: Prisma.$taxModelPayload<ExtArgs>
      clientTaxes: Prisma.$clientTaxPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modeloId: string
      anio: number
      trimestre: number | null
      mes: number | null
      inicioPresentacion: Date
      finPresentacion: Date
    }, ExtArgs["result"]["taxPeriod"]>
    composites: {}
  }

  type taxPeriodGetPayload<S extends boolean | null | undefined | taxPeriodDefaultArgs> = $Result.GetResult<Prisma.$taxPeriodPayload, S>

  type taxPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<taxPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxPeriodCountAggregateInputType | true
    }

  export interface taxPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taxPeriod'], meta: { name: 'taxPeriod' } }
    /**
     * Find zero or one TaxPeriod that matches the filter.
     * @param {taxPeriodFindUniqueArgs} args - Arguments to find a TaxPeriod
     * @example
     * // Get one TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends taxPeriodFindUniqueArgs>(args: SelectSubset<T, taxPeriodFindUniqueArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {taxPeriodFindUniqueOrThrowArgs} args - Arguments to find a TaxPeriod
     * @example
     * // Get one TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends taxPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, taxPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodFindFirstArgs} args - Arguments to find a TaxPeriod
     * @example
     * // Get one TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends taxPeriodFindFirstArgs>(args?: SelectSubset<T, taxPeriodFindFirstArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodFindFirstOrThrowArgs} args - Arguments to find a TaxPeriod
     * @example
     * // Get one TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends taxPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, taxPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxPeriods
     * const taxPeriods = await prisma.taxPeriod.findMany()
     * 
     * // Get first 10 TaxPeriods
     * const taxPeriods = await prisma.taxPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxPeriodWithIdOnly = await prisma.taxPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends taxPeriodFindManyArgs>(args?: SelectSubset<T, taxPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxPeriod.
     * @param {taxPeriodCreateArgs} args - Arguments to create a TaxPeriod.
     * @example
     * // Create one TaxPeriod
     * const TaxPeriod = await prisma.taxPeriod.create({
     *   data: {
     *     // ... data to create a TaxPeriod
     *   }
     * })
     * 
     */
    create<T extends taxPeriodCreateArgs>(args: SelectSubset<T, taxPeriodCreateArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxPeriods.
     * @param {taxPeriodCreateManyArgs} args - Arguments to create many TaxPeriods.
     * @example
     * // Create many TaxPeriods
     * const taxPeriod = await prisma.taxPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends taxPeriodCreateManyArgs>(args?: SelectSubset<T, taxPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaxPeriod.
     * @param {taxPeriodDeleteArgs} args - Arguments to delete one TaxPeriod.
     * @example
     * // Delete one TaxPeriod
     * const TaxPeriod = await prisma.taxPeriod.delete({
     *   where: {
     *     // ... filter to delete one TaxPeriod
     *   }
     * })
     * 
     */
    delete<T extends taxPeriodDeleteArgs>(args: SelectSubset<T, taxPeriodDeleteArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxPeriod.
     * @param {taxPeriodUpdateArgs} args - Arguments to update one TaxPeriod.
     * @example
     * // Update one TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends taxPeriodUpdateArgs>(args: SelectSubset<T, taxPeriodUpdateArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxPeriods.
     * @param {taxPeriodDeleteManyArgs} args - Arguments to filter TaxPeriods to delete.
     * @example
     * // Delete a few TaxPeriods
     * const { count } = await prisma.taxPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends taxPeriodDeleteManyArgs>(args?: SelectSubset<T, taxPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxPeriods
     * const taxPeriod = await prisma.taxPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends taxPeriodUpdateManyArgs>(args: SelectSubset<T, taxPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxPeriod.
     * @param {taxPeriodUpsertArgs} args - Arguments to update or create a TaxPeriod.
     * @example
     * // Update or create a TaxPeriod
     * const taxPeriod = await prisma.taxPeriod.upsert({
     *   create: {
     *     // ... data to create a TaxPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxPeriod we want to update
     *   }
     * })
     */
    upsert<T extends taxPeriodUpsertArgs>(args: SelectSubset<T, taxPeriodUpsertArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodCountArgs} args - Arguments to filter TaxPeriods to count.
     * @example
     * // Count the number of TaxPeriods
     * const count = await prisma.taxPeriod.count({
     *   where: {
     *     // ... the filter for the TaxPeriods we want to count
     *   }
     * })
    **/
    count<T extends taxPeriodCountArgs>(
      args?: Subset<T, taxPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxPeriodAggregateArgs>(args: Subset<T, TaxPeriodAggregateArgs>): Prisma.PrismaPromise<GetTaxPeriodAggregateType<T>>

    /**
     * Group by TaxPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends taxPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: taxPeriodGroupByArgs['orderBy'] }
        : { orderBy?: taxPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, taxPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taxPeriod model
   */
  readonly fields: taxPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taxPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__taxPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    modelo<T extends taxModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, taxModelDefaultArgs<ExtArgs>>): Prisma__taxModelClient<$Result.GetResult<Prisma.$taxModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientTaxes<T extends taxPeriod$clientTaxesArgs<ExtArgs> = {}>(args?: Subset<T, taxPeriod$clientTaxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taxPeriod model
   */
  interface taxPeriodFieldRefs {
    readonly id: FieldRef<"taxPeriod", 'String'>
    readonly modeloId: FieldRef<"taxPeriod", 'String'>
    readonly anio: FieldRef<"taxPeriod", 'Int'>
    readonly trimestre: FieldRef<"taxPeriod", 'Int'>
    readonly mes: FieldRef<"taxPeriod", 'Int'>
    readonly inicioPresentacion: FieldRef<"taxPeriod", 'DateTime'>
    readonly finPresentacion: FieldRef<"taxPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * taxPeriod findUnique
   */
  export type taxPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter, which taxPeriod to fetch.
     */
    where: taxPeriodWhereUniqueInput
  }

  /**
   * taxPeriod findUniqueOrThrow
   */
  export type taxPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter, which taxPeriod to fetch.
     */
    where: taxPeriodWhereUniqueInput
  }

  /**
   * taxPeriod findFirst
   */
  export type taxPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter, which taxPeriod to fetch.
     */
    where?: taxPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxPeriods to fetch.
     */
    orderBy?: taxPeriodOrderByWithRelationInput | taxPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxPeriods.
     */
    cursor?: taxPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxPeriods.
     */
    distinct?: TaxPeriodScalarFieldEnum | TaxPeriodScalarFieldEnum[]
  }

  /**
   * taxPeriod findFirstOrThrow
   */
  export type taxPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter, which taxPeriod to fetch.
     */
    where?: taxPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxPeriods to fetch.
     */
    orderBy?: taxPeriodOrderByWithRelationInput | taxPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxPeriods.
     */
    cursor?: taxPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxPeriods.
     */
    distinct?: TaxPeriodScalarFieldEnum | TaxPeriodScalarFieldEnum[]
  }

  /**
   * taxPeriod findMany
   */
  export type taxPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter, which taxPeriods to fetch.
     */
    where?: taxPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxPeriods to fetch.
     */
    orderBy?: taxPeriodOrderByWithRelationInput | taxPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taxPeriods.
     */
    cursor?: taxPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxPeriods.
     */
    skip?: number
    distinct?: TaxPeriodScalarFieldEnum | TaxPeriodScalarFieldEnum[]
  }

  /**
   * taxPeriod create
   */
  export type taxPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a taxPeriod.
     */
    data: XOR<taxPeriodCreateInput, taxPeriodUncheckedCreateInput>
  }

  /**
   * taxPeriod createMany
   */
  export type taxPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many taxPeriods.
     */
    data: taxPeriodCreateManyInput | taxPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taxPeriod update
   */
  export type taxPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a taxPeriod.
     */
    data: XOR<taxPeriodUpdateInput, taxPeriodUncheckedUpdateInput>
    /**
     * Choose, which taxPeriod to update.
     */
    where: taxPeriodWhereUniqueInput
  }

  /**
   * taxPeriod updateMany
   */
  export type taxPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update taxPeriods.
     */
    data: XOR<taxPeriodUpdateManyMutationInput, taxPeriodUncheckedUpdateManyInput>
    /**
     * Filter which taxPeriods to update
     */
    where?: taxPeriodWhereInput
    /**
     * Limit how many taxPeriods to update.
     */
    limit?: number
  }

  /**
   * taxPeriod upsert
   */
  export type taxPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the taxPeriod to update in case it exists.
     */
    where: taxPeriodWhereUniqueInput
    /**
     * In case the taxPeriod found by the `where` argument doesn't exist, create a new taxPeriod with this data.
     */
    create: XOR<taxPeriodCreateInput, taxPeriodUncheckedCreateInput>
    /**
     * In case the taxPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taxPeriodUpdateInput, taxPeriodUncheckedUpdateInput>
  }

  /**
   * taxPeriod delete
   */
  export type taxPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
    /**
     * Filter which taxPeriod to delete.
     */
    where: taxPeriodWhereUniqueInput
  }

  /**
   * taxPeriod deleteMany
   */
  export type taxPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxPeriods to delete
     */
    where?: taxPeriodWhereInput
    /**
     * Limit how many taxPeriods to delete.
     */
    limit?: number
  }

  /**
   * taxPeriod.clientTaxes
   */
  export type taxPeriod$clientTaxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    where?: clientTaxWhereInput
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    cursor?: clientTaxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTaxScalarFieldEnum | ClientTaxScalarFieldEnum[]
  }

  /**
   * taxPeriod without action
   */
  export type taxPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxPeriod
     */
    select?: taxPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxPeriod
     */
    omit?: taxPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxPeriodInclude<ExtArgs> | null
  }


  /**
   * Model clientTax
   */

  export type AggregateClientTax = {
    _count: ClientTaxCountAggregateOutputType | null
    _min: ClientTaxMinAggregateOutputType | null
    _max: ClientTaxMaxAggregateOutputType | null
  }

  export type ClientTaxMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    taxPeriodId: string | null
    estado: string | null
    notas: string | null
    displayText: string | null
    colorTag: string | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type ClientTaxMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    taxPeriodId: string | null
    estado: string | null
    notas: string | null
    displayText: string | null
    colorTag: string | null
    fechaCreacion: Date | null
    fechaActualizacion: Date | null
  }

  export type ClientTaxCountAggregateOutputType = {
    id: number
    clientId: number
    taxPeriodId: number
    estado: number
    notas: number
    displayText: number
    colorTag: number
    fechaCreacion: number
    fechaActualizacion: number
    _all: number
  }


  export type ClientTaxMinAggregateInputType = {
    id?: true
    clientId?: true
    taxPeriodId?: true
    estado?: true
    notas?: true
    displayText?: true
    colorTag?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type ClientTaxMaxAggregateInputType = {
    id?: true
    clientId?: true
    taxPeriodId?: true
    estado?: true
    notas?: true
    displayText?: true
    colorTag?: true
    fechaCreacion?: true
    fechaActualizacion?: true
  }

  export type ClientTaxCountAggregateInputType = {
    id?: true
    clientId?: true
    taxPeriodId?: true
    estado?: true
    notas?: true
    displayText?: true
    colorTag?: true
    fechaCreacion?: true
    fechaActualizacion?: true
    _all?: true
  }

  export type ClientTaxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTax to aggregate.
     */
    where?: clientTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxes to fetch.
     */
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientTaxes
    **/
    _count?: true | ClientTaxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientTaxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientTaxMaxAggregateInputType
  }

  export type GetClientTaxAggregateType<T extends ClientTaxAggregateArgs> = {
        [P in keyof T & keyof AggregateClientTax]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientTax[P]>
      : GetScalarType<T[P], AggregateClientTax[P]>
  }




  export type clientTaxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxWhereInput
    orderBy?: clientTaxOrderByWithAggregationInput | clientTaxOrderByWithAggregationInput[]
    by: ClientTaxScalarFieldEnum[] | ClientTaxScalarFieldEnum
    having?: clientTaxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientTaxCountAggregateInputType | true
    _min?: ClientTaxMinAggregateInputType
    _max?: ClientTaxMaxAggregateInputType
  }

  export type ClientTaxGroupByOutputType = {
    id: string
    clientId: string
    taxPeriodId: string
    estado: string
    notas: string | null
    displayText: string | null
    colorTag: string | null
    fechaCreacion: Date
    fechaActualizacion: Date
    _count: ClientTaxCountAggregateOutputType | null
    _min: ClientTaxMinAggregateOutputType | null
    _max: ClientTaxMaxAggregateOutputType | null
  }

  type GetClientTaxGroupByPayload<T extends clientTaxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientTaxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientTaxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientTaxGroupByOutputType[P]>
            : GetScalarType<T[P], ClientTaxGroupByOutputType[P]>
        }
      >
    >


  export type clientTaxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    taxPeriodId?: boolean
    estado?: boolean
    notas?: boolean
    displayText?: boolean
    colorTag?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    period?: boolean | taxPeriodDefaultArgs<ExtArgs>
    files?: boolean | clientTax$filesArgs<ExtArgs>
    _count?: boolean | ClientTaxCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientTax"]>



  export type clientTaxSelectScalar = {
    id?: boolean
    clientId?: boolean
    taxPeriodId?: boolean
    estado?: boolean
    notas?: boolean
    displayText?: boolean
    colorTag?: boolean
    fechaCreacion?: boolean
    fechaActualizacion?: boolean
  }

  export type clientTaxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "taxPeriodId" | "estado" | "notas" | "displayText" | "colorTag" | "fechaCreacion" | "fechaActualizacion", ExtArgs["result"]["clientTax"]>
  export type clientTaxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    period?: boolean | taxPeriodDefaultArgs<ExtArgs>
    files?: boolean | clientTax$filesArgs<ExtArgs>
    _count?: boolean | ClientTaxCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $clientTaxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientTax"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      period: Prisma.$taxPeriodPayload<ExtArgs>
      files: Prisma.$taxFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      taxPeriodId: string
      estado: string
      notas: string | null
      displayText: string | null
      colorTag: string | null
      fechaCreacion: Date
      fechaActualizacion: Date
    }, ExtArgs["result"]["clientTax"]>
    composites: {}
  }

  type clientTaxGetPayload<S extends boolean | null | undefined | clientTaxDefaultArgs> = $Result.GetResult<Prisma.$clientTaxPayload, S>

  type clientTaxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientTaxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientTaxCountAggregateInputType | true
    }

  export interface clientTaxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientTax'], meta: { name: 'clientTax' } }
    /**
     * Find zero or one ClientTax that matches the filter.
     * @param {clientTaxFindUniqueArgs} args - Arguments to find a ClientTax
     * @example
     * // Get one ClientTax
     * const clientTax = await prisma.clientTax.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientTaxFindUniqueArgs>(args: SelectSubset<T, clientTaxFindUniqueArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientTax that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientTaxFindUniqueOrThrowArgs} args - Arguments to find a ClientTax
     * @example
     * // Get one ClientTax
     * const clientTax = await prisma.clientTax.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientTaxFindUniqueOrThrowArgs>(args: SelectSubset<T, clientTaxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTax that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFindFirstArgs} args - Arguments to find a ClientTax
     * @example
     * // Get one ClientTax
     * const clientTax = await prisma.clientTax.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientTaxFindFirstArgs>(args?: SelectSubset<T, clientTaxFindFirstArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTax that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFindFirstOrThrowArgs} args - Arguments to find a ClientTax
     * @example
     * // Get one ClientTax
     * const clientTax = await prisma.clientTax.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientTaxFindFirstOrThrowArgs>(args?: SelectSubset<T, clientTaxFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientTaxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientTaxes
     * const clientTaxes = await prisma.clientTax.findMany()
     * 
     * // Get first 10 ClientTaxes
     * const clientTaxes = await prisma.clientTax.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientTaxWithIdOnly = await prisma.clientTax.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientTaxFindManyArgs>(args?: SelectSubset<T, clientTaxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientTax.
     * @param {clientTaxCreateArgs} args - Arguments to create a ClientTax.
     * @example
     * // Create one ClientTax
     * const ClientTax = await prisma.clientTax.create({
     *   data: {
     *     // ... data to create a ClientTax
     *   }
     * })
     * 
     */
    create<T extends clientTaxCreateArgs>(args: SelectSubset<T, clientTaxCreateArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientTaxes.
     * @param {clientTaxCreateManyArgs} args - Arguments to create many ClientTaxes.
     * @example
     * // Create many ClientTaxes
     * const clientTax = await prisma.clientTax.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientTaxCreateManyArgs>(args?: SelectSubset<T, clientTaxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientTax.
     * @param {clientTaxDeleteArgs} args - Arguments to delete one ClientTax.
     * @example
     * // Delete one ClientTax
     * const ClientTax = await prisma.clientTax.delete({
     *   where: {
     *     // ... filter to delete one ClientTax
     *   }
     * })
     * 
     */
    delete<T extends clientTaxDeleteArgs>(args: SelectSubset<T, clientTaxDeleteArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientTax.
     * @param {clientTaxUpdateArgs} args - Arguments to update one ClientTax.
     * @example
     * // Update one ClientTax
     * const clientTax = await prisma.clientTax.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientTaxUpdateArgs>(args: SelectSubset<T, clientTaxUpdateArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientTaxes.
     * @param {clientTaxDeleteManyArgs} args - Arguments to filter ClientTaxes to delete.
     * @example
     * // Delete a few ClientTaxes
     * const { count } = await prisma.clientTax.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientTaxDeleteManyArgs>(args?: SelectSubset<T, clientTaxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientTaxes
     * const clientTax = await prisma.clientTax.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientTaxUpdateManyArgs>(args: SelectSubset<T, clientTaxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientTax.
     * @param {clientTaxUpsertArgs} args - Arguments to update or create a ClientTax.
     * @example
     * // Update or create a ClientTax
     * const clientTax = await prisma.clientTax.upsert({
     *   create: {
     *     // ... data to create a ClientTax
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientTax we want to update
     *   }
     * })
     */
    upsert<T extends clientTaxUpsertArgs>(args: SelectSubset<T, clientTaxUpsertArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientTaxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxCountArgs} args - Arguments to filter ClientTaxes to count.
     * @example
     * // Count the number of ClientTaxes
     * const count = await prisma.clientTax.count({
     *   where: {
     *     // ... the filter for the ClientTaxes we want to count
     *   }
     * })
    **/
    count<T extends clientTaxCountArgs>(
      args?: Subset<T, clientTaxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientTaxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTaxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientTaxAggregateArgs>(args: Subset<T, ClientTaxAggregateArgs>): Prisma.PrismaPromise<GetClientTaxAggregateType<T>>

    /**
     * Group by ClientTax.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientTaxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientTaxGroupByArgs['orderBy'] }
        : { orderBy?: clientTaxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientTaxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientTaxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientTax model
   */
  readonly fields: clientTaxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientTax.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientTaxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    period<T extends taxPeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, taxPeriodDefaultArgs<ExtArgs>>): Prisma__taxPeriodClient<$Result.GetResult<Prisma.$taxPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends clientTax$filesArgs<ExtArgs> = {}>(args?: Subset<T, clientTax$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientTax model
   */
  interface clientTaxFieldRefs {
    readonly id: FieldRef<"clientTax", 'String'>
    readonly clientId: FieldRef<"clientTax", 'String'>
    readonly taxPeriodId: FieldRef<"clientTax", 'String'>
    readonly estado: FieldRef<"clientTax", 'String'>
    readonly notas: FieldRef<"clientTax", 'String'>
    readonly displayText: FieldRef<"clientTax", 'String'>
    readonly colorTag: FieldRef<"clientTax", 'String'>
    readonly fechaCreacion: FieldRef<"clientTax", 'DateTime'>
    readonly fechaActualizacion: FieldRef<"clientTax", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clientTax findUnique
   */
  export type clientTaxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter, which clientTax to fetch.
     */
    where: clientTaxWhereUniqueInput
  }

  /**
   * clientTax findUniqueOrThrow
   */
  export type clientTaxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter, which clientTax to fetch.
     */
    where: clientTaxWhereUniqueInput
  }

  /**
   * clientTax findFirst
   */
  export type clientTaxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter, which clientTax to fetch.
     */
    where?: clientTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxes to fetch.
     */
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxes.
     */
    cursor?: clientTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxes.
     */
    distinct?: ClientTaxScalarFieldEnum | ClientTaxScalarFieldEnum[]
  }

  /**
   * clientTax findFirstOrThrow
   */
  export type clientTaxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter, which clientTax to fetch.
     */
    where?: clientTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxes to fetch.
     */
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxes.
     */
    cursor?: clientTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxes.
     */
    distinct?: ClientTaxScalarFieldEnum | ClientTaxScalarFieldEnum[]
  }

  /**
   * clientTax findMany
   */
  export type clientTaxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxes to fetch.
     */
    where?: clientTaxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxes to fetch.
     */
    orderBy?: clientTaxOrderByWithRelationInput | clientTaxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientTaxes.
     */
    cursor?: clientTaxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxes.
     */
    skip?: number
    distinct?: ClientTaxScalarFieldEnum | ClientTaxScalarFieldEnum[]
  }

  /**
   * clientTax create
   */
  export type clientTaxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * The data needed to create a clientTax.
     */
    data: XOR<clientTaxCreateInput, clientTaxUncheckedCreateInput>
  }

  /**
   * clientTax createMany
   */
  export type clientTaxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientTaxes.
     */
    data: clientTaxCreateManyInput | clientTaxCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientTax update
   */
  export type clientTaxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * The data needed to update a clientTax.
     */
    data: XOR<clientTaxUpdateInput, clientTaxUncheckedUpdateInput>
    /**
     * Choose, which clientTax to update.
     */
    where: clientTaxWhereUniqueInput
  }

  /**
   * clientTax updateMany
   */
  export type clientTaxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientTaxes.
     */
    data: XOR<clientTaxUpdateManyMutationInput, clientTaxUncheckedUpdateManyInput>
    /**
     * Filter which clientTaxes to update
     */
    where?: clientTaxWhereInput
    /**
     * Limit how many clientTaxes to update.
     */
    limit?: number
  }

  /**
   * clientTax upsert
   */
  export type clientTaxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * The filter to search for the clientTax to update in case it exists.
     */
    where: clientTaxWhereUniqueInput
    /**
     * In case the clientTax found by the `where` argument doesn't exist, create a new clientTax with this data.
     */
    create: XOR<clientTaxCreateInput, clientTaxUncheckedCreateInput>
    /**
     * In case the clientTax was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientTaxUpdateInput, clientTaxUncheckedUpdateInput>
  }

  /**
   * clientTax delete
   */
  export type clientTaxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
    /**
     * Filter which clientTax to delete.
     */
    where: clientTaxWhereUniqueInput
  }

  /**
   * clientTax deleteMany
   */
  export type clientTaxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTaxes to delete
     */
    where?: clientTaxWhereInput
    /**
     * Limit how many clientTaxes to delete.
     */
    limit?: number
  }

  /**
   * clientTax.files
   */
  export type clientTax$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    where?: taxFileWhereInput
    orderBy?: taxFileOrderByWithRelationInput | taxFileOrderByWithRelationInput[]
    cursor?: taxFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxFileScalarFieldEnum | TaxFileScalarFieldEnum[]
  }

  /**
   * clientTax without action
   */
  export type clientTaxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTax
     */
    select?: clientTaxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTax
     */
    omit?: clientTaxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxInclude<ExtArgs> | null
  }


  /**
   * Model taxFile
   */

  export type AggregateTaxFile = {
    _count: TaxFileCountAggregateOutputType | null
    _avg: TaxFileAvgAggregateOutputType | null
    _sum: TaxFileSumAggregateOutputType | null
    _min: TaxFileMinAggregateOutputType | null
    _max: TaxFileMaxAggregateOutputType | null
  }

  export type TaxFileAvgAggregateOutputType = {
    tamanio: number | null
  }

  export type TaxFileSumAggregateOutputType = {
    tamanio: number | null
  }

  export type TaxFileMinAggregateOutputType = {
    id: string | null
    clientTaxId: string | null
    nombreArchivo: string | null
    s3Url: string | null
    s3Key: string | null
    tipo: string | null
    tamanio: number | null
    fechaSubida: Date | null
    subidoPor: string | null
  }

  export type TaxFileMaxAggregateOutputType = {
    id: string | null
    clientTaxId: string | null
    nombreArchivo: string | null
    s3Url: string | null
    s3Key: string | null
    tipo: string | null
    tamanio: number | null
    fechaSubida: Date | null
    subidoPor: string | null
  }

  export type TaxFileCountAggregateOutputType = {
    id: number
    clientTaxId: number
    nombreArchivo: number
    s3Url: number
    s3Key: number
    tipo: number
    tamanio: number
    fechaSubida: number
    subidoPor: number
    _all: number
  }


  export type TaxFileAvgAggregateInputType = {
    tamanio?: true
  }

  export type TaxFileSumAggregateInputType = {
    tamanio?: true
  }

  export type TaxFileMinAggregateInputType = {
    id?: true
    clientTaxId?: true
    nombreArchivo?: true
    s3Url?: true
    s3Key?: true
    tipo?: true
    tamanio?: true
    fechaSubida?: true
    subidoPor?: true
  }

  export type TaxFileMaxAggregateInputType = {
    id?: true
    clientTaxId?: true
    nombreArchivo?: true
    s3Url?: true
    s3Key?: true
    tipo?: true
    tamanio?: true
    fechaSubida?: true
    subidoPor?: true
  }

  export type TaxFileCountAggregateInputType = {
    id?: true
    clientTaxId?: true
    nombreArchivo?: true
    s3Url?: true
    s3Key?: true
    tipo?: true
    tamanio?: true
    fechaSubida?: true
    subidoPor?: true
    _all?: true
  }

  export type TaxFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxFile to aggregate.
     */
    where?: taxFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxFiles to fetch.
     */
    orderBy?: taxFileOrderByWithRelationInput | taxFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: taxFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taxFiles
    **/
    _count?: true | TaxFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxFileMaxAggregateInputType
  }

  export type GetTaxFileAggregateType<T extends TaxFileAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxFile[P]>
      : GetScalarType<T[P], AggregateTaxFile[P]>
  }




  export type taxFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: taxFileWhereInput
    orderBy?: taxFileOrderByWithAggregationInput | taxFileOrderByWithAggregationInput[]
    by: TaxFileScalarFieldEnum[] | TaxFileScalarFieldEnum
    having?: taxFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxFileCountAggregateInputType | true
    _avg?: TaxFileAvgAggregateInputType
    _sum?: TaxFileSumAggregateInputType
    _min?: TaxFileMinAggregateInputType
    _max?: TaxFileMaxAggregateInputType
  }

  export type TaxFileGroupByOutputType = {
    id: string
    clientTaxId: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo: string | null
    tamanio: number | null
    fechaSubida: Date
    subidoPor: string | null
    _count: TaxFileCountAggregateOutputType | null
    _avg: TaxFileAvgAggregateOutputType | null
    _sum: TaxFileSumAggregateOutputType | null
    _min: TaxFileMinAggregateOutputType | null
    _max: TaxFileMaxAggregateOutputType | null
  }

  type GetTaxFileGroupByPayload<T extends taxFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxFileGroupByOutputType[P]>
            : GetScalarType<T[P], TaxFileGroupByOutputType[P]>
        }
      >
    >


  export type taxFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientTaxId?: boolean
    nombreArchivo?: boolean
    s3Url?: boolean
    s3Key?: boolean
    tipo?: boolean
    tamanio?: boolean
    fechaSubida?: boolean
    subidoPor?: boolean
    clientTax?: boolean | clientTaxDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxFile"]>



  export type taxFileSelectScalar = {
    id?: boolean
    clientTaxId?: boolean
    nombreArchivo?: boolean
    s3Url?: boolean
    s3Key?: boolean
    tipo?: boolean
    tamanio?: boolean
    fechaSubida?: boolean
    subidoPor?: boolean
  }

  export type taxFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientTaxId" | "nombreArchivo" | "s3Url" | "s3Key" | "tipo" | "tamanio" | "fechaSubida" | "subidoPor", ExtArgs["result"]["taxFile"]>
  export type taxFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientTax?: boolean | clientTaxDefaultArgs<ExtArgs>
  }

  export type $taxFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "taxFile"
    objects: {
      clientTax: Prisma.$clientTaxPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientTaxId: string
      nombreArchivo: string
      s3Url: string
      s3Key: string
      tipo: string | null
      tamanio: number | null
      fechaSubida: Date
      subidoPor: string | null
    }, ExtArgs["result"]["taxFile"]>
    composites: {}
  }

  type taxFileGetPayload<S extends boolean | null | undefined | taxFileDefaultArgs> = $Result.GetResult<Prisma.$taxFilePayload, S>

  type taxFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<taxFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxFileCountAggregateInputType | true
    }

  export interface taxFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['taxFile'], meta: { name: 'taxFile' } }
    /**
     * Find zero or one TaxFile that matches the filter.
     * @param {taxFileFindUniqueArgs} args - Arguments to find a TaxFile
     * @example
     * // Get one TaxFile
     * const taxFile = await prisma.taxFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends taxFileFindUniqueArgs>(args: SelectSubset<T, taxFileFindUniqueArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {taxFileFindUniqueOrThrowArgs} args - Arguments to find a TaxFile
     * @example
     * // Get one TaxFile
     * const taxFile = await prisma.taxFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends taxFileFindUniqueOrThrowArgs>(args: SelectSubset<T, taxFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileFindFirstArgs} args - Arguments to find a TaxFile
     * @example
     * // Get one TaxFile
     * const taxFile = await prisma.taxFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends taxFileFindFirstArgs>(args?: SelectSubset<T, taxFileFindFirstArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileFindFirstOrThrowArgs} args - Arguments to find a TaxFile
     * @example
     * // Get one TaxFile
     * const taxFile = await prisma.taxFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends taxFileFindFirstOrThrowArgs>(args?: SelectSubset<T, taxFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxFiles
     * const taxFiles = await prisma.taxFile.findMany()
     * 
     * // Get first 10 TaxFiles
     * const taxFiles = await prisma.taxFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxFileWithIdOnly = await prisma.taxFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends taxFileFindManyArgs>(args?: SelectSubset<T, taxFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxFile.
     * @param {taxFileCreateArgs} args - Arguments to create a TaxFile.
     * @example
     * // Create one TaxFile
     * const TaxFile = await prisma.taxFile.create({
     *   data: {
     *     // ... data to create a TaxFile
     *   }
     * })
     * 
     */
    create<T extends taxFileCreateArgs>(args: SelectSubset<T, taxFileCreateArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxFiles.
     * @param {taxFileCreateManyArgs} args - Arguments to create many TaxFiles.
     * @example
     * // Create many TaxFiles
     * const taxFile = await prisma.taxFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends taxFileCreateManyArgs>(args?: SelectSubset<T, taxFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaxFile.
     * @param {taxFileDeleteArgs} args - Arguments to delete one TaxFile.
     * @example
     * // Delete one TaxFile
     * const TaxFile = await prisma.taxFile.delete({
     *   where: {
     *     // ... filter to delete one TaxFile
     *   }
     * })
     * 
     */
    delete<T extends taxFileDeleteArgs>(args: SelectSubset<T, taxFileDeleteArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxFile.
     * @param {taxFileUpdateArgs} args - Arguments to update one TaxFile.
     * @example
     * // Update one TaxFile
     * const taxFile = await prisma.taxFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends taxFileUpdateArgs>(args: SelectSubset<T, taxFileUpdateArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxFiles.
     * @param {taxFileDeleteManyArgs} args - Arguments to filter TaxFiles to delete.
     * @example
     * // Delete a few TaxFiles
     * const { count } = await prisma.taxFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends taxFileDeleteManyArgs>(args?: SelectSubset<T, taxFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxFiles
     * const taxFile = await prisma.taxFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends taxFileUpdateManyArgs>(args: SelectSubset<T, taxFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaxFile.
     * @param {taxFileUpsertArgs} args - Arguments to update or create a TaxFile.
     * @example
     * // Update or create a TaxFile
     * const taxFile = await prisma.taxFile.upsert({
     *   create: {
     *     // ... data to create a TaxFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxFile we want to update
     *   }
     * })
     */
    upsert<T extends taxFileUpsertArgs>(args: SelectSubset<T, taxFileUpsertArgs<ExtArgs>>): Prisma__taxFileClient<$Result.GetResult<Prisma.$taxFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileCountArgs} args - Arguments to filter TaxFiles to count.
     * @example
     * // Count the number of TaxFiles
     * const count = await prisma.taxFile.count({
     *   where: {
     *     // ... the filter for the TaxFiles we want to count
     *   }
     * })
    **/
    count<T extends taxFileCountArgs>(
      args?: Subset<T, taxFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxFileAggregateArgs>(args: Subset<T, TaxFileAggregateArgs>): Prisma.PrismaPromise<GetTaxFileAggregateType<T>>

    /**
     * Group by TaxFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends taxFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: taxFileGroupByArgs['orderBy'] }
        : { orderBy?: taxFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, taxFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the taxFile model
   */
  readonly fields: taxFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for taxFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__taxFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientTax<T extends clientTaxDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientTaxDefaultArgs<ExtArgs>>): Prisma__clientTaxClient<$Result.GetResult<Prisma.$clientTaxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the taxFile model
   */
  interface taxFileFieldRefs {
    readonly id: FieldRef<"taxFile", 'String'>
    readonly clientTaxId: FieldRef<"taxFile", 'String'>
    readonly nombreArchivo: FieldRef<"taxFile", 'String'>
    readonly s3Url: FieldRef<"taxFile", 'String'>
    readonly s3Key: FieldRef<"taxFile", 'String'>
    readonly tipo: FieldRef<"taxFile", 'String'>
    readonly tamanio: FieldRef<"taxFile", 'Int'>
    readonly fechaSubida: FieldRef<"taxFile", 'DateTime'>
    readonly subidoPor: FieldRef<"taxFile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * taxFile findUnique
   */
  export type taxFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter, which taxFile to fetch.
     */
    where: taxFileWhereUniqueInput
  }

  /**
   * taxFile findUniqueOrThrow
   */
  export type taxFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter, which taxFile to fetch.
     */
    where: taxFileWhereUniqueInput
  }

  /**
   * taxFile findFirst
   */
  export type taxFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter, which taxFile to fetch.
     */
    where?: taxFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxFiles to fetch.
     */
    orderBy?: taxFileOrderByWithRelationInput | taxFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxFiles.
     */
    cursor?: taxFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxFiles.
     */
    distinct?: TaxFileScalarFieldEnum | TaxFileScalarFieldEnum[]
  }

  /**
   * taxFile findFirstOrThrow
   */
  export type taxFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter, which taxFile to fetch.
     */
    where?: taxFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxFiles to fetch.
     */
    orderBy?: taxFileOrderByWithRelationInput | taxFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxFiles.
     */
    cursor?: taxFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxFiles.
     */
    distinct?: TaxFileScalarFieldEnum | TaxFileScalarFieldEnum[]
  }

  /**
   * taxFile findMany
   */
  export type taxFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter, which taxFiles to fetch.
     */
    where?: taxFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxFiles to fetch.
     */
    orderBy?: taxFileOrderByWithRelationInput | taxFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taxFiles.
     */
    cursor?: taxFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxFiles.
     */
    skip?: number
    distinct?: TaxFileScalarFieldEnum | TaxFileScalarFieldEnum[]
  }

  /**
   * taxFile create
   */
  export type taxFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * The data needed to create a taxFile.
     */
    data: XOR<taxFileCreateInput, taxFileUncheckedCreateInput>
  }

  /**
   * taxFile createMany
   */
  export type taxFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many taxFiles.
     */
    data: taxFileCreateManyInput | taxFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * taxFile update
   */
  export type taxFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * The data needed to update a taxFile.
     */
    data: XOR<taxFileUpdateInput, taxFileUncheckedUpdateInput>
    /**
     * Choose, which taxFile to update.
     */
    where: taxFileWhereUniqueInput
  }

  /**
   * taxFile updateMany
   */
  export type taxFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update taxFiles.
     */
    data: XOR<taxFileUpdateManyMutationInput, taxFileUncheckedUpdateManyInput>
    /**
     * Filter which taxFiles to update
     */
    where?: taxFileWhereInput
    /**
     * Limit how many taxFiles to update.
     */
    limit?: number
  }

  /**
   * taxFile upsert
   */
  export type taxFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * The filter to search for the taxFile to update in case it exists.
     */
    where: taxFileWhereUniqueInput
    /**
     * In case the taxFile found by the `where` argument doesn't exist, create a new taxFile with this data.
     */
    create: XOR<taxFileCreateInput, taxFileUncheckedCreateInput>
    /**
     * In case the taxFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<taxFileUpdateInput, taxFileUncheckedUpdateInput>
  }

  /**
   * taxFile delete
   */
  export type taxFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
    /**
     * Filter which taxFile to delete.
     */
    where: taxFileWhereUniqueInput
  }

  /**
   * taxFile deleteMany
   */
  export type taxFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which taxFiles to delete
     */
    where?: taxFileWhereInput
    /**
     * Limit how many taxFiles to delete.
     */
    limit?: number
  }

  /**
   * taxFile without action
   */
  export type taxFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the taxFile
     */
    select?: taxFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the taxFile
     */
    omit?: taxFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: taxFileInclude<ExtArgs> | null
  }


  /**
   * Model clientTaxRequirement
   */

  export type AggregateClientTaxRequirement = {
    _count: ClientTaxRequirementCountAggregateOutputType | null
    _min: ClientTaxRequirementMinAggregateOutputType | null
    _max: ClientTaxRequirementMaxAggregateOutputType | null
  }

  export type ClientTaxRequirementMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    impuesto: string | null
    detalle: string | null
    taxModelCode: string | null
    required: boolean | null
    note: string | null
    colorTag: string | null
  }

  export type ClientTaxRequirementMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    impuesto: string | null
    detalle: string | null
    taxModelCode: string | null
    required: boolean | null
    note: string | null
    colorTag: string | null
  }

  export type ClientTaxRequirementCountAggregateOutputType = {
    id: number
    clientId: number
    impuesto: number
    detalle: number
    taxModelCode: number
    required: number
    note: number
    colorTag: number
    _all: number
  }


  export type ClientTaxRequirementMinAggregateInputType = {
    id?: true
    clientId?: true
    impuesto?: true
    detalle?: true
    taxModelCode?: true
    required?: true
    note?: true
    colorTag?: true
  }

  export type ClientTaxRequirementMaxAggregateInputType = {
    id?: true
    clientId?: true
    impuesto?: true
    detalle?: true
    taxModelCode?: true
    required?: true
    note?: true
    colorTag?: true
  }

  export type ClientTaxRequirementCountAggregateInputType = {
    id?: true
    clientId?: true
    impuesto?: true
    detalle?: true
    taxModelCode?: true
    required?: true
    note?: true
    colorTag?: true
    _all?: true
  }

  export type ClientTaxRequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTaxRequirement to aggregate.
     */
    where?: clientTaxRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxRequirements to fetch.
     */
    orderBy?: clientTaxRequirementOrderByWithRelationInput | clientTaxRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientTaxRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientTaxRequirements
    **/
    _count?: true | ClientTaxRequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientTaxRequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientTaxRequirementMaxAggregateInputType
  }

  export type GetClientTaxRequirementAggregateType<T extends ClientTaxRequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateClientTaxRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientTaxRequirement[P]>
      : GetScalarType<T[P], AggregateClientTaxRequirement[P]>
  }




  export type clientTaxRequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxRequirementWhereInput
    orderBy?: clientTaxRequirementOrderByWithAggregationInput | clientTaxRequirementOrderByWithAggregationInput[]
    by: ClientTaxRequirementScalarFieldEnum[] | ClientTaxRequirementScalarFieldEnum
    having?: clientTaxRequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientTaxRequirementCountAggregateInputType | true
    _min?: ClientTaxRequirementMinAggregateInputType
    _max?: ClientTaxRequirementMaxAggregateInputType
  }

  export type ClientTaxRequirementGroupByOutputType = {
    id: string
    clientId: string
    impuesto: string
    detalle: string | null
    taxModelCode: string | null
    required: boolean
    note: string | null
    colorTag: string | null
    _count: ClientTaxRequirementCountAggregateOutputType | null
    _min: ClientTaxRequirementMinAggregateOutputType | null
    _max: ClientTaxRequirementMaxAggregateOutputType | null
  }

  type GetClientTaxRequirementGroupByPayload<T extends clientTaxRequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientTaxRequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientTaxRequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientTaxRequirementGroupByOutputType[P]>
            : GetScalarType<T[P], ClientTaxRequirementGroupByOutputType[P]>
        }
      >
    >


  export type clientTaxRequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    impuesto?: boolean
    detalle?: boolean
    taxModelCode?: boolean
    required?: boolean
    note?: boolean
    colorTag?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientTaxRequirement"]>



  export type clientTaxRequirementSelectScalar = {
    id?: boolean
    clientId?: boolean
    impuesto?: boolean
    detalle?: boolean
    taxModelCode?: boolean
    required?: boolean
    note?: boolean
    colorTag?: boolean
  }

  export type clientTaxRequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "impuesto" | "detalle" | "taxModelCode" | "required" | "note" | "colorTag", ExtArgs["result"]["clientTaxRequirement"]>
  export type clientTaxRequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $clientTaxRequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientTaxRequirement"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      impuesto: string
      detalle: string | null
      taxModelCode: string | null
      required: boolean
      note: string | null
      colorTag: string | null
    }, ExtArgs["result"]["clientTaxRequirement"]>
    composites: {}
  }

  type clientTaxRequirementGetPayload<S extends boolean | null | undefined | clientTaxRequirementDefaultArgs> = $Result.GetResult<Prisma.$clientTaxRequirementPayload, S>

  type clientTaxRequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientTaxRequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientTaxRequirementCountAggregateInputType | true
    }

  export interface clientTaxRequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientTaxRequirement'], meta: { name: 'clientTaxRequirement' } }
    /**
     * Find zero or one ClientTaxRequirement that matches the filter.
     * @param {clientTaxRequirementFindUniqueArgs} args - Arguments to find a ClientTaxRequirement
     * @example
     * // Get one ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientTaxRequirementFindUniqueArgs>(args: SelectSubset<T, clientTaxRequirementFindUniqueArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientTaxRequirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientTaxRequirementFindUniqueOrThrowArgs} args - Arguments to find a ClientTaxRequirement
     * @example
     * // Get one ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientTaxRequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, clientTaxRequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTaxRequirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementFindFirstArgs} args - Arguments to find a ClientTaxRequirement
     * @example
     * // Get one ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientTaxRequirementFindFirstArgs>(args?: SelectSubset<T, clientTaxRequirementFindFirstArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTaxRequirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementFindFirstOrThrowArgs} args - Arguments to find a ClientTaxRequirement
     * @example
     * // Get one ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientTaxRequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, clientTaxRequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientTaxRequirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientTaxRequirements
     * const clientTaxRequirements = await prisma.clientTaxRequirement.findMany()
     * 
     * // Get first 10 ClientTaxRequirements
     * const clientTaxRequirements = await prisma.clientTaxRequirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientTaxRequirementWithIdOnly = await prisma.clientTaxRequirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientTaxRequirementFindManyArgs>(args?: SelectSubset<T, clientTaxRequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientTaxRequirement.
     * @param {clientTaxRequirementCreateArgs} args - Arguments to create a ClientTaxRequirement.
     * @example
     * // Create one ClientTaxRequirement
     * const ClientTaxRequirement = await prisma.clientTaxRequirement.create({
     *   data: {
     *     // ... data to create a ClientTaxRequirement
     *   }
     * })
     * 
     */
    create<T extends clientTaxRequirementCreateArgs>(args: SelectSubset<T, clientTaxRequirementCreateArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientTaxRequirements.
     * @param {clientTaxRequirementCreateManyArgs} args - Arguments to create many ClientTaxRequirements.
     * @example
     * // Create many ClientTaxRequirements
     * const clientTaxRequirement = await prisma.clientTaxRequirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientTaxRequirementCreateManyArgs>(args?: SelectSubset<T, clientTaxRequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientTaxRequirement.
     * @param {clientTaxRequirementDeleteArgs} args - Arguments to delete one ClientTaxRequirement.
     * @example
     * // Delete one ClientTaxRequirement
     * const ClientTaxRequirement = await prisma.clientTaxRequirement.delete({
     *   where: {
     *     // ... filter to delete one ClientTaxRequirement
     *   }
     * })
     * 
     */
    delete<T extends clientTaxRequirementDeleteArgs>(args: SelectSubset<T, clientTaxRequirementDeleteArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientTaxRequirement.
     * @param {clientTaxRequirementUpdateArgs} args - Arguments to update one ClientTaxRequirement.
     * @example
     * // Update one ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientTaxRequirementUpdateArgs>(args: SelectSubset<T, clientTaxRequirementUpdateArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientTaxRequirements.
     * @param {clientTaxRequirementDeleteManyArgs} args - Arguments to filter ClientTaxRequirements to delete.
     * @example
     * // Delete a few ClientTaxRequirements
     * const { count } = await prisma.clientTaxRequirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientTaxRequirementDeleteManyArgs>(args?: SelectSubset<T, clientTaxRequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTaxRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientTaxRequirements
     * const clientTaxRequirement = await prisma.clientTaxRequirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientTaxRequirementUpdateManyArgs>(args: SelectSubset<T, clientTaxRequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientTaxRequirement.
     * @param {clientTaxRequirementUpsertArgs} args - Arguments to update or create a ClientTaxRequirement.
     * @example
     * // Update or create a ClientTaxRequirement
     * const clientTaxRequirement = await prisma.clientTaxRequirement.upsert({
     *   create: {
     *     // ... data to create a ClientTaxRequirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientTaxRequirement we want to update
     *   }
     * })
     */
    upsert<T extends clientTaxRequirementUpsertArgs>(args: SelectSubset<T, clientTaxRequirementUpsertArgs<ExtArgs>>): Prisma__clientTaxRequirementClient<$Result.GetResult<Prisma.$clientTaxRequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientTaxRequirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementCountArgs} args - Arguments to filter ClientTaxRequirements to count.
     * @example
     * // Count the number of ClientTaxRequirements
     * const count = await prisma.clientTaxRequirement.count({
     *   where: {
     *     // ... the filter for the ClientTaxRequirements we want to count
     *   }
     * })
    **/
    count<T extends clientTaxRequirementCountArgs>(
      args?: Subset<T, clientTaxRequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientTaxRequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientTaxRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTaxRequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientTaxRequirementAggregateArgs>(args: Subset<T, ClientTaxRequirementAggregateArgs>): Prisma.PrismaPromise<GetClientTaxRequirementAggregateType<T>>

    /**
     * Group by ClientTaxRequirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxRequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientTaxRequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientTaxRequirementGroupByArgs['orderBy'] }
        : { orderBy?: clientTaxRequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientTaxRequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientTaxRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientTaxRequirement model
   */
  readonly fields: clientTaxRequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientTaxRequirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientTaxRequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientTaxRequirement model
   */
  interface clientTaxRequirementFieldRefs {
    readonly id: FieldRef<"clientTaxRequirement", 'String'>
    readonly clientId: FieldRef<"clientTaxRequirement", 'String'>
    readonly impuesto: FieldRef<"clientTaxRequirement", 'String'>
    readonly detalle: FieldRef<"clientTaxRequirement", 'String'>
    readonly taxModelCode: FieldRef<"clientTaxRequirement", 'String'>
    readonly required: FieldRef<"clientTaxRequirement", 'Boolean'>
    readonly note: FieldRef<"clientTaxRequirement", 'String'>
    readonly colorTag: FieldRef<"clientTaxRequirement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clientTaxRequirement findUnique
   */
  export type clientTaxRequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxRequirement to fetch.
     */
    where: clientTaxRequirementWhereUniqueInput
  }

  /**
   * clientTaxRequirement findUniqueOrThrow
   */
  export type clientTaxRequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxRequirement to fetch.
     */
    where: clientTaxRequirementWhereUniqueInput
  }

  /**
   * clientTaxRequirement findFirst
   */
  export type clientTaxRequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxRequirement to fetch.
     */
    where?: clientTaxRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxRequirements to fetch.
     */
    orderBy?: clientTaxRequirementOrderByWithRelationInput | clientTaxRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxRequirements.
     */
    cursor?: clientTaxRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxRequirements.
     */
    distinct?: ClientTaxRequirementScalarFieldEnum | ClientTaxRequirementScalarFieldEnum[]
  }

  /**
   * clientTaxRequirement findFirstOrThrow
   */
  export type clientTaxRequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxRequirement to fetch.
     */
    where?: clientTaxRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxRequirements to fetch.
     */
    orderBy?: clientTaxRequirementOrderByWithRelationInput | clientTaxRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxRequirements.
     */
    cursor?: clientTaxRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxRequirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxRequirements.
     */
    distinct?: ClientTaxRequirementScalarFieldEnum | ClientTaxRequirementScalarFieldEnum[]
  }

  /**
   * clientTaxRequirement findMany
   */
  export type clientTaxRequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxRequirements to fetch.
     */
    where?: clientTaxRequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxRequirements to fetch.
     */
    orderBy?: clientTaxRequirementOrderByWithRelationInput | clientTaxRequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientTaxRequirements.
     */
    cursor?: clientTaxRequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxRequirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxRequirements.
     */
    skip?: number
    distinct?: ClientTaxRequirementScalarFieldEnum | ClientTaxRequirementScalarFieldEnum[]
  }

  /**
   * clientTaxRequirement create
   */
  export type clientTaxRequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a clientTaxRequirement.
     */
    data: XOR<clientTaxRequirementCreateInput, clientTaxRequirementUncheckedCreateInput>
  }

  /**
   * clientTaxRequirement createMany
   */
  export type clientTaxRequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientTaxRequirements.
     */
    data: clientTaxRequirementCreateManyInput | clientTaxRequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientTaxRequirement update
   */
  export type clientTaxRequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a clientTaxRequirement.
     */
    data: XOR<clientTaxRequirementUpdateInput, clientTaxRequirementUncheckedUpdateInput>
    /**
     * Choose, which clientTaxRequirement to update.
     */
    where: clientTaxRequirementWhereUniqueInput
  }

  /**
   * clientTaxRequirement updateMany
   */
  export type clientTaxRequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientTaxRequirements.
     */
    data: XOR<clientTaxRequirementUpdateManyMutationInput, clientTaxRequirementUncheckedUpdateManyInput>
    /**
     * Filter which clientTaxRequirements to update
     */
    where?: clientTaxRequirementWhereInput
    /**
     * Limit how many clientTaxRequirements to update.
     */
    limit?: number
  }

  /**
   * clientTaxRequirement upsert
   */
  export type clientTaxRequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the clientTaxRequirement to update in case it exists.
     */
    where: clientTaxRequirementWhereUniqueInput
    /**
     * In case the clientTaxRequirement found by the `where` argument doesn't exist, create a new clientTaxRequirement with this data.
     */
    create: XOR<clientTaxRequirementCreateInput, clientTaxRequirementUncheckedCreateInput>
    /**
     * In case the clientTaxRequirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientTaxRequirementUpdateInput, clientTaxRequirementUncheckedUpdateInput>
  }

  /**
   * clientTaxRequirement delete
   */
  export type clientTaxRequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
    /**
     * Filter which clientTaxRequirement to delete.
     */
    where: clientTaxRequirementWhereUniqueInput
  }

  /**
   * clientTaxRequirement deleteMany
   */
  export type clientTaxRequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTaxRequirements to delete
     */
    where?: clientTaxRequirementWhereInput
    /**
     * Limit how many clientTaxRequirements to delete.
     */
    limit?: number
  }

  /**
   * clientTaxRequirement without action
   */
  export type clientTaxRequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxRequirement
     */
    select?: clientTaxRequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxRequirement
     */
    omit?: clientTaxRequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxRequirementInclude<ExtArgs> | null
  }


  /**
   * Model fiscalPeriod
   */

  export type AggregateFiscalPeriod = {
    _count: FiscalPeriodCountAggregateOutputType | null
    _avg: FiscalPeriodAvgAggregateOutputType | null
    _sum: FiscalPeriodSumAggregateOutputType | null
    _min: FiscalPeriodMinAggregateOutputType | null
    _max: FiscalPeriodMaxAggregateOutputType | null
  }

  export type FiscalPeriodAvgAggregateOutputType = {
    year: number | null
    quarter: number | null
  }

  export type FiscalPeriodSumAggregateOutputType = {
    year: number | null
    quarter: number | null
  }

  export type FiscalPeriodMinAggregateOutputType = {
    id: string | null
    year: number | null
    quarter: number | null
    label: string | null
    startsAt: Date | null
    endsAt: Date | null
  }

  export type FiscalPeriodMaxAggregateOutputType = {
    id: string | null
    year: number | null
    quarter: number | null
    label: string | null
    startsAt: Date | null
    endsAt: Date | null
  }

  export type FiscalPeriodCountAggregateOutputType = {
    id: number
    year: number
    quarter: number
    label: number
    startsAt: number
    endsAt: number
    _all: number
  }


  export type FiscalPeriodAvgAggregateInputType = {
    year?: true
    quarter?: true
  }

  export type FiscalPeriodSumAggregateInputType = {
    year?: true
    quarter?: true
  }

  export type FiscalPeriodMinAggregateInputType = {
    id?: true
    year?: true
    quarter?: true
    label?: true
    startsAt?: true
    endsAt?: true
  }

  export type FiscalPeriodMaxAggregateInputType = {
    id?: true
    year?: true
    quarter?: true
    label?: true
    startsAt?: true
    endsAt?: true
  }

  export type FiscalPeriodCountAggregateInputType = {
    id?: true
    year?: true
    quarter?: true
    label?: true
    startsAt?: true
    endsAt?: true
    _all?: true
  }

  export type FiscalPeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fiscalPeriod to aggregate.
     */
    where?: fiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fiscalPeriods to fetch.
     */
    orderBy?: fiscalPeriodOrderByWithRelationInput | fiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fiscalPeriods
    **/
    _count?: true | FiscalPeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiscalPeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiscalPeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiscalPeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiscalPeriodMaxAggregateInputType
  }

  export type GetFiscalPeriodAggregateType<T extends FiscalPeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateFiscalPeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiscalPeriod[P]>
      : GetScalarType<T[P], AggregateFiscalPeriod[P]>
  }




  export type fiscalPeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fiscalPeriodWhereInput
    orderBy?: fiscalPeriodOrderByWithAggregationInput | fiscalPeriodOrderByWithAggregationInput[]
    by: FiscalPeriodScalarFieldEnum[] | FiscalPeriodScalarFieldEnum
    having?: fiscalPeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiscalPeriodCountAggregateInputType | true
    _avg?: FiscalPeriodAvgAggregateInputType
    _sum?: FiscalPeriodSumAggregateInputType
    _min?: FiscalPeriodMinAggregateInputType
    _max?: FiscalPeriodMaxAggregateInputType
  }

  export type FiscalPeriodGroupByOutputType = {
    id: string
    year: number
    quarter: number
    label: string
    startsAt: Date
    endsAt: Date
    _count: FiscalPeriodCountAggregateOutputType | null
    _avg: FiscalPeriodAvgAggregateOutputType | null
    _sum: FiscalPeriodSumAggregateOutputType | null
    _min: FiscalPeriodMinAggregateOutputType | null
    _max: FiscalPeriodMaxAggregateOutputType | null
  }

  type GetFiscalPeriodGroupByPayload<T extends fiscalPeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FiscalPeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiscalPeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiscalPeriodGroupByOutputType[P]>
            : GetScalarType<T[P], FiscalPeriodGroupByOutputType[P]>
        }
      >
    >


  export type fiscalPeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    year?: boolean
    quarter?: boolean
    label?: boolean
    startsAt?: boolean
    endsAt?: boolean
    filings?: boolean | fiscalPeriod$filingsArgs<ExtArgs>
    _count?: boolean | FiscalPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fiscalPeriod"]>



  export type fiscalPeriodSelectScalar = {
    id?: boolean
    year?: boolean
    quarter?: boolean
    label?: boolean
    startsAt?: boolean
    endsAt?: boolean
  }

  export type fiscalPeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "year" | "quarter" | "label" | "startsAt" | "endsAt", ExtArgs["result"]["fiscalPeriod"]>
  export type fiscalPeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filings?: boolean | fiscalPeriod$filingsArgs<ExtArgs>
    _count?: boolean | FiscalPeriodCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $fiscalPeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fiscalPeriod"
    objects: {
      filings: Prisma.$clientTaxFilingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      year: number
      quarter: number
      label: string
      startsAt: Date
      endsAt: Date
    }, ExtArgs["result"]["fiscalPeriod"]>
    composites: {}
  }

  type fiscalPeriodGetPayload<S extends boolean | null | undefined | fiscalPeriodDefaultArgs> = $Result.GetResult<Prisma.$fiscalPeriodPayload, S>

  type fiscalPeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fiscalPeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FiscalPeriodCountAggregateInputType | true
    }

  export interface fiscalPeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fiscalPeriod'], meta: { name: 'fiscalPeriod' } }
    /**
     * Find zero or one FiscalPeriod that matches the filter.
     * @param {fiscalPeriodFindUniqueArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fiscalPeriodFindUniqueArgs>(args: SelectSubset<T, fiscalPeriodFindUniqueArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FiscalPeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fiscalPeriodFindUniqueOrThrowArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fiscalPeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, fiscalPeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalPeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodFindFirstArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fiscalPeriodFindFirstArgs>(args?: SelectSubset<T, fiscalPeriodFindFirstArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FiscalPeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodFindFirstOrThrowArgs} args - Arguments to find a FiscalPeriod
     * @example
     * // Get one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fiscalPeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, fiscalPeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FiscalPeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FiscalPeriods
     * const fiscalPeriods = await prisma.fiscalPeriod.findMany()
     * 
     * // Get first 10 FiscalPeriods
     * const fiscalPeriods = await prisma.fiscalPeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiscalPeriodWithIdOnly = await prisma.fiscalPeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fiscalPeriodFindManyArgs>(args?: SelectSubset<T, fiscalPeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FiscalPeriod.
     * @param {fiscalPeriodCreateArgs} args - Arguments to create a FiscalPeriod.
     * @example
     * // Create one FiscalPeriod
     * const FiscalPeriod = await prisma.fiscalPeriod.create({
     *   data: {
     *     // ... data to create a FiscalPeriod
     *   }
     * })
     * 
     */
    create<T extends fiscalPeriodCreateArgs>(args: SelectSubset<T, fiscalPeriodCreateArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FiscalPeriods.
     * @param {fiscalPeriodCreateManyArgs} args - Arguments to create many FiscalPeriods.
     * @example
     * // Create many FiscalPeriods
     * const fiscalPeriod = await prisma.fiscalPeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fiscalPeriodCreateManyArgs>(args?: SelectSubset<T, fiscalPeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FiscalPeriod.
     * @param {fiscalPeriodDeleteArgs} args - Arguments to delete one FiscalPeriod.
     * @example
     * // Delete one FiscalPeriod
     * const FiscalPeriod = await prisma.fiscalPeriod.delete({
     *   where: {
     *     // ... filter to delete one FiscalPeriod
     *   }
     * })
     * 
     */
    delete<T extends fiscalPeriodDeleteArgs>(args: SelectSubset<T, fiscalPeriodDeleteArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FiscalPeriod.
     * @param {fiscalPeriodUpdateArgs} args - Arguments to update one FiscalPeriod.
     * @example
     * // Update one FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fiscalPeriodUpdateArgs>(args: SelectSubset<T, fiscalPeriodUpdateArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FiscalPeriods.
     * @param {fiscalPeriodDeleteManyArgs} args - Arguments to filter FiscalPeriods to delete.
     * @example
     * // Delete a few FiscalPeriods
     * const { count } = await prisma.fiscalPeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fiscalPeriodDeleteManyArgs>(args?: SelectSubset<T, fiscalPeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FiscalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FiscalPeriods
     * const fiscalPeriod = await prisma.fiscalPeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fiscalPeriodUpdateManyArgs>(args: SelectSubset<T, fiscalPeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FiscalPeriod.
     * @param {fiscalPeriodUpsertArgs} args - Arguments to update or create a FiscalPeriod.
     * @example
     * // Update or create a FiscalPeriod
     * const fiscalPeriod = await prisma.fiscalPeriod.upsert({
     *   create: {
     *     // ... data to create a FiscalPeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FiscalPeriod we want to update
     *   }
     * })
     */
    upsert<T extends fiscalPeriodUpsertArgs>(args: SelectSubset<T, fiscalPeriodUpsertArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FiscalPeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodCountArgs} args - Arguments to filter FiscalPeriods to count.
     * @example
     * // Count the number of FiscalPeriods
     * const count = await prisma.fiscalPeriod.count({
     *   where: {
     *     // ... the filter for the FiscalPeriods we want to count
     *   }
     * })
    **/
    count<T extends fiscalPeriodCountArgs>(
      args?: Subset<T, fiscalPeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiscalPeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FiscalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiscalPeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiscalPeriodAggregateArgs>(args: Subset<T, FiscalPeriodAggregateArgs>): Prisma.PrismaPromise<GetFiscalPeriodAggregateType<T>>

    /**
     * Group by FiscalPeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fiscalPeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fiscalPeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fiscalPeriodGroupByArgs['orderBy'] }
        : { orderBy?: fiscalPeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fiscalPeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiscalPeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fiscalPeriod model
   */
  readonly fields: fiscalPeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fiscalPeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fiscalPeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filings<T extends fiscalPeriod$filingsArgs<ExtArgs> = {}>(args?: Subset<T, fiscalPeriod$filingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fiscalPeriod model
   */
  interface fiscalPeriodFieldRefs {
    readonly id: FieldRef<"fiscalPeriod", 'String'>
    readonly year: FieldRef<"fiscalPeriod", 'Int'>
    readonly quarter: FieldRef<"fiscalPeriod", 'Int'>
    readonly label: FieldRef<"fiscalPeriod", 'String'>
    readonly startsAt: FieldRef<"fiscalPeriod", 'DateTime'>
    readonly endsAt: FieldRef<"fiscalPeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * fiscalPeriod findUnique
   */
  export type fiscalPeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which fiscalPeriod to fetch.
     */
    where: fiscalPeriodWhereUniqueInput
  }

  /**
   * fiscalPeriod findUniqueOrThrow
   */
  export type fiscalPeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which fiscalPeriod to fetch.
     */
    where: fiscalPeriodWhereUniqueInput
  }

  /**
   * fiscalPeriod findFirst
   */
  export type fiscalPeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which fiscalPeriod to fetch.
     */
    where?: fiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fiscalPeriods to fetch.
     */
    orderBy?: fiscalPeriodOrderByWithRelationInput | fiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fiscalPeriods.
     */
    cursor?: fiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fiscalPeriods.
     */
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * fiscalPeriod findFirstOrThrow
   */
  export type fiscalPeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which fiscalPeriod to fetch.
     */
    where?: fiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fiscalPeriods to fetch.
     */
    orderBy?: fiscalPeriodOrderByWithRelationInput | fiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fiscalPeriods.
     */
    cursor?: fiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fiscalPeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fiscalPeriods.
     */
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * fiscalPeriod findMany
   */
  export type fiscalPeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter, which fiscalPeriods to fetch.
     */
    where?: fiscalPeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fiscalPeriods to fetch.
     */
    orderBy?: fiscalPeriodOrderByWithRelationInput | fiscalPeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fiscalPeriods.
     */
    cursor?: fiscalPeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fiscalPeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fiscalPeriods.
     */
    skip?: number
    distinct?: FiscalPeriodScalarFieldEnum | FiscalPeriodScalarFieldEnum[]
  }

  /**
   * fiscalPeriod create
   */
  export type fiscalPeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a fiscalPeriod.
     */
    data: XOR<fiscalPeriodCreateInput, fiscalPeriodUncheckedCreateInput>
  }

  /**
   * fiscalPeriod createMany
   */
  export type fiscalPeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fiscalPeriods.
     */
    data: fiscalPeriodCreateManyInput | fiscalPeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fiscalPeriod update
   */
  export type fiscalPeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a fiscalPeriod.
     */
    data: XOR<fiscalPeriodUpdateInput, fiscalPeriodUncheckedUpdateInput>
    /**
     * Choose, which fiscalPeriod to update.
     */
    where: fiscalPeriodWhereUniqueInput
  }

  /**
   * fiscalPeriod updateMany
   */
  export type fiscalPeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fiscalPeriods.
     */
    data: XOR<fiscalPeriodUpdateManyMutationInput, fiscalPeriodUncheckedUpdateManyInput>
    /**
     * Filter which fiscalPeriods to update
     */
    where?: fiscalPeriodWhereInput
    /**
     * Limit how many fiscalPeriods to update.
     */
    limit?: number
  }

  /**
   * fiscalPeriod upsert
   */
  export type fiscalPeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the fiscalPeriod to update in case it exists.
     */
    where: fiscalPeriodWhereUniqueInput
    /**
     * In case the fiscalPeriod found by the `where` argument doesn't exist, create a new fiscalPeriod with this data.
     */
    create: XOR<fiscalPeriodCreateInput, fiscalPeriodUncheckedCreateInput>
    /**
     * In case the fiscalPeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fiscalPeriodUpdateInput, fiscalPeriodUncheckedUpdateInput>
  }

  /**
   * fiscalPeriod delete
   */
  export type fiscalPeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    /**
     * Filter which fiscalPeriod to delete.
     */
    where: fiscalPeriodWhereUniqueInput
  }

  /**
   * fiscalPeriod deleteMany
   */
  export type fiscalPeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fiscalPeriods to delete
     */
    where?: fiscalPeriodWhereInput
    /**
     * Limit how many fiscalPeriods to delete.
     */
    limit?: number
  }

  /**
   * fiscalPeriod.filings
   */
  export type fiscalPeriod$filingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    where?: clientTaxFilingWhereInput
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    cursor?: clientTaxFilingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientTaxFilingScalarFieldEnum | ClientTaxFilingScalarFieldEnum[]
  }

  /**
   * fiscalPeriod without action
   */
  export type fiscalPeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
  }


  /**
   * Model clientTaxFiling
   */

  export type AggregateClientTaxFiling = {
    _count: ClientTaxFilingCountAggregateOutputType | null
    _min: ClientTaxFilingMinAggregateOutputType | null
    _max: ClientTaxFilingMaxAggregateOutputType | null
  }

  export type ClientTaxFilingMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    taxModelCode: string | null
    periodId: string | null
    status: string | null
    notes: string | null
    presentedAt: Date | null
  }

  export type ClientTaxFilingMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    taxModelCode: string | null
    periodId: string | null
    status: string | null
    notes: string | null
    presentedAt: Date | null
  }

  export type ClientTaxFilingCountAggregateOutputType = {
    id: number
    clientId: number
    taxModelCode: number
    periodId: number
    status: number
    notes: number
    presentedAt: number
    _all: number
  }


  export type ClientTaxFilingMinAggregateInputType = {
    id?: true
    clientId?: true
    taxModelCode?: true
    periodId?: true
    status?: true
    notes?: true
    presentedAt?: true
  }

  export type ClientTaxFilingMaxAggregateInputType = {
    id?: true
    clientId?: true
    taxModelCode?: true
    periodId?: true
    status?: true
    notes?: true
    presentedAt?: true
  }

  export type ClientTaxFilingCountAggregateInputType = {
    id?: true
    clientId?: true
    taxModelCode?: true
    periodId?: true
    status?: true
    notes?: true
    presentedAt?: true
    _all?: true
  }

  export type ClientTaxFilingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTaxFiling to aggregate.
     */
    where?: clientTaxFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxFilings to fetch.
     */
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientTaxFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientTaxFilings
    **/
    _count?: true | ClientTaxFilingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientTaxFilingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientTaxFilingMaxAggregateInputType
  }

  export type GetClientTaxFilingAggregateType<T extends ClientTaxFilingAggregateArgs> = {
        [P in keyof T & keyof AggregateClientTaxFiling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientTaxFiling[P]>
      : GetScalarType<T[P], AggregateClientTaxFiling[P]>
  }




  export type clientTaxFilingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientTaxFilingWhereInput
    orderBy?: clientTaxFilingOrderByWithAggregationInput | clientTaxFilingOrderByWithAggregationInput[]
    by: ClientTaxFilingScalarFieldEnum[] | ClientTaxFilingScalarFieldEnum
    having?: clientTaxFilingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientTaxFilingCountAggregateInputType | true
    _min?: ClientTaxFilingMinAggregateInputType
    _max?: ClientTaxFilingMaxAggregateInputType
  }

  export type ClientTaxFilingGroupByOutputType = {
    id: string
    clientId: string
    taxModelCode: string
    periodId: string
    status: string
    notes: string | null
    presentedAt: Date | null
    _count: ClientTaxFilingCountAggregateOutputType | null
    _min: ClientTaxFilingMinAggregateOutputType | null
    _max: ClientTaxFilingMaxAggregateOutputType | null
  }

  type GetClientTaxFilingGroupByPayload<T extends clientTaxFilingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientTaxFilingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientTaxFilingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientTaxFilingGroupByOutputType[P]>
            : GetScalarType<T[P], ClientTaxFilingGroupByOutputType[P]>
        }
      >
    >


  export type clientTaxFilingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    taxModelCode?: boolean
    periodId?: boolean
    status?: boolean
    notes?: boolean
    presentedAt?: boolean
    client?: boolean | clientTaxFiling$clientArgs<ExtArgs>
    period?: boolean | clientTaxFiling$periodArgs<ExtArgs>
  }, ExtArgs["result"]["clientTaxFiling"]>



  export type clientTaxFilingSelectScalar = {
    id?: boolean
    clientId?: boolean
    taxModelCode?: boolean
    periodId?: boolean
    status?: boolean
    notes?: boolean
    presentedAt?: boolean
  }

  export type clientTaxFilingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "taxModelCode" | "periodId" | "status" | "notes" | "presentedAt", ExtArgs["result"]["clientTaxFiling"]>
  export type clientTaxFilingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | clientTaxFiling$clientArgs<ExtArgs>
    period?: boolean | clientTaxFiling$periodArgs<ExtArgs>
  }

  export type $clientTaxFilingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clientTaxFiling"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      period: Prisma.$fiscalPeriodPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      taxModelCode: string
      periodId: string
      status: string
      notes: string | null
      presentedAt: Date | null
    }, ExtArgs["result"]["clientTaxFiling"]>
    composites: {}
  }

  type clientTaxFilingGetPayload<S extends boolean | null | undefined | clientTaxFilingDefaultArgs> = $Result.GetResult<Prisma.$clientTaxFilingPayload, S>

  type clientTaxFilingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientTaxFilingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientTaxFilingCountAggregateInputType | true
    }

  export interface clientTaxFilingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clientTaxFiling'], meta: { name: 'clientTaxFiling' } }
    /**
     * Find zero or one ClientTaxFiling that matches the filter.
     * @param {clientTaxFilingFindUniqueArgs} args - Arguments to find a ClientTaxFiling
     * @example
     * // Get one ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientTaxFilingFindUniqueArgs>(args: SelectSubset<T, clientTaxFilingFindUniqueArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientTaxFiling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientTaxFilingFindUniqueOrThrowArgs} args - Arguments to find a ClientTaxFiling
     * @example
     * // Get one ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientTaxFilingFindUniqueOrThrowArgs>(args: SelectSubset<T, clientTaxFilingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTaxFiling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingFindFirstArgs} args - Arguments to find a ClientTaxFiling
     * @example
     * // Get one ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientTaxFilingFindFirstArgs>(args?: SelectSubset<T, clientTaxFilingFindFirstArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientTaxFiling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingFindFirstOrThrowArgs} args - Arguments to find a ClientTaxFiling
     * @example
     * // Get one ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientTaxFilingFindFirstOrThrowArgs>(args?: SelectSubset<T, clientTaxFilingFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientTaxFilings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientTaxFilings
     * const clientTaxFilings = await prisma.clientTaxFiling.findMany()
     * 
     * // Get first 10 ClientTaxFilings
     * const clientTaxFilings = await prisma.clientTaxFiling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientTaxFilingWithIdOnly = await prisma.clientTaxFiling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientTaxFilingFindManyArgs>(args?: SelectSubset<T, clientTaxFilingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientTaxFiling.
     * @param {clientTaxFilingCreateArgs} args - Arguments to create a ClientTaxFiling.
     * @example
     * // Create one ClientTaxFiling
     * const ClientTaxFiling = await prisma.clientTaxFiling.create({
     *   data: {
     *     // ... data to create a ClientTaxFiling
     *   }
     * })
     * 
     */
    create<T extends clientTaxFilingCreateArgs>(args: SelectSubset<T, clientTaxFilingCreateArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientTaxFilings.
     * @param {clientTaxFilingCreateManyArgs} args - Arguments to create many ClientTaxFilings.
     * @example
     * // Create many ClientTaxFilings
     * const clientTaxFiling = await prisma.clientTaxFiling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientTaxFilingCreateManyArgs>(args?: SelectSubset<T, clientTaxFilingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ClientTaxFiling.
     * @param {clientTaxFilingDeleteArgs} args - Arguments to delete one ClientTaxFiling.
     * @example
     * // Delete one ClientTaxFiling
     * const ClientTaxFiling = await prisma.clientTaxFiling.delete({
     *   where: {
     *     // ... filter to delete one ClientTaxFiling
     *   }
     * })
     * 
     */
    delete<T extends clientTaxFilingDeleteArgs>(args: SelectSubset<T, clientTaxFilingDeleteArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientTaxFiling.
     * @param {clientTaxFilingUpdateArgs} args - Arguments to update one ClientTaxFiling.
     * @example
     * // Update one ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientTaxFilingUpdateArgs>(args: SelectSubset<T, clientTaxFilingUpdateArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientTaxFilings.
     * @param {clientTaxFilingDeleteManyArgs} args - Arguments to filter ClientTaxFilings to delete.
     * @example
     * // Delete a few ClientTaxFilings
     * const { count } = await prisma.clientTaxFiling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientTaxFilingDeleteManyArgs>(args?: SelectSubset<T, clientTaxFilingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientTaxFilings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientTaxFilings
     * const clientTaxFiling = await prisma.clientTaxFiling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientTaxFilingUpdateManyArgs>(args: SelectSubset<T, clientTaxFilingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClientTaxFiling.
     * @param {clientTaxFilingUpsertArgs} args - Arguments to update or create a ClientTaxFiling.
     * @example
     * // Update or create a ClientTaxFiling
     * const clientTaxFiling = await prisma.clientTaxFiling.upsert({
     *   create: {
     *     // ... data to create a ClientTaxFiling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientTaxFiling we want to update
     *   }
     * })
     */
    upsert<T extends clientTaxFilingUpsertArgs>(args: SelectSubset<T, clientTaxFilingUpsertArgs<ExtArgs>>): Prisma__clientTaxFilingClient<$Result.GetResult<Prisma.$clientTaxFilingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientTaxFilings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingCountArgs} args - Arguments to filter ClientTaxFilings to count.
     * @example
     * // Count the number of ClientTaxFilings
     * const count = await prisma.clientTaxFiling.count({
     *   where: {
     *     // ... the filter for the ClientTaxFilings we want to count
     *   }
     * })
    **/
    count<T extends clientTaxFilingCountArgs>(
      args?: Subset<T, clientTaxFilingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientTaxFilingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientTaxFiling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientTaxFilingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientTaxFilingAggregateArgs>(args: Subset<T, ClientTaxFilingAggregateArgs>): Prisma.PrismaPromise<GetClientTaxFilingAggregateType<T>>

    /**
     * Group by ClientTaxFiling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientTaxFilingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientTaxFilingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientTaxFilingGroupByArgs['orderBy'] }
        : { orderBy?: clientTaxFilingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientTaxFilingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientTaxFilingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clientTaxFiling model
   */
  readonly fields: clientTaxFilingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clientTaxFiling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientTaxFilingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends clientTaxFiling$clientArgs<ExtArgs> = {}>(args?: Subset<T, clientTaxFiling$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    period<T extends clientTaxFiling$periodArgs<ExtArgs> = {}>(args?: Subset<T, clientTaxFiling$periodArgs<ExtArgs>>): Prisma__fiscalPeriodClient<$Result.GetResult<Prisma.$fiscalPeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clientTaxFiling model
   */
  interface clientTaxFilingFieldRefs {
    readonly id: FieldRef<"clientTaxFiling", 'String'>
    readonly clientId: FieldRef<"clientTaxFiling", 'String'>
    readonly taxModelCode: FieldRef<"clientTaxFiling", 'String'>
    readonly periodId: FieldRef<"clientTaxFiling", 'String'>
    readonly status: FieldRef<"clientTaxFiling", 'String'>
    readonly notes: FieldRef<"clientTaxFiling", 'String'>
    readonly presentedAt: FieldRef<"clientTaxFiling", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * clientTaxFiling findUnique
   */
  export type clientTaxFilingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxFiling to fetch.
     */
    where: clientTaxFilingWhereUniqueInput
  }

  /**
   * clientTaxFiling findUniqueOrThrow
   */
  export type clientTaxFilingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxFiling to fetch.
     */
    where: clientTaxFilingWhereUniqueInput
  }

  /**
   * clientTaxFiling findFirst
   */
  export type clientTaxFilingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxFiling to fetch.
     */
    where?: clientTaxFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxFilings to fetch.
     */
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxFilings.
     */
    cursor?: clientTaxFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxFilings.
     */
    distinct?: ClientTaxFilingScalarFieldEnum | ClientTaxFilingScalarFieldEnum[]
  }

  /**
   * clientTaxFiling findFirstOrThrow
   */
  export type clientTaxFilingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxFiling to fetch.
     */
    where?: clientTaxFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxFilings to fetch.
     */
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientTaxFilings.
     */
    cursor?: clientTaxFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxFilings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientTaxFilings.
     */
    distinct?: ClientTaxFilingScalarFieldEnum | ClientTaxFilingScalarFieldEnum[]
  }

  /**
   * clientTaxFiling findMany
   */
  export type clientTaxFilingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter, which clientTaxFilings to fetch.
     */
    where?: clientTaxFilingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientTaxFilings to fetch.
     */
    orderBy?: clientTaxFilingOrderByWithRelationInput | clientTaxFilingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientTaxFilings.
     */
    cursor?: clientTaxFilingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientTaxFilings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientTaxFilings.
     */
    skip?: number
    distinct?: ClientTaxFilingScalarFieldEnum | ClientTaxFilingScalarFieldEnum[]
  }

  /**
   * clientTaxFiling create
   */
  export type clientTaxFilingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * The data needed to create a clientTaxFiling.
     */
    data: XOR<clientTaxFilingCreateInput, clientTaxFilingUncheckedCreateInput>
  }

  /**
   * clientTaxFiling createMany
   */
  export type clientTaxFilingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientTaxFilings.
     */
    data: clientTaxFilingCreateManyInput | clientTaxFilingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clientTaxFiling update
   */
  export type clientTaxFilingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * The data needed to update a clientTaxFiling.
     */
    data: XOR<clientTaxFilingUpdateInput, clientTaxFilingUncheckedUpdateInput>
    /**
     * Choose, which clientTaxFiling to update.
     */
    where: clientTaxFilingWhereUniqueInput
  }

  /**
   * clientTaxFiling updateMany
   */
  export type clientTaxFilingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientTaxFilings.
     */
    data: XOR<clientTaxFilingUpdateManyMutationInput, clientTaxFilingUncheckedUpdateManyInput>
    /**
     * Filter which clientTaxFilings to update
     */
    where?: clientTaxFilingWhereInput
    /**
     * Limit how many clientTaxFilings to update.
     */
    limit?: number
  }

  /**
   * clientTaxFiling upsert
   */
  export type clientTaxFilingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * The filter to search for the clientTaxFiling to update in case it exists.
     */
    where: clientTaxFilingWhereUniqueInput
    /**
     * In case the clientTaxFiling found by the `where` argument doesn't exist, create a new clientTaxFiling with this data.
     */
    create: XOR<clientTaxFilingCreateInput, clientTaxFilingUncheckedCreateInput>
    /**
     * In case the clientTaxFiling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientTaxFilingUpdateInput, clientTaxFilingUncheckedUpdateInput>
  }

  /**
   * clientTaxFiling delete
   */
  export type clientTaxFilingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
    /**
     * Filter which clientTaxFiling to delete.
     */
    where: clientTaxFilingWhereUniqueInput
  }

  /**
   * clientTaxFiling deleteMany
   */
  export type clientTaxFilingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientTaxFilings to delete
     */
    where?: clientTaxFilingWhereInput
    /**
     * Limit how many clientTaxFilings to delete.
     */
    limit?: number
  }

  /**
   * clientTaxFiling.client
   */
  export type clientTaxFiling$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * clientTaxFiling.period
   */
  export type clientTaxFiling$periodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fiscalPeriod
     */
    select?: fiscalPeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fiscalPeriod
     */
    omit?: fiscalPeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fiscalPeriodInclude<ExtArgs> | null
    where?: fiscalPeriodWhereInput
  }

  /**
   * clientTaxFiling without action
   */
  export type clientTaxFilingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clientTaxFiling
     */
    select?: clientTaxFilingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clientTaxFiling
     */
    omit?: clientTaxFilingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientTaxFilingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isSystem: 'isSystem',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    resource: 'resource',
    action: 'action',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const RolePermissionScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId',
    createdAt: 'createdAt'
  };

  export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    roleId: 'roleId',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    razonSocial: 'razonSocial',
    nifCif: 'nifCif',
    tipo: 'tipo',
    email: 'email',
    telefono: 'telefono',
    direccion: 'direccion',
    fechaAlta: 'fechaAlta',
    fechaBaja: 'fechaBaja',
    responsableAsignado: 'responsableAsignado',
    taxModels: 'taxModels',
    isActive: 'isActive'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const ClientEmployeeScalarFieldEnum: {
    clientId: 'clientId',
    userId: 'userId',
    isPrimary: 'isPrimary',
    assignedAt: 'assignedAt'
  };

  export type ClientEmployeeScalarFieldEnum = (typeof ClientEmployeeScalarFieldEnum)[keyof typeof ClientEmployeeScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    clienteId: 'clienteId',
    asignadoA: 'asignadoA',
    prioridad: 'prioridad',
    estado: 'estado',
    visibilidad: 'visibilidad',
    fechaVencimiento: 'fechaVencimiento',
    fechaCreacion: 'fechaCreacion',
    fechaActualizacion: 'fechaActualizacion'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const ManualScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    contenidoHtml: 'contenidoHtml',
    autorId: 'autorId',
    etiquetas: 'etiquetas',
    categoria: 'categoria',
    status: 'status',
    fechaCreacion: 'fechaCreacion',
    fechaActualizacion: 'fechaActualizacion',
    fechaPublicacion: 'fechaPublicacion'
  };

  export type ManualScalarFieldEnum = (typeof ManualScalarFieldEnum)[keyof typeof ManualScalarFieldEnum]


  export const ManualAttachmentScalarFieldEnum: {
    id: 'id',
    manualId: 'manualId',
    fileName: 'fileName',
    originalName: 'originalName',
    filePath: 'filePath',
    fileType: 'fileType',
    fileSize: 'fileSize',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt'
  };

  export type ManualAttachmentScalarFieldEnum = (typeof ManualAttachmentScalarFieldEnum)[keyof typeof ManualAttachmentScalarFieldEnum]


  export const ManualVersionScalarFieldEnum: {
    id: 'id',
    manualId: 'manualId',
    versionNumber: 'versionNumber',
    titulo: 'titulo',
    contenidoHtml: 'contenidoHtml',
    etiquetas: 'etiquetas',
    categoria: 'categoria',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type ManualVersionScalarFieldEnum = (typeof ManualVersionScalarFieldEnum)[keyof typeof ManualVersionScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    accion: 'accion',
    modulo: 'modulo',
    detalles: 'detalles',
    fecha: 'fecha'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const AuditTrailScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    accion: 'accion',
    tabla: 'tabla',
    registroId: 'registroId',
    valorAnterior: 'valorAnterior',
    valorNuevo: 'valorNuevo',
    cambios: 'cambios',
    requestId: 'requestId',
    fecha: 'fecha'
  };

  export type AuditTrailScalarFieldEnum = (typeof AuditTrailScalarFieldEnum)[keyof typeof AuditTrailScalarFieldEnum]


  export const SmtpConfigScalarFieldEnum: {
    id: 'id',
    host: 'host',
    port: 'port',
    user: 'user',
    password: 'password',
    secure: 'secure'
  };

  export type SmtpConfigScalarFieldEnum = (typeof SmtpConfigScalarFieldEnum)[keyof typeof SmtpConfigScalarFieldEnum]


  export const JobRunScalarFieldEnum: {
    id: 'id',
    jobName: 'jobName',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    recordsProcessed: 'recordsProcessed',
    errorMessage: 'errorMessage',
    metadata: 'metadata'
  };

  export type JobRunScalarFieldEnum = (typeof JobRunScalarFieldEnum)[keyof typeof JobRunScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    registrationEnabled: 'registrationEnabled',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const SMTPAccountScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    host: 'host',
    port: 'port',
    user: 'user',
    password: 'password',
    isPredeterminada: 'isPredeterminada',
    activa: 'activa',
    creadaPor: 'creadaPor',
    fechaCreacion: 'fechaCreacion'
  };

  export type SMTPAccountScalarFieldEnum = (typeof SMTPAccountScalarFieldEnum)[keyof typeof SMTPAccountScalarFieldEnum]


  export const NotificationTemplateScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    asunto: 'asunto',
    contenidoHTML: 'contenidoHTML',
    variables: 'variables',
    tipo: 'tipo',
    activa: 'activa',
    creadoPor: 'creadoPor',
    fechaCreacion: 'fechaCreacion',
    fechaActualizacion: 'fechaActualizacion'
  };

  export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


  export const NotificationLogScalarFieldEnum: {
    id: 'id',
    plantillaId: 'plantillaId',
    smtpAccountId: 'smtpAccountId',
    destinatarios: 'destinatarios',
    asunto: 'asunto',
    contenido: 'contenido',
    tipo: 'tipo',
    estado: 'estado',
    fechaEnvio: 'fechaEnvio',
    enviadoPor: 'enviadoPor',
    metadata: 'metadata'
  };

  export type NotificationLogScalarFieldEnum = (typeof NotificationLogScalarFieldEnum)[keyof typeof NotificationLogScalarFieldEnum]


  export const ScheduledNotificationScalarFieldEnum: {
    id: 'id',
    plantillaId: 'plantillaId',
    smtpAccountId: 'smtpAccountId',
    destinatariosSeleccionados: 'destinatariosSeleccionados',
    fechaProgramada: 'fechaProgramada',
    estado: 'estado',
    recurrencia: 'recurrencia',
    creadoPor: 'creadoPor',
    fechaCreacion: 'fechaCreacion'
  };

  export type ScheduledNotificationScalarFieldEnum = (typeof ScheduledNotificationScalarFieldEnum)[keyof typeof ScheduledNotificationScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    isEditable: 'isEditable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const SystemBackupScalarFieldEnum: {
    id: 'id',
    version: 'version',
    dbFile: 'dbFile',
    filesFile: 'filesFile',
    dbSize: 'dbSize',
    filesSize: 'filesSize',
    status: 'status',
    errorMessage: 'errorMessage',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type SystemBackupScalarFieldEnum = (typeof SystemBackupScalarFieldEnum)[keyof typeof SystemBackupScalarFieldEnum]


  export const SystemUpdateScalarFieldEnum: {
    id: 'id',
    fromVersion: 'fromVersion',
    toVersion: 'toVersion',
    status: 'status',
    logs: 'logs',
    backupId: 'backupId',
    errorMessage: 'errorMessage',
    initiatedBy: 'initiatedBy',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type SystemUpdateScalarFieldEnum = (typeof SystemUpdateScalarFieldEnum)[keyof typeof SystemUpdateScalarFieldEnum]


  export const StorageConfigScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    host: 'host',
    port: 'port',
    username: 'username',
    encryptedPassword: 'encryptedPassword',
    basePath: 'basePath',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageConfigScalarFieldEnum = (typeof StorageConfigScalarFieldEnum)[keyof typeof StorageConfigScalarFieldEnum]


  export const ImpuestoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    modelo: 'modelo',
    descripcion: 'descripcion',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ImpuestoScalarFieldEnum = (typeof ImpuestoScalarFieldEnum)[keyof typeof ImpuestoScalarFieldEnum]


  export const ObligacionFiscalScalarFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    impuestoId: 'impuestoId',
    periodicidad: 'periodicidad',
    diaVencimiento: 'diaVencimiento',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    observaciones: 'observaciones',
    fechaAsignacion: 'fechaAsignacion',
    activo: 'activo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ObligacionFiscalScalarFieldEnum = (typeof ObligacionFiscalScalarFieldEnum)[keyof typeof ObligacionFiscalScalarFieldEnum]


  export const CalendarioAEATScalarFieldEnum: {
    id: 'id',
    modelo: 'modelo',
    periodicidad: 'periodicidad',
    periodoContable: 'periodoContable',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CalendarioAEATScalarFieldEnum = (typeof CalendarioAEATScalarFieldEnum)[keyof typeof CalendarioAEATScalarFieldEnum]


  export const DeclaracionScalarFieldEnum: {
    id: 'id',
    obligacionId: 'obligacionId',
    calendarioId: 'calendarioId',
    estado: 'estado',
    fechaPresentacion: 'fechaPresentacion',
    archivoPdf: 'archivoPdf',
    notas: 'notas',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeclaracionScalarFieldEnum = (typeof DeclaracionScalarFieldEnum)[keyof typeof DeclaracionScalarFieldEnum]


  export const NotificacionScalarFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    periodo: 'periodo',
    tipo: 'tipo',
    fechaEnvio: 'fechaEnvio',
    enviada: 'enviada',
    asunto: 'asunto',
    mensaje: 'mensaje',
    createdAt: 'createdAt'
  };

  export type NotificacionScalarFieldEnum = (typeof NotificacionScalarFieldEnum)[keyof typeof NotificacionScalarFieldEnum]


  export const TaxModelScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type TaxModelScalarFieldEnum = (typeof TaxModelScalarFieldEnum)[keyof typeof TaxModelScalarFieldEnum]


  export const TaxPeriodScalarFieldEnum: {
    id: 'id',
    modeloId: 'modeloId',
    anio: 'anio',
    trimestre: 'trimestre',
    mes: 'mes',
    inicioPresentacion: 'inicioPresentacion',
    finPresentacion: 'finPresentacion'
  };

  export type TaxPeriodScalarFieldEnum = (typeof TaxPeriodScalarFieldEnum)[keyof typeof TaxPeriodScalarFieldEnum]


  export const ClientTaxScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    taxPeriodId: 'taxPeriodId',
    estado: 'estado',
    notas: 'notas',
    displayText: 'displayText',
    colorTag: 'colorTag',
    fechaCreacion: 'fechaCreacion',
    fechaActualizacion: 'fechaActualizacion'
  };

  export type ClientTaxScalarFieldEnum = (typeof ClientTaxScalarFieldEnum)[keyof typeof ClientTaxScalarFieldEnum]


  export const TaxFileScalarFieldEnum: {
    id: 'id',
    clientTaxId: 'clientTaxId',
    nombreArchivo: 'nombreArchivo',
    s3Url: 's3Url',
    s3Key: 's3Key',
    tipo: 'tipo',
    tamanio: 'tamanio',
    fechaSubida: 'fechaSubida',
    subidoPor: 'subidoPor'
  };

  export type TaxFileScalarFieldEnum = (typeof TaxFileScalarFieldEnum)[keyof typeof TaxFileScalarFieldEnum]


  export const ClientTaxRequirementScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    impuesto: 'impuesto',
    detalle: 'detalle',
    taxModelCode: 'taxModelCode',
    required: 'required',
    note: 'note',
    colorTag: 'colorTag'
  };

  export type ClientTaxRequirementScalarFieldEnum = (typeof ClientTaxRequirementScalarFieldEnum)[keyof typeof ClientTaxRequirementScalarFieldEnum]


  export const FiscalPeriodScalarFieldEnum: {
    id: 'id',
    year: 'year',
    quarter: 'quarter',
    label: 'label',
    startsAt: 'startsAt',
    endsAt: 'endsAt'
  };

  export type FiscalPeriodScalarFieldEnum = (typeof FiscalPeriodScalarFieldEnum)[keyof typeof FiscalPeriodScalarFieldEnum]


  export const ClientTaxFilingScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    taxModelCode: 'taxModelCode',
    periodId: 'periodId',
    status: 'status',
    notes: 'notes',
    presentedAt: 'presentedAt'
  };

  export type ClientTaxFilingScalarFieldEnum = (typeof ClientTaxFilingScalarFieldEnum)[keyof typeof ClientTaxFilingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const RoleOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type RoleOrderByRelevanceFieldEnum = (typeof RoleOrderByRelevanceFieldEnum)[keyof typeof RoleOrderByRelevanceFieldEnum]


  export const PermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    resource: 'resource',
    action: 'action',
    description: 'description'
  };

  export type PermissionOrderByRelevanceFieldEnum = (typeof PermissionOrderByRelevanceFieldEnum)[keyof typeof PermissionOrderByRelevanceFieldEnum]


  export const RolePermissionOrderByRelevanceFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    permissionId: 'permissionId'
  };

  export type RolePermissionOrderByRelevanceFieldEnum = (typeof RolePermissionOrderByRelevanceFieldEnum)[keyof typeof RolePermissionOrderByRelevanceFieldEnum]


  export const UserOrderByRelevanceFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    roleId: 'roleId'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const ClientOrderByRelevanceFieldEnum: {
    id: 'id',
    razonSocial: 'razonSocial',
    nifCif: 'nifCif',
    email: 'email',
    telefono: 'telefono',
    direccion: 'direccion',
    responsableAsignado: 'responsableAsignado'
  };

  export type ClientOrderByRelevanceFieldEnum = (typeof ClientOrderByRelevanceFieldEnum)[keyof typeof ClientOrderByRelevanceFieldEnum]


  export const ClientEmployeeOrderByRelevanceFieldEnum: {
    clientId: 'clientId',
    userId: 'userId'
  };

  export type ClientEmployeeOrderByRelevanceFieldEnum = (typeof ClientEmployeeOrderByRelevanceFieldEnum)[keyof typeof ClientEmployeeOrderByRelevanceFieldEnum]


  export const TaskOrderByRelevanceFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descripcion: 'descripcion',
    clienteId: 'clienteId',
    asignadoA: 'asignadoA'
  };

  export type TaskOrderByRelevanceFieldEnum = (typeof TaskOrderByRelevanceFieldEnum)[keyof typeof TaskOrderByRelevanceFieldEnum]


  export const ManualOrderByRelevanceFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    contenidoHtml: 'contenidoHtml',
    autorId: 'autorId',
    etiquetas: 'etiquetas',
    categoria: 'categoria'
  };

  export type ManualOrderByRelevanceFieldEnum = (typeof ManualOrderByRelevanceFieldEnum)[keyof typeof ManualOrderByRelevanceFieldEnum]


  export const ManualAttachmentOrderByRelevanceFieldEnum: {
    id: 'id',
    manualId: 'manualId',
    fileName: 'fileName',
    originalName: 'originalName',
    filePath: 'filePath',
    fileType: 'fileType',
    uploadedBy: 'uploadedBy'
  };

  export type ManualAttachmentOrderByRelevanceFieldEnum = (typeof ManualAttachmentOrderByRelevanceFieldEnum)[keyof typeof ManualAttachmentOrderByRelevanceFieldEnum]


  export const ManualVersionOrderByRelevanceFieldEnum: {
    id: 'id',
    manualId: 'manualId',
    titulo: 'titulo',
    contenidoHtml: 'contenidoHtml',
    etiquetas: 'etiquetas',
    categoria: 'categoria',
    createdBy: 'createdBy'
  };

  export type ManualVersionOrderByRelevanceFieldEnum = (typeof ManualVersionOrderByRelevanceFieldEnum)[keyof typeof ManualVersionOrderByRelevanceFieldEnum]


  export const ActivityLogOrderByRelevanceFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    accion: 'accion',
    modulo: 'modulo',
    detalles: 'detalles'
  };

  export type ActivityLogOrderByRelevanceFieldEnum = (typeof ActivityLogOrderByRelevanceFieldEnum)[keyof typeof ActivityLogOrderByRelevanceFieldEnum]


  export const AuditTrailOrderByRelevanceFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    tabla: 'tabla',
    registroId: 'registroId',
    valorAnterior: 'valorAnterior',
    valorNuevo: 'valorNuevo',
    cambios: 'cambios',
    requestId: 'requestId'
  };

  export type AuditTrailOrderByRelevanceFieldEnum = (typeof AuditTrailOrderByRelevanceFieldEnum)[keyof typeof AuditTrailOrderByRelevanceFieldEnum]


  export const SmtpConfigOrderByRelevanceFieldEnum: {
    id: 'id',
    host: 'host',
    user: 'user',
    password: 'password'
  };

  export type SmtpConfigOrderByRelevanceFieldEnum = (typeof SmtpConfigOrderByRelevanceFieldEnum)[keyof typeof SmtpConfigOrderByRelevanceFieldEnum]


  export const JobRunOrderByRelevanceFieldEnum: {
    id: 'id',
    jobName: 'jobName',
    status: 'status',
    errorMessage: 'errorMessage',
    metadata: 'metadata'
  };

  export type JobRunOrderByRelevanceFieldEnum = (typeof JobRunOrderByRelevanceFieldEnum)[keyof typeof JobRunOrderByRelevanceFieldEnum]


  export const SystemSettingsOrderByRelevanceFieldEnum: {
    id: 'id'
  };

  export type SystemSettingsOrderByRelevanceFieldEnum = (typeof SystemSettingsOrderByRelevanceFieldEnum)[keyof typeof SystemSettingsOrderByRelevanceFieldEnum]


  export const SMTPAccountOrderByRelevanceFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    host: 'host',
    user: 'user',
    password: 'password',
    creadaPor: 'creadaPor'
  };

  export type SMTPAccountOrderByRelevanceFieldEnum = (typeof SMTPAccountOrderByRelevanceFieldEnum)[keyof typeof SMTPAccountOrderByRelevanceFieldEnum]


  export const NotificationTemplateOrderByRelevanceFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    asunto: 'asunto',
    contenidoHTML: 'contenidoHTML',
    tipo: 'tipo',
    creadoPor: 'creadoPor'
  };

  export type NotificationTemplateOrderByRelevanceFieldEnum = (typeof NotificationTemplateOrderByRelevanceFieldEnum)[keyof typeof NotificationTemplateOrderByRelevanceFieldEnum]


  export const NotificationLogOrderByRelevanceFieldEnum: {
    id: 'id',
    plantillaId: 'plantillaId',
    smtpAccountId: 'smtpAccountId',
    asunto: 'asunto',
    contenido: 'contenido',
    tipo: 'tipo',
    estado: 'estado',
    enviadoPor: 'enviadoPor'
  };

  export type NotificationLogOrderByRelevanceFieldEnum = (typeof NotificationLogOrderByRelevanceFieldEnum)[keyof typeof NotificationLogOrderByRelevanceFieldEnum]


  export const ScheduledNotificationOrderByRelevanceFieldEnum: {
    id: 'id',
    plantillaId: 'plantillaId',
    smtpAccountId: 'smtpAccountId',
    estado: 'estado',
    recurrencia: 'recurrencia',
    creadoPor: 'creadoPor'
  };

  export type ScheduledNotificationOrderByRelevanceFieldEnum = (typeof ScheduledNotificationOrderByRelevanceFieldEnum)[keyof typeof ScheduledNotificationOrderByRelevanceFieldEnum]


  export const SystemConfigOrderByRelevanceFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description'
  };

  export type SystemConfigOrderByRelevanceFieldEnum = (typeof SystemConfigOrderByRelevanceFieldEnum)[keyof typeof SystemConfigOrderByRelevanceFieldEnum]


  export const SystemBackupOrderByRelevanceFieldEnum: {
    id: 'id',
    version: 'version',
    dbFile: 'dbFile',
    filesFile: 'filesFile',
    errorMessage: 'errorMessage',
    createdBy: 'createdBy'
  };

  export type SystemBackupOrderByRelevanceFieldEnum = (typeof SystemBackupOrderByRelevanceFieldEnum)[keyof typeof SystemBackupOrderByRelevanceFieldEnum]


  export const SystemUpdateOrderByRelevanceFieldEnum: {
    id: 'id',
    fromVersion: 'fromVersion',
    toVersion: 'toVersion',
    backupId: 'backupId',
    errorMessage: 'errorMessage',
    initiatedBy: 'initiatedBy'
  };

  export type SystemUpdateOrderByRelevanceFieldEnum = (typeof SystemUpdateOrderByRelevanceFieldEnum)[keyof typeof SystemUpdateOrderByRelevanceFieldEnum]


  export const StorageConfigOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    host: 'host',
    username: 'username',
    encryptedPassword: 'encryptedPassword',
    basePath: 'basePath'
  };

  export type StorageConfigOrderByRelevanceFieldEnum = (typeof StorageConfigOrderByRelevanceFieldEnum)[keyof typeof StorageConfigOrderByRelevanceFieldEnum]


  export const ImpuestoOrderByRelevanceFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    modelo: 'modelo',
    descripcion: 'descripcion'
  };

  export type ImpuestoOrderByRelevanceFieldEnum = (typeof ImpuestoOrderByRelevanceFieldEnum)[keyof typeof ImpuestoOrderByRelevanceFieldEnum]


  export const ObligacionFiscalOrderByRelevanceFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    impuestoId: 'impuestoId',
    observaciones: 'observaciones'
  };

  export type ObligacionFiscalOrderByRelevanceFieldEnum = (typeof ObligacionFiscalOrderByRelevanceFieldEnum)[keyof typeof ObligacionFiscalOrderByRelevanceFieldEnum]


  export const CalendarioAEATOrderByRelevanceFieldEnum: {
    id: 'id',
    modelo: 'modelo',
    periodoContable: 'periodoContable'
  };

  export type CalendarioAEATOrderByRelevanceFieldEnum = (typeof CalendarioAEATOrderByRelevanceFieldEnum)[keyof typeof CalendarioAEATOrderByRelevanceFieldEnum]


  export const DeclaracionOrderByRelevanceFieldEnum: {
    id: 'id',
    obligacionId: 'obligacionId',
    calendarioId: 'calendarioId',
    archivoPdf: 'archivoPdf',
    notas: 'notas'
  };

  export type DeclaracionOrderByRelevanceFieldEnum = (typeof DeclaracionOrderByRelevanceFieldEnum)[keyof typeof DeclaracionOrderByRelevanceFieldEnum]


  export const NotificacionOrderByRelevanceFieldEnum: {
    id: 'id',
    clienteId: 'clienteId',
    periodo: 'periodo',
    asunto: 'asunto',
    mensaje: 'mensaje'
  };

  export type NotificacionOrderByRelevanceFieldEnum = (typeof NotificacionOrderByRelevanceFieldEnum)[keyof typeof NotificacionOrderByRelevanceFieldEnum]


  export const taxModelOrderByRelevanceFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type taxModelOrderByRelevanceFieldEnum = (typeof taxModelOrderByRelevanceFieldEnum)[keyof typeof taxModelOrderByRelevanceFieldEnum]


  export const taxPeriodOrderByRelevanceFieldEnum: {
    id: 'id',
    modeloId: 'modeloId'
  };

  export type taxPeriodOrderByRelevanceFieldEnum = (typeof taxPeriodOrderByRelevanceFieldEnum)[keyof typeof taxPeriodOrderByRelevanceFieldEnum]


  export const clientTaxOrderByRelevanceFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    taxPeriodId: 'taxPeriodId',
    estado: 'estado',
    notas: 'notas',
    displayText: 'displayText',
    colorTag: 'colorTag'
  };

  export type clientTaxOrderByRelevanceFieldEnum = (typeof clientTaxOrderByRelevanceFieldEnum)[keyof typeof clientTaxOrderByRelevanceFieldEnum]


  export const taxFileOrderByRelevanceFieldEnum: {
    id: 'id',
    clientTaxId: 'clientTaxId',
    nombreArchivo: 'nombreArchivo',
    s3Url: 's3Url',
    s3Key: 's3Key',
    tipo: 'tipo',
    subidoPor: 'subidoPor'
  };

  export type taxFileOrderByRelevanceFieldEnum = (typeof taxFileOrderByRelevanceFieldEnum)[keyof typeof taxFileOrderByRelevanceFieldEnum]


  export const clientTaxRequirementOrderByRelevanceFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    impuesto: 'impuesto',
    detalle: 'detalle',
    taxModelCode: 'taxModelCode',
    note: 'note',
    colorTag: 'colorTag'
  };

  export type clientTaxRequirementOrderByRelevanceFieldEnum = (typeof clientTaxRequirementOrderByRelevanceFieldEnum)[keyof typeof clientTaxRequirementOrderByRelevanceFieldEnum]


  export const fiscalPeriodOrderByRelevanceFieldEnum: {
    id: 'id',
    label: 'label'
  };

  export type fiscalPeriodOrderByRelevanceFieldEnum = (typeof fiscalPeriodOrderByRelevanceFieldEnum)[keyof typeof fiscalPeriodOrderByRelevanceFieldEnum]


  export const clientTaxFilingOrderByRelevanceFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    taxModelCode: 'taxModelCode',
    periodId: 'periodId',
    status: 'status',
    notes: 'notes'
  };

  export type clientTaxFilingOrderByRelevanceFieldEnum = (typeof clientTaxFilingOrderByRelevanceFieldEnum)[keyof typeof clientTaxFilingOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TaskPriority'
   */
  export type EnumTaskPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskPriority'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskVisibility'
   */
  export type EnumTaskVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskVisibility'>
    


  /**
   * Reference to a field of type 'ManualStatus'
   */
  export type EnumManualStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ManualStatus'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BackupStatus'
   */
  export type EnumBackupStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BackupStatus'>
    


  /**
   * Reference to a field of type 'UpdateStatus'
   */
  export type EnumUpdateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UpdateStatus'>
    


  /**
   * Reference to a field of type 'StorageType'
   */
  export type EnumStorageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StorageType'>
    


  /**
   * Reference to a field of type 'Periodicidad'
   */
  export type EnumPeriodicidadFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Periodicidad'>
    


  /**
   * Reference to a field of type 'EstadoDeclaracion'
   */
  export type EnumEstadoDeclaracionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDeclaracion'>
    


  /**
   * Reference to a field of type 'TipoNotificacion'
   */
  export type EnumTipoNotificacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoNotificacion'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    permissions?: RolePermissionOrderByRelationAggregateInput
    _relevance?: RoleOrderByRelevanceInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    isSystem?: BoolFilter<"Role"> | boolean
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
    permissions?: RolePermissionListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Role"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    id?: StringFilter<"Permission"> | string
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    roles?: RolePermissionOrderByRelationAggregateInput
    _relevance?: PermissionOrderByRelevanceInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    resource_action?: PermissionResourceActionCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    resource?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    createdAt?: DateTimeFilter<"Permission"> | Date | string
    roles?: RolePermissionListRelationFilter
  }, "id" | "resource_action">

  export type PermissionOrderByWithAggregationInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permission"> | string
    resource?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Permission"> | Date | string
  }

  export type RolePermissionWhereInput = {
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }

  export type RolePermissionOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    permission?: PermissionOrderByWithRelationInput
    _relevance?: RolePermissionOrderByRelevanceInput
  }

  export type RolePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roleId_permissionId?: RolePermissionRoleIdPermissionIdCompoundUniqueInput
    AND?: RolePermissionWhereInput | RolePermissionWhereInput[]
    OR?: RolePermissionWhereInput[]
    NOT?: RolePermissionWhereInput | RolePermissionWhereInput[]
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    permission?: XOR<PermissionScalarRelationFilter, PermissionWhereInput>
  }, "id" | "roleId_permissionId">

  export type RolePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
    _count?: RolePermissionCountOrderByAggregateInput
    _max?: RolePermissionMaxOrderByAggregateInput
    _min?: RolePermissionMinOrderByAggregateInput
  }

  export type RolePermissionScalarWhereWithAggregatesInput = {
    AND?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    OR?: RolePermissionScalarWhereWithAggregatesInput[]
    NOT?: RolePermissionScalarWhereWithAggregatesInput | RolePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RolePermission"> | string
    roleId?: StringWithAggregatesFilter<"RolePermission"> | string
    permissionId?: StringWithAggregatesFilter<"RolePermission"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RolePermission"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    clientsManaged?: ClientListRelationFilter
    clientsAssigned?: ClientEmployeeListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    manualsAuthored?: ManualListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    smtpAccountsCreated?: SMTPAccountListRelationFilter
    notificationTemplatesCreated?: NotificationTemplateListRelationFilter
    notificationsSent?: NotificationLogListRelationFilter
    scheduledNotificationsCreated?: ScheduledNotificationListRelationFilter
    backupsCreated?: SystemBackupListRelationFilter
    updatesInitiated?: SystemUpdateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    clientsManaged?: ClientOrderByRelationAggregateInput
    clientsAssigned?: ClientEmployeeOrderByRelationAggregateInput
    tasksAssigned?: TaskOrderByRelationAggregateInput
    manualsAuthored?: ManualOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    auditTrails?: AuditTrailOrderByRelationAggregateInput
    smtpAccountsCreated?: SMTPAccountOrderByRelationAggregateInput
    notificationTemplatesCreated?: NotificationTemplateOrderByRelationAggregateInput
    notificationsSent?: NotificationLogOrderByRelationAggregateInput
    scheduledNotificationsCreated?: ScheduledNotificationOrderByRelationAggregateInput
    backupsCreated?: SystemBackupOrderByRelationAggregateInput
    updatesInitiated?: SystemUpdateOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    roleId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleNullableScalarRelationFilter, RoleWhereInput> | null
    clientsManaged?: ClientListRelationFilter
    clientsAssigned?: ClientEmployeeListRelationFilter
    tasksAssigned?: TaskListRelationFilter
    manualsAuthored?: ManualListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    smtpAccountsCreated?: SMTPAccountListRelationFilter
    notificationTemplatesCreated?: NotificationTemplateListRelationFilter
    notificationsSent?: NotificationLogListRelationFilter
    scheduledNotificationsCreated?: ScheduledNotificationListRelationFilter
    backupsCreated?: SystemBackupListRelationFilter
    updatesInitiated?: SystemUpdateListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    roleId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    razonSocial?: StringFilter<"Client"> | string
    nifCif?: StringFilter<"Client"> | string
    tipo?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    email?: StringNullableFilter<"Client"> | string | null
    telefono?: StringNullableFilter<"Client"> | string | null
    direccion?: StringNullableFilter<"Client"> | string | null
    fechaAlta?: DateTimeFilter<"Client"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Client"> | Date | string | null
    responsableAsignado?: StringNullableFilter<"Client"> | string | null
    taxModels?: JsonNullableFilter<"Client">
    isActive?: BoolFilter<"Client"> | boolean
    responsable?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    employees?: ClientEmployeeListRelationFilter
    clientTaxes?: ClientTaxListRelationFilter
    clientTaxRequirements?: ClientTaxRequirementListRelationFilter
    taxFilings?: ClientTaxFilingListRelationFilter
    obligacionesFiscales?: ObligacionFiscalListRelationFilter
    notificaciones?: NotificacionListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    razonSocial?: SortOrder
    nifCif?: SortOrder
    tipo?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fechaAlta?: SortOrder
    fechaBaja?: SortOrderInput | SortOrder
    responsableAsignado?: SortOrderInput | SortOrder
    taxModels?: SortOrderInput | SortOrder
    isActive?: SortOrder
    responsable?: UserOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    employees?: ClientEmployeeOrderByRelationAggregateInput
    clientTaxes?: clientTaxOrderByRelationAggregateInput
    clientTaxRequirements?: clientTaxRequirementOrderByRelationAggregateInput
    taxFilings?: clientTaxFilingOrderByRelationAggregateInput
    obligacionesFiscales?: ObligacionFiscalOrderByRelationAggregateInput
    notificaciones?: NotificacionOrderByRelationAggregateInput
    _relevance?: ClientOrderByRelevanceInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nifCif?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    razonSocial?: StringFilter<"Client"> | string
    tipo?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    email?: StringNullableFilter<"Client"> | string | null
    telefono?: StringNullableFilter<"Client"> | string | null
    direccion?: StringNullableFilter<"Client"> | string | null
    fechaAlta?: DateTimeFilter<"Client"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Client"> | Date | string | null
    responsableAsignado?: StringNullableFilter<"Client"> | string | null
    taxModels?: JsonNullableFilter<"Client">
    isActive?: BoolFilter<"Client"> | boolean
    responsable?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    tasks?: TaskListRelationFilter
    employees?: ClientEmployeeListRelationFilter
    clientTaxes?: ClientTaxListRelationFilter
    clientTaxRequirements?: ClientTaxRequirementListRelationFilter
    taxFilings?: ClientTaxFilingListRelationFilter
    obligacionesFiscales?: ObligacionFiscalListRelationFilter
    notificaciones?: NotificacionListRelationFilter
  }, "id" | "nifCif">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    razonSocial?: SortOrder
    nifCif?: SortOrder
    tipo?: SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    fechaAlta?: SortOrder
    fechaBaja?: SortOrderInput | SortOrder
    responsableAsignado?: SortOrderInput | SortOrder
    taxModels?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    razonSocial?: StringWithAggregatesFilter<"Client"> | string
    nifCif?: StringWithAggregatesFilter<"Client"> | string
    tipo?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Client"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Client"> | string | null
    fechaAlta?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    fechaBaja?: DateTimeNullableWithAggregatesFilter<"Client"> | Date | string | null
    responsableAsignado?: StringNullableWithAggregatesFilter<"Client"> | string | null
    taxModels?: JsonNullableWithAggregatesFilter<"Client">
    isActive?: BoolWithAggregatesFilter<"Client"> | boolean
  }

  export type ClientEmployeeWhereInput = {
    AND?: ClientEmployeeWhereInput | ClientEmployeeWhereInput[]
    OR?: ClientEmployeeWhereInput[]
    NOT?: ClientEmployeeWhereInput | ClientEmployeeWhereInput[]
    clientId?: StringFilter<"ClientEmployee"> | string
    userId?: StringFilter<"ClientEmployee"> | string
    isPrimary?: BoolFilter<"ClientEmployee"> | boolean
    assignedAt?: DateTimeFilter<"ClientEmployee"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClientEmployeeOrderByWithRelationInput = {
    clientId?: SortOrder
    userId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    _relevance?: ClientEmployeeOrderByRelevanceInput
  }

  export type ClientEmployeeWhereUniqueInput = Prisma.AtLeast<{
    clientId_userId?: ClientEmployeeClientIdUserIdCompoundUniqueInput
    AND?: ClientEmployeeWhereInput | ClientEmployeeWhereInput[]
    OR?: ClientEmployeeWhereInput[]
    NOT?: ClientEmployeeWhereInput | ClientEmployeeWhereInput[]
    clientId?: StringFilter<"ClientEmployee"> | string
    userId?: StringFilter<"ClientEmployee"> | string
    isPrimary?: BoolFilter<"ClientEmployee"> | boolean
    assignedAt?: DateTimeFilter<"ClientEmployee"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "clientId_userId">

  export type ClientEmployeeOrderByWithAggregationInput = {
    clientId?: SortOrder
    userId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
    _count?: ClientEmployeeCountOrderByAggregateInput
    _max?: ClientEmployeeMaxOrderByAggregateInput
    _min?: ClientEmployeeMinOrderByAggregateInput
  }

  export type ClientEmployeeScalarWhereWithAggregatesInput = {
    AND?: ClientEmployeeScalarWhereWithAggregatesInput | ClientEmployeeScalarWhereWithAggregatesInput[]
    OR?: ClientEmployeeScalarWhereWithAggregatesInput[]
    NOT?: ClientEmployeeScalarWhereWithAggregatesInput | ClientEmployeeScalarWhereWithAggregatesInput[]
    clientId?: StringWithAggregatesFilter<"ClientEmployee"> | string
    userId?: StringWithAggregatesFilter<"ClientEmployee"> | string
    isPrimary?: BoolWithAggregatesFilter<"ClientEmployee"> | boolean
    assignedAt?: DateTimeWithAggregatesFilter<"ClientEmployee"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    titulo?: StringFilter<"Task"> | string
    descripcion?: StringNullableFilter<"Task"> | string | null
    clienteId?: StringNullableFilter<"Task"> | string | null
    asignadoA?: StringNullableFilter<"Task"> | string | null
    prioridad?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    estado?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFilter<"Task"> | $Enums.TaskVisibility
    fechaVencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    fechaCreacion?: DateTimeFilter<"Task"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Task"> | Date | string
    cliente?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    asignado?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    asignadoA?: SortOrderInput | SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    visibilidad?: SortOrder
    fechaVencimiento?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    cliente?: ClientOrderByWithRelationInput
    asignado?: UserOrderByWithRelationInput
    _relevance?: TaskOrderByRelevanceInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    titulo?: StringFilter<"Task"> | string
    descripcion?: StringNullableFilter<"Task"> | string | null
    clienteId?: StringNullableFilter<"Task"> | string | null
    asignadoA?: StringNullableFilter<"Task"> | string | null
    prioridad?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    estado?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFilter<"Task"> | $Enums.TaskVisibility
    fechaVencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    fechaCreacion?: DateTimeFilter<"Task"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Task"> | Date | string
    cliente?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    asignado?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    clienteId?: SortOrderInput | SortOrder
    asignadoA?: SortOrderInput | SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    visibilidad?: SortOrder
    fechaVencimiento?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    titulo?: StringWithAggregatesFilter<"Task"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Task"> | string | null
    clienteId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    asignadoA?: StringNullableWithAggregatesFilter<"Task"> | string | null
    prioridad?: EnumTaskPriorityWithAggregatesFilter<"Task"> | $Enums.TaskPriority
    estado?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityWithAggregatesFilter<"Task"> | $Enums.TaskVisibility
    fechaVencimiento?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    fechaActualizacion?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type ManualWhereInput = {
    AND?: ManualWhereInput | ManualWhereInput[]
    OR?: ManualWhereInput[]
    NOT?: ManualWhereInput | ManualWhereInput[]
    id?: StringFilter<"Manual"> | string
    titulo?: StringFilter<"Manual"> | string
    contenidoHtml?: StringFilter<"Manual"> | string
    autorId?: StringFilter<"Manual"> | string
    etiquetas?: StringNullableFilter<"Manual"> | string | null
    categoria?: StringNullableFilter<"Manual"> | string | null
    status?: EnumManualStatusFilter<"Manual"> | $Enums.ManualStatus
    fechaCreacion?: DateTimeFilter<"Manual"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Manual"> | Date | string
    fechaPublicacion?: DateTimeNullableFilter<"Manual"> | Date | string | null
    autor?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: ManualAttachmentListRelationFilter
    versions?: ManualVersionListRelationFilter
  }

  export type ManualOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    autorId?: SortOrder
    etiquetas?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    status?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    fechaPublicacion?: SortOrderInput | SortOrder
    autor?: UserOrderByWithRelationInput
    attachments?: ManualAttachmentOrderByRelationAggregateInput
    versions?: ManualVersionOrderByRelationAggregateInput
    _relevance?: ManualOrderByRelevanceInput
  }

  export type ManualWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManualWhereInput | ManualWhereInput[]
    OR?: ManualWhereInput[]
    NOT?: ManualWhereInput | ManualWhereInput[]
    titulo?: StringFilter<"Manual"> | string
    contenidoHtml?: StringFilter<"Manual"> | string
    autorId?: StringFilter<"Manual"> | string
    etiquetas?: StringNullableFilter<"Manual"> | string | null
    categoria?: StringNullableFilter<"Manual"> | string | null
    status?: EnumManualStatusFilter<"Manual"> | $Enums.ManualStatus
    fechaCreacion?: DateTimeFilter<"Manual"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Manual"> | Date | string
    fechaPublicacion?: DateTimeNullableFilter<"Manual"> | Date | string | null
    autor?: XOR<UserScalarRelationFilter, UserWhereInput>
    attachments?: ManualAttachmentListRelationFilter
    versions?: ManualVersionListRelationFilter
  }, "id">

  export type ManualOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    autorId?: SortOrder
    etiquetas?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    status?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    fechaPublicacion?: SortOrderInput | SortOrder
    _count?: ManualCountOrderByAggregateInput
    _max?: ManualMaxOrderByAggregateInput
    _min?: ManualMinOrderByAggregateInput
  }

  export type ManualScalarWhereWithAggregatesInput = {
    AND?: ManualScalarWhereWithAggregatesInput | ManualScalarWhereWithAggregatesInput[]
    OR?: ManualScalarWhereWithAggregatesInput[]
    NOT?: ManualScalarWhereWithAggregatesInput | ManualScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Manual"> | string
    titulo?: StringWithAggregatesFilter<"Manual"> | string
    contenidoHtml?: StringWithAggregatesFilter<"Manual"> | string
    autorId?: StringWithAggregatesFilter<"Manual"> | string
    etiquetas?: StringNullableWithAggregatesFilter<"Manual"> | string | null
    categoria?: StringNullableWithAggregatesFilter<"Manual"> | string | null
    status?: EnumManualStatusWithAggregatesFilter<"Manual"> | $Enums.ManualStatus
    fechaCreacion?: DateTimeWithAggregatesFilter<"Manual"> | Date | string
    fechaActualizacion?: DateTimeWithAggregatesFilter<"Manual"> | Date | string
    fechaPublicacion?: DateTimeNullableWithAggregatesFilter<"Manual"> | Date | string | null
  }

  export type ManualAttachmentWhereInput = {
    AND?: ManualAttachmentWhereInput | ManualAttachmentWhereInput[]
    OR?: ManualAttachmentWhereInput[]
    NOT?: ManualAttachmentWhereInput | ManualAttachmentWhereInput[]
    id?: StringFilter<"ManualAttachment"> | string
    manualId?: StringFilter<"ManualAttachment"> | string
    fileName?: StringFilter<"ManualAttachment"> | string
    originalName?: StringFilter<"ManualAttachment"> | string
    filePath?: StringFilter<"ManualAttachment"> | string
    fileType?: StringFilter<"ManualAttachment"> | string
    fileSize?: IntFilter<"ManualAttachment"> | number
    uploadedBy?: StringFilter<"ManualAttachment"> | string
    uploadedAt?: DateTimeFilter<"ManualAttachment"> | Date | string
    manual?: XOR<ManualScalarRelationFilter, ManualWhereInput>
  }

  export type ManualAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    manualId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    manual?: ManualOrderByWithRelationInput
    _relevance?: ManualAttachmentOrderByRelevanceInput
  }

  export type ManualAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ManualAttachmentWhereInput | ManualAttachmentWhereInput[]
    OR?: ManualAttachmentWhereInput[]
    NOT?: ManualAttachmentWhereInput | ManualAttachmentWhereInput[]
    manualId?: StringFilter<"ManualAttachment"> | string
    fileName?: StringFilter<"ManualAttachment"> | string
    originalName?: StringFilter<"ManualAttachment"> | string
    filePath?: StringFilter<"ManualAttachment"> | string
    fileType?: StringFilter<"ManualAttachment"> | string
    fileSize?: IntFilter<"ManualAttachment"> | number
    uploadedBy?: StringFilter<"ManualAttachment"> | string
    uploadedAt?: DateTimeFilter<"ManualAttachment"> | Date | string
    manual?: XOR<ManualScalarRelationFilter, ManualWhereInput>
  }, "id">

  export type ManualAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    manualId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
    _count?: ManualAttachmentCountOrderByAggregateInput
    _avg?: ManualAttachmentAvgOrderByAggregateInput
    _max?: ManualAttachmentMaxOrderByAggregateInput
    _min?: ManualAttachmentMinOrderByAggregateInput
    _sum?: ManualAttachmentSumOrderByAggregateInput
  }

  export type ManualAttachmentScalarWhereWithAggregatesInput = {
    AND?: ManualAttachmentScalarWhereWithAggregatesInput | ManualAttachmentScalarWhereWithAggregatesInput[]
    OR?: ManualAttachmentScalarWhereWithAggregatesInput[]
    NOT?: ManualAttachmentScalarWhereWithAggregatesInput | ManualAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualAttachment"> | string
    manualId?: StringWithAggregatesFilter<"ManualAttachment"> | string
    fileName?: StringWithAggregatesFilter<"ManualAttachment"> | string
    originalName?: StringWithAggregatesFilter<"ManualAttachment"> | string
    filePath?: StringWithAggregatesFilter<"ManualAttachment"> | string
    fileType?: StringWithAggregatesFilter<"ManualAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"ManualAttachment"> | number
    uploadedBy?: StringWithAggregatesFilter<"ManualAttachment"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"ManualAttachment"> | Date | string
  }

  export type ManualVersionWhereInput = {
    AND?: ManualVersionWhereInput | ManualVersionWhereInput[]
    OR?: ManualVersionWhereInput[]
    NOT?: ManualVersionWhereInput | ManualVersionWhereInput[]
    id?: StringFilter<"ManualVersion"> | string
    manualId?: StringFilter<"ManualVersion"> | string
    versionNumber?: IntFilter<"ManualVersion"> | number
    titulo?: StringFilter<"ManualVersion"> | string
    contenidoHtml?: StringFilter<"ManualVersion"> | string
    etiquetas?: StringNullableFilter<"ManualVersion"> | string | null
    categoria?: StringNullableFilter<"ManualVersion"> | string | null
    createdBy?: StringFilter<"ManualVersion"> | string
    createdAt?: DateTimeFilter<"ManualVersion"> | Date | string
    manual?: XOR<ManualScalarRelationFilter, ManualWhereInput>
  }

  export type ManualVersionOrderByWithRelationInput = {
    id?: SortOrder
    manualId?: SortOrder
    versionNumber?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    etiquetas?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    manual?: ManualOrderByWithRelationInput
    _relevance?: ManualVersionOrderByRelevanceInput
  }

  export type ManualVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    manualId_versionNumber?: ManualVersionManualIdVersionNumberCompoundUniqueInput
    AND?: ManualVersionWhereInput | ManualVersionWhereInput[]
    OR?: ManualVersionWhereInput[]
    NOT?: ManualVersionWhereInput | ManualVersionWhereInput[]
    manualId?: StringFilter<"ManualVersion"> | string
    versionNumber?: IntFilter<"ManualVersion"> | number
    titulo?: StringFilter<"ManualVersion"> | string
    contenidoHtml?: StringFilter<"ManualVersion"> | string
    etiquetas?: StringNullableFilter<"ManualVersion"> | string | null
    categoria?: StringNullableFilter<"ManualVersion"> | string | null
    createdBy?: StringFilter<"ManualVersion"> | string
    createdAt?: DateTimeFilter<"ManualVersion"> | Date | string
    manual?: XOR<ManualScalarRelationFilter, ManualWhereInput>
  }, "id" | "manualId_versionNumber">

  export type ManualVersionOrderByWithAggregationInput = {
    id?: SortOrder
    manualId?: SortOrder
    versionNumber?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    etiquetas?: SortOrderInput | SortOrder
    categoria?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: ManualVersionCountOrderByAggregateInput
    _avg?: ManualVersionAvgOrderByAggregateInput
    _max?: ManualVersionMaxOrderByAggregateInput
    _min?: ManualVersionMinOrderByAggregateInput
    _sum?: ManualVersionSumOrderByAggregateInput
  }

  export type ManualVersionScalarWhereWithAggregatesInput = {
    AND?: ManualVersionScalarWhereWithAggregatesInput | ManualVersionScalarWhereWithAggregatesInput[]
    OR?: ManualVersionScalarWhereWithAggregatesInput[]
    NOT?: ManualVersionScalarWhereWithAggregatesInput | ManualVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ManualVersion"> | string
    manualId?: StringWithAggregatesFilter<"ManualVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"ManualVersion"> | number
    titulo?: StringWithAggregatesFilter<"ManualVersion"> | string
    contenidoHtml?: StringWithAggregatesFilter<"ManualVersion"> | string
    etiquetas?: StringNullableWithAggregatesFilter<"ManualVersion"> | string | null
    categoria?: StringNullableWithAggregatesFilter<"ManualVersion"> | string | null
    createdBy?: StringWithAggregatesFilter<"ManualVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ManualVersion"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    usuarioId?: StringFilter<"ActivityLog"> | string
    accion?: StringFilter<"ActivityLog"> | string
    modulo?: StringFilter<"ActivityLog"> | string
    detalles?: StringNullableFilter<"ActivityLog"> | string | null
    fecha?: DateTimeFilter<"ActivityLog"> | Date | string
    usuario?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    modulo?: SortOrder
    detalles?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuario?: UserOrderByWithRelationInput
    _relevance?: ActivityLogOrderByRelevanceInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    usuarioId?: StringFilter<"ActivityLog"> | string
    accion?: StringFilter<"ActivityLog"> | string
    modulo?: StringFilter<"ActivityLog"> | string
    detalles?: StringNullableFilter<"ActivityLog"> | string | null
    fecha?: DateTimeFilter<"ActivityLog"> | Date | string
    usuario?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    modulo?: SortOrder
    detalles?: SortOrderInput | SortOrder
    fecha?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    usuarioId?: StringWithAggregatesFilter<"ActivityLog"> | string
    accion?: StringWithAggregatesFilter<"ActivityLog"> | string
    modulo?: StringWithAggregatesFilter<"ActivityLog"> | string
    detalles?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    fecha?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type AuditTrailWhereInput = {
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    usuarioId?: StringFilter<"AuditTrail"> | string
    accion?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    tabla?: StringFilter<"AuditTrail"> | string
    registroId?: StringFilter<"AuditTrail"> | string
    valorAnterior?: StringNullableFilter<"AuditTrail"> | string | null
    valorNuevo?: StringNullableFilter<"AuditTrail"> | string | null
    cambios?: StringNullableFilter<"AuditTrail"> | string | null
    requestId?: StringNullableFilter<"AuditTrail"> | string | null
    fecha?: DateTimeFilter<"AuditTrail"> | Date | string
    usuario?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditTrailOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    valorAnterior?: SortOrderInput | SortOrder
    valorNuevo?: SortOrderInput | SortOrder
    cambios?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    fecha?: SortOrder
    usuario?: UserOrderByWithRelationInput
    _relevance?: AuditTrailOrderByRelevanceInput
  }

  export type AuditTrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    usuarioId?: StringFilter<"AuditTrail"> | string
    accion?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    tabla?: StringFilter<"AuditTrail"> | string
    registroId?: StringFilter<"AuditTrail"> | string
    valorAnterior?: StringNullableFilter<"AuditTrail"> | string | null
    valorNuevo?: StringNullableFilter<"AuditTrail"> | string | null
    cambios?: StringNullableFilter<"AuditTrail"> | string | null
    requestId?: StringNullableFilter<"AuditTrail"> | string | null
    fecha?: DateTimeFilter<"AuditTrail"> | Date | string
    usuario?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    valorAnterior?: SortOrderInput | SortOrder
    valorNuevo?: SortOrderInput | SortOrder
    cambios?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    fecha?: SortOrder
    _count?: AuditTrailCountOrderByAggregateInput
    _max?: AuditTrailMaxOrderByAggregateInput
    _min?: AuditTrailMinOrderByAggregateInput
  }

  export type AuditTrailScalarWhereWithAggregatesInput = {
    AND?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    OR?: AuditTrailScalarWhereWithAggregatesInput[]
    NOT?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditTrail"> | string
    usuarioId?: StringWithAggregatesFilter<"AuditTrail"> | string
    accion?: EnumAuditActionWithAggregatesFilter<"AuditTrail"> | $Enums.AuditAction
    tabla?: StringWithAggregatesFilter<"AuditTrail"> | string
    registroId?: StringWithAggregatesFilter<"AuditTrail"> | string
    valorAnterior?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    valorNuevo?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    cambios?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    requestId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    fecha?: DateTimeWithAggregatesFilter<"AuditTrail"> | Date | string
  }

  export type SmtpConfigWhereInput = {
    AND?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    OR?: SmtpConfigWhereInput[]
    NOT?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    id?: StringFilter<"SmtpConfig"> | string
    host?: StringFilter<"SmtpConfig"> | string
    port?: IntFilter<"SmtpConfig"> | number
    user?: StringFilter<"SmtpConfig"> | string
    password?: StringFilter<"SmtpConfig"> | string
    secure?: BoolFilter<"SmtpConfig"> | boolean
  }

  export type SmtpConfigOrderByWithRelationInput = {
    id?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    secure?: SortOrder
    _relevance?: SmtpConfigOrderByRelevanceInput
  }

  export type SmtpConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    OR?: SmtpConfigWhereInput[]
    NOT?: SmtpConfigWhereInput | SmtpConfigWhereInput[]
    host?: StringFilter<"SmtpConfig"> | string
    port?: IntFilter<"SmtpConfig"> | number
    user?: StringFilter<"SmtpConfig"> | string
    password?: StringFilter<"SmtpConfig"> | string
    secure?: BoolFilter<"SmtpConfig"> | boolean
  }, "id">

  export type SmtpConfigOrderByWithAggregationInput = {
    id?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    secure?: SortOrder
    _count?: SmtpConfigCountOrderByAggregateInput
    _avg?: SmtpConfigAvgOrderByAggregateInput
    _max?: SmtpConfigMaxOrderByAggregateInput
    _min?: SmtpConfigMinOrderByAggregateInput
    _sum?: SmtpConfigSumOrderByAggregateInput
  }

  export type SmtpConfigScalarWhereWithAggregatesInput = {
    AND?: SmtpConfigScalarWhereWithAggregatesInput | SmtpConfigScalarWhereWithAggregatesInput[]
    OR?: SmtpConfigScalarWhereWithAggregatesInput[]
    NOT?: SmtpConfigScalarWhereWithAggregatesInput | SmtpConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SmtpConfig"> | string
    host?: StringWithAggregatesFilter<"SmtpConfig"> | string
    port?: IntWithAggregatesFilter<"SmtpConfig"> | number
    user?: StringWithAggregatesFilter<"SmtpConfig"> | string
    password?: StringWithAggregatesFilter<"SmtpConfig"> | string
    secure?: BoolWithAggregatesFilter<"SmtpConfig"> | boolean
  }

  export type JobRunWhereInput = {
    AND?: JobRunWhereInput | JobRunWhereInput[]
    OR?: JobRunWhereInput[]
    NOT?: JobRunWhereInput | JobRunWhereInput[]
    id?: StringFilter<"JobRun"> | string
    jobName?: StringFilter<"JobRun"> | string
    startedAt?: DateTimeFilter<"JobRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobRun"> | Date | string | null
    status?: StringFilter<"JobRun"> | string
    recordsProcessed?: IntNullableFilter<"JobRun"> | number | null
    errorMessage?: StringNullableFilter<"JobRun"> | string | null
    metadata?: StringNullableFilter<"JobRun"> | string | null
  }

  export type JobRunOrderByWithRelationInput = {
    id?: SortOrder
    jobName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _relevance?: JobRunOrderByRelevanceInput
  }

  export type JobRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JobRunWhereInput | JobRunWhereInput[]
    OR?: JobRunWhereInput[]
    NOT?: JobRunWhereInput | JobRunWhereInput[]
    jobName?: StringFilter<"JobRun"> | string
    startedAt?: DateTimeFilter<"JobRun"> | Date | string
    completedAt?: DateTimeNullableFilter<"JobRun"> | Date | string | null
    status?: StringFilter<"JobRun"> | string
    recordsProcessed?: IntNullableFilter<"JobRun"> | number | null
    errorMessage?: StringNullableFilter<"JobRun"> | string | null
    metadata?: StringNullableFilter<"JobRun"> | string | null
  }, "id">

  export type JobRunOrderByWithAggregationInput = {
    id?: SortOrder
    jobName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: JobRunCountOrderByAggregateInput
    _avg?: JobRunAvgOrderByAggregateInput
    _max?: JobRunMaxOrderByAggregateInput
    _min?: JobRunMinOrderByAggregateInput
    _sum?: JobRunSumOrderByAggregateInput
  }

  export type JobRunScalarWhereWithAggregatesInput = {
    AND?: JobRunScalarWhereWithAggregatesInput | JobRunScalarWhereWithAggregatesInput[]
    OR?: JobRunScalarWhereWithAggregatesInput[]
    NOT?: JobRunScalarWhereWithAggregatesInput | JobRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JobRun"> | string
    jobName?: StringWithAggregatesFilter<"JobRun"> | string
    startedAt?: DateTimeWithAggregatesFilter<"JobRun"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"JobRun"> | Date | string | null
    status?: StringWithAggregatesFilter<"JobRun"> | string
    recordsProcessed?: IntNullableWithAggregatesFilter<"JobRun"> | number | null
    errorMessage?: StringNullableWithAggregatesFilter<"JobRun"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"JobRun"> | string | null
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    registrationEnabled?: BoolFilter<"SystemSettings"> | boolean
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    registrationEnabled?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SystemSettingsOrderByRelevanceInput
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    registrationEnabled?: BoolFilter<"SystemSettings"> | boolean
    updatedAt?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    registrationEnabled?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    registrationEnabled?: BoolWithAggregatesFilter<"SystemSettings"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type SMTPAccountWhereInput = {
    AND?: SMTPAccountWhereInput | SMTPAccountWhereInput[]
    OR?: SMTPAccountWhereInput[]
    NOT?: SMTPAccountWhereInput | SMTPAccountWhereInput[]
    id?: StringFilter<"SMTPAccount"> | string
    nombre?: StringFilter<"SMTPAccount"> | string
    host?: StringFilter<"SMTPAccount"> | string
    port?: IntFilter<"SMTPAccount"> | number
    user?: StringFilter<"SMTPAccount"> | string
    password?: StringFilter<"SMTPAccount"> | string
    isPredeterminada?: BoolFilter<"SMTPAccount"> | boolean
    activa?: BoolFilter<"SMTPAccount"> | boolean
    creadaPor?: StringNullableFilter<"SMTPAccount"> | string | null
    fechaCreacion?: DateTimeFilter<"SMTPAccount"> | Date | string
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
    scheduled?: ScheduledNotificationListRelationFilter
  }

  export type SMTPAccountOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    isPredeterminada?: SortOrder
    activa?: SortOrder
    creadaPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    creador?: UserOrderByWithRelationInput
    logs?: NotificationLogOrderByRelationAggregateInput
    scheduled?: ScheduledNotificationOrderByRelationAggregateInput
    _relevance?: SMTPAccountOrderByRelevanceInput
  }

  export type SMTPAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SMTPAccountWhereInput | SMTPAccountWhereInput[]
    OR?: SMTPAccountWhereInput[]
    NOT?: SMTPAccountWhereInput | SMTPAccountWhereInput[]
    nombre?: StringFilter<"SMTPAccount"> | string
    host?: StringFilter<"SMTPAccount"> | string
    port?: IntFilter<"SMTPAccount"> | number
    user?: StringFilter<"SMTPAccount"> | string
    password?: StringFilter<"SMTPAccount"> | string
    isPredeterminada?: BoolFilter<"SMTPAccount"> | boolean
    activa?: BoolFilter<"SMTPAccount"> | boolean
    creadaPor?: StringNullableFilter<"SMTPAccount"> | string | null
    fechaCreacion?: DateTimeFilter<"SMTPAccount"> | Date | string
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
    scheduled?: ScheduledNotificationListRelationFilter
  }, "id">

  export type SMTPAccountOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    isPredeterminada?: SortOrder
    activa?: SortOrder
    creadaPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    _count?: SMTPAccountCountOrderByAggregateInput
    _avg?: SMTPAccountAvgOrderByAggregateInput
    _max?: SMTPAccountMaxOrderByAggregateInput
    _min?: SMTPAccountMinOrderByAggregateInput
    _sum?: SMTPAccountSumOrderByAggregateInput
  }

  export type SMTPAccountScalarWhereWithAggregatesInput = {
    AND?: SMTPAccountScalarWhereWithAggregatesInput | SMTPAccountScalarWhereWithAggregatesInput[]
    OR?: SMTPAccountScalarWhereWithAggregatesInput[]
    NOT?: SMTPAccountScalarWhereWithAggregatesInput | SMTPAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SMTPAccount"> | string
    nombre?: StringWithAggregatesFilter<"SMTPAccount"> | string
    host?: StringWithAggregatesFilter<"SMTPAccount"> | string
    port?: IntWithAggregatesFilter<"SMTPAccount"> | number
    user?: StringWithAggregatesFilter<"SMTPAccount"> | string
    password?: StringWithAggregatesFilter<"SMTPAccount"> | string
    isPredeterminada?: BoolWithAggregatesFilter<"SMTPAccount"> | boolean
    activa?: BoolWithAggregatesFilter<"SMTPAccount"> | boolean
    creadaPor?: StringNullableWithAggregatesFilter<"SMTPAccount"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"SMTPAccount"> | Date | string
  }

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    nombre?: StringFilter<"NotificationTemplate"> | string
    asunto?: StringFilter<"NotificationTemplate"> | string
    contenidoHTML?: StringFilter<"NotificationTemplate"> | string
    variables?: JsonNullableFilter<"NotificationTemplate">
    tipo?: StringFilter<"NotificationTemplate"> | string
    activa?: BoolFilter<"NotificationTemplate"> | boolean
    creadoPor?: StringNullableFilter<"NotificationTemplate"> | string | null
    fechaCreacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
    fechaActualizacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
    scheduled?: ScheduledNotificationListRelationFilter
  }

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    asunto?: SortOrder
    contenidoHTML?: SortOrder
    variables?: SortOrderInput | SortOrder
    tipo?: SortOrder
    activa?: SortOrder
    creadoPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    creador?: UserOrderByWithRelationInput
    logs?: NotificationLogOrderByRelationAggregateInput
    scheduled?: ScheduledNotificationOrderByRelationAggregateInput
    _relevance?: NotificationTemplateOrderByRelevanceInput
  }

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    nombre?: StringFilter<"NotificationTemplate"> | string
    asunto?: StringFilter<"NotificationTemplate"> | string
    contenidoHTML?: StringFilter<"NotificationTemplate"> | string
    variables?: JsonNullableFilter<"NotificationTemplate">
    tipo?: StringFilter<"NotificationTemplate"> | string
    activa?: BoolFilter<"NotificationTemplate"> | boolean
    creadoPor?: StringNullableFilter<"NotificationTemplate"> | string | null
    fechaCreacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
    fechaActualizacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    logs?: NotificationLogListRelationFilter
    scheduled?: ScheduledNotificationListRelationFilter
  }, "id">

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    asunto?: SortOrder
    contenidoHTML?: SortOrder
    variables?: SortOrderInput | SortOrder
    tipo?: SortOrder
    activa?: SortOrder
    creadoPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    _count?: NotificationTemplateCountOrderByAggregateInput
    _max?: NotificationTemplateMaxOrderByAggregateInput
    _min?: NotificationTemplateMinOrderByAggregateInput
  }

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[]
    NOT?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    nombre?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    asunto?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    contenidoHTML?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    variables?: JsonNullableWithAggregatesFilter<"NotificationTemplate">
    tipo?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    activa?: BoolWithAggregatesFilter<"NotificationTemplate"> | boolean
    creadoPor?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
    fechaActualizacion?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationLogWhereInput = {
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    plantillaId?: StringNullableFilter<"NotificationLog"> | string | null
    smtpAccountId?: StringNullableFilter<"NotificationLog"> | string | null
    destinatarios?: JsonFilter<"NotificationLog">
    asunto?: StringFilter<"NotificationLog"> | string
    contenido?: StringFilter<"NotificationLog"> | string
    tipo?: StringFilter<"NotificationLog"> | string
    estado?: StringFilter<"NotificationLog"> | string
    fechaEnvio?: DateTimeFilter<"NotificationLog"> | Date | string
    enviadoPor?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
    plantilla?: XOR<NotificationTemplateNullableScalarRelationFilter, NotificationTemplateWhereInput> | null
    smtpAccount?: XOR<SMTPAccountNullableScalarRelationFilter, SMTPAccountWhereInput> | null
    enviador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationLogOrderByWithRelationInput = {
    id?: SortOrder
    plantillaId?: SortOrderInput | SortOrder
    smtpAccountId?: SortOrderInput | SortOrder
    destinatarios?: SortOrder
    asunto?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    fechaEnvio?: SortOrder
    enviadoPor?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    plantilla?: NotificationTemplateOrderByWithRelationInput
    smtpAccount?: SMTPAccountOrderByWithRelationInput
    enviador?: UserOrderByWithRelationInput
    _relevance?: NotificationLogOrderByRelevanceInput
  }

  export type NotificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationLogWhereInput | NotificationLogWhereInput[]
    OR?: NotificationLogWhereInput[]
    NOT?: NotificationLogWhereInput | NotificationLogWhereInput[]
    plantillaId?: StringNullableFilter<"NotificationLog"> | string | null
    smtpAccountId?: StringNullableFilter<"NotificationLog"> | string | null
    destinatarios?: JsonFilter<"NotificationLog">
    asunto?: StringFilter<"NotificationLog"> | string
    contenido?: StringFilter<"NotificationLog"> | string
    tipo?: StringFilter<"NotificationLog"> | string
    estado?: StringFilter<"NotificationLog"> | string
    fechaEnvio?: DateTimeFilter<"NotificationLog"> | Date | string
    enviadoPor?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
    plantilla?: XOR<NotificationTemplateNullableScalarRelationFilter, NotificationTemplateWhereInput> | null
    smtpAccount?: XOR<SMTPAccountNullableScalarRelationFilter, SMTPAccountWhereInput> | null
    enviador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    plantillaId?: SortOrderInput | SortOrder
    smtpAccountId?: SortOrderInput | SortOrder
    destinatarios?: SortOrder
    asunto?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    fechaEnvio?: SortOrder
    enviadoPor?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: NotificationLogCountOrderByAggregateInput
    _max?: NotificationLogMaxOrderByAggregateInput
    _min?: NotificationLogMinOrderByAggregateInput
  }

  export type NotificationLogScalarWhereWithAggregatesInput = {
    AND?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    OR?: NotificationLogScalarWhereWithAggregatesInput[]
    NOT?: NotificationLogScalarWhereWithAggregatesInput | NotificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationLog"> | string
    plantillaId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    smtpAccountId?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    destinatarios?: JsonWithAggregatesFilter<"NotificationLog">
    asunto?: StringWithAggregatesFilter<"NotificationLog"> | string
    contenido?: StringWithAggregatesFilter<"NotificationLog"> | string
    tipo?: StringWithAggregatesFilter<"NotificationLog"> | string
    estado?: StringWithAggregatesFilter<"NotificationLog"> | string
    fechaEnvio?: DateTimeWithAggregatesFilter<"NotificationLog"> | Date | string
    enviadoPor?: StringNullableWithAggregatesFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"NotificationLog">
  }

  export type ScheduledNotificationWhereInput = {
    AND?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    OR?: ScheduledNotificationWhereInput[]
    NOT?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    id?: StringFilter<"ScheduledNotification"> | string
    plantillaId?: StringFilter<"ScheduledNotification"> | string
    smtpAccountId?: StringNullableFilter<"ScheduledNotification"> | string | null
    destinatariosSeleccionados?: JsonFilter<"ScheduledNotification">
    fechaProgramada?: DateTimeFilter<"ScheduledNotification"> | Date | string
    estado?: StringFilter<"ScheduledNotification"> | string
    recurrencia?: StringFilter<"ScheduledNotification"> | string
    creadoPor?: StringNullableFilter<"ScheduledNotification"> | string | null
    fechaCreacion?: DateTimeFilter<"ScheduledNotification"> | Date | string
    plantilla?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
    smtpAccount?: XOR<SMTPAccountNullableScalarRelationFilter, SMTPAccountWhereInput> | null
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ScheduledNotificationOrderByWithRelationInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrderInput | SortOrder
    destinatariosSeleccionados?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    recurrencia?: SortOrder
    creadoPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    plantilla?: NotificationTemplateOrderByWithRelationInput
    smtpAccount?: SMTPAccountOrderByWithRelationInput
    creador?: UserOrderByWithRelationInput
    _relevance?: ScheduledNotificationOrderByRelevanceInput
  }

  export type ScheduledNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    OR?: ScheduledNotificationWhereInput[]
    NOT?: ScheduledNotificationWhereInput | ScheduledNotificationWhereInput[]
    plantillaId?: StringFilter<"ScheduledNotification"> | string
    smtpAccountId?: StringNullableFilter<"ScheduledNotification"> | string | null
    destinatariosSeleccionados?: JsonFilter<"ScheduledNotification">
    fechaProgramada?: DateTimeFilter<"ScheduledNotification"> | Date | string
    estado?: StringFilter<"ScheduledNotification"> | string
    recurrencia?: StringFilter<"ScheduledNotification"> | string
    creadoPor?: StringNullableFilter<"ScheduledNotification"> | string | null
    fechaCreacion?: DateTimeFilter<"ScheduledNotification"> | Date | string
    plantilla?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
    smtpAccount?: XOR<SMTPAccountNullableScalarRelationFilter, SMTPAccountWhereInput> | null
    creador?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ScheduledNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrderInput | SortOrder
    destinatariosSeleccionados?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    recurrencia?: SortOrder
    creadoPor?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    _count?: ScheduledNotificationCountOrderByAggregateInput
    _max?: ScheduledNotificationMaxOrderByAggregateInput
    _min?: ScheduledNotificationMinOrderByAggregateInput
  }

  export type ScheduledNotificationScalarWhereWithAggregatesInput = {
    AND?: ScheduledNotificationScalarWhereWithAggregatesInput | ScheduledNotificationScalarWhereWithAggregatesInput[]
    OR?: ScheduledNotificationScalarWhereWithAggregatesInput[]
    NOT?: ScheduledNotificationScalarWhereWithAggregatesInput | ScheduledNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    plantillaId?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    smtpAccountId?: StringNullableWithAggregatesFilter<"ScheduledNotification"> | string | null
    destinatariosSeleccionados?: JsonWithAggregatesFilter<"ScheduledNotification">
    fechaProgramada?: DateTimeWithAggregatesFilter<"ScheduledNotification"> | Date | string
    estado?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    recurrencia?: StringWithAggregatesFilter<"ScheduledNotification"> | string
    creadoPor?: StringNullableWithAggregatesFilter<"ScheduledNotification"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"ScheduledNotification"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isEditable?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    isEditable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SystemConfigOrderByRelevanceInput
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    isEditable?: BoolFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    isEditable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    isEditable?: BoolWithAggregatesFilter<"SystemConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type SystemBackupWhereInput = {
    AND?: SystemBackupWhereInput | SystemBackupWhereInput[]
    OR?: SystemBackupWhereInput[]
    NOT?: SystemBackupWhereInput | SystemBackupWhereInput[]
    id?: StringFilter<"SystemBackup"> | string
    version?: StringFilter<"SystemBackup"> | string
    dbFile?: StringFilter<"SystemBackup"> | string
    filesFile?: StringFilter<"SystemBackup"> | string
    dbSize?: BigIntFilter<"SystemBackup"> | bigint | number
    filesSize?: BigIntFilter<"SystemBackup"> | bigint | number
    status?: EnumBackupStatusFilter<"SystemBackup"> | $Enums.BackupStatus
    errorMessage?: StringNullableFilter<"SystemBackup"> | string | null
    createdBy?: StringNullableFilter<"SystemBackup"> | string | null
    createdAt?: DateTimeFilter<"SystemBackup"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemBackup"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SystemBackupOrderByWithRelationInput = {
    id?: SortOrder
    version?: SortOrder
    dbFile?: SortOrder
    filesFile?: SortOrder
    dbSize?: SortOrder
    filesSize?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    _relevance?: SystemBackupOrderByRelevanceInput
  }

  export type SystemBackupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemBackupWhereInput | SystemBackupWhereInput[]
    OR?: SystemBackupWhereInput[]
    NOT?: SystemBackupWhereInput | SystemBackupWhereInput[]
    version?: StringFilter<"SystemBackup"> | string
    dbFile?: StringFilter<"SystemBackup"> | string
    filesFile?: StringFilter<"SystemBackup"> | string
    dbSize?: BigIntFilter<"SystemBackup"> | bigint | number
    filesSize?: BigIntFilter<"SystemBackup"> | bigint | number
    status?: EnumBackupStatusFilter<"SystemBackup"> | $Enums.BackupStatus
    errorMessage?: StringNullableFilter<"SystemBackup"> | string | null
    createdBy?: StringNullableFilter<"SystemBackup"> | string | null
    createdAt?: DateTimeFilter<"SystemBackup"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemBackup"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemBackupOrderByWithAggregationInput = {
    id?: SortOrder
    version?: SortOrder
    dbFile?: SortOrder
    filesFile?: SortOrder
    dbSize?: SortOrder
    filesSize?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SystemBackupCountOrderByAggregateInput
    _avg?: SystemBackupAvgOrderByAggregateInput
    _max?: SystemBackupMaxOrderByAggregateInput
    _min?: SystemBackupMinOrderByAggregateInput
    _sum?: SystemBackupSumOrderByAggregateInput
  }

  export type SystemBackupScalarWhereWithAggregatesInput = {
    AND?: SystemBackupScalarWhereWithAggregatesInput | SystemBackupScalarWhereWithAggregatesInput[]
    OR?: SystemBackupScalarWhereWithAggregatesInput[]
    NOT?: SystemBackupScalarWhereWithAggregatesInput | SystemBackupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemBackup"> | string
    version?: StringWithAggregatesFilter<"SystemBackup"> | string
    dbFile?: StringWithAggregatesFilter<"SystemBackup"> | string
    filesFile?: StringWithAggregatesFilter<"SystemBackup"> | string
    dbSize?: BigIntWithAggregatesFilter<"SystemBackup"> | bigint | number
    filesSize?: BigIntWithAggregatesFilter<"SystemBackup"> | bigint | number
    status?: EnumBackupStatusWithAggregatesFilter<"SystemBackup"> | $Enums.BackupStatus
    errorMessage?: StringNullableWithAggregatesFilter<"SystemBackup"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"SystemBackup"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemBackup"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SystemBackup"> | Date | string | null
  }

  export type SystemUpdateWhereInput = {
    AND?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    OR?: SystemUpdateWhereInput[]
    NOT?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    id?: StringFilter<"SystemUpdate"> | string
    fromVersion?: StringFilter<"SystemUpdate"> | string
    toVersion?: StringFilter<"SystemUpdate"> | string
    status?: EnumUpdateStatusFilter<"SystemUpdate"> | $Enums.UpdateStatus
    logs?: JsonNullableFilter<"SystemUpdate">
    backupId?: StringNullableFilter<"SystemUpdate"> | string | null
    errorMessage?: StringNullableFilter<"SystemUpdate"> | string | null
    initiatedBy?: StringNullableFilter<"SystemUpdate"> | string | null
    createdAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdate"> | Date | string | null
    initiator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SystemUpdateOrderByWithRelationInput = {
    id?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    status?: SortOrder
    logs?: SortOrderInput | SortOrder
    backupId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    initiatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    initiator?: UserOrderByWithRelationInput
    _relevance?: SystemUpdateOrderByRelevanceInput
  }

  export type SystemUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    OR?: SystemUpdateWhereInput[]
    NOT?: SystemUpdateWhereInput | SystemUpdateWhereInput[]
    fromVersion?: StringFilter<"SystemUpdate"> | string
    toVersion?: StringFilter<"SystemUpdate"> | string
    status?: EnumUpdateStatusFilter<"SystemUpdate"> | $Enums.UpdateStatus
    logs?: JsonNullableFilter<"SystemUpdate">
    backupId?: StringNullableFilter<"SystemUpdate"> | string | null
    errorMessage?: StringNullableFilter<"SystemUpdate"> | string | null
    initiatedBy?: StringNullableFilter<"SystemUpdate"> | string | null
    createdAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdate"> | Date | string | null
    initiator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SystemUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    status?: SortOrder
    logs?: SortOrderInput | SortOrder
    backupId?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    initiatedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: SystemUpdateCountOrderByAggregateInput
    _max?: SystemUpdateMaxOrderByAggregateInput
    _min?: SystemUpdateMinOrderByAggregateInput
  }

  export type SystemUpdateScalarWhereWithAggregatesInput = {
    AND?: SystemUpdateScalarWhereWithAggregatesInput | SystemUpdateScalarWhereWithAggregatesInput[]
    OR?: SystemUpdateScalarWhereWithAggregatesInput[]
    NOT?: SystemUpdateScalarWhereWithAggregatesInput | SystemUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemUpdate"> | string
    fromVersion?: StringWithAggregatesFilter<"SystemUpdate"> | string
    toVersion?: StringWithAggregatesFilter<"SystemUpdate"> | string
    status?: EnumUpdateStatusWithAggregatesFilter<"SystemUpdate"> | $Enums.UpdateStatus
    logs?: JsonNullableWithAggregatesFilter<"SystemUpdate">
    backupId?: StringNullableWithAggregatesFilter<"SystemUpdate"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"SystemUpdate"> | string | null
    initiatedBy?: StringNullableWithAggregatesFilter<"SystemUpdate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SystemUpdate"> | Date | string | null
  }

  export type StorageConfigWhereInput = {
    AND?: StorageConfigWhereInput | StorageConfigWhereInput[]
    OR?: StorageConfigWhereInput[]
    NOT?: StorageConfigWhereInput | StorageConfigWhereInput[]
    id?: StringFilter<"StorageConfig"> | string
    type?: EnumStorageTypeFilter<"StorageConfig"> | $Enums.StorageType
    name?: StringFilter<"StorageConfig"> | string
    host?: StringNullableFilter<"StorageConfig"> | string | null
    port?: IntNullableFilter<"StorageConfig"> | number | null
    username?: StringNullableFilter<"StorageConfig"> | string | null
    encryptedPassword?: StringNullableFilter<"StorageConfig"> | string | null
    basePath?: StringFilter<"StorageConfig"> | string
    isActive?: BoolFilter<"StorageConfig"> | boolean
    createdAt?: DateTimeFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StorageConfig"> | Date | string
  }

  export type StorageConfigOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    host?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    encryptedPassword?: SortOrderInput | SortOrder
    basePath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: StorageConfigOrderByRelevanceInput
  }

  export type StorageConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StorageConfigWhereInput | StorageConfigWhereInput[]
    OR?: StorageConfigWhereInput[]
    NOT?: StorageConfigWhereInput | StorageConfigWhereInput[]
    type?: EnumStorageTypeFilter<"StorageConfig"> | $Enums.StorageType
    name?: StringFilter<"StorageConfig"> | string
    host?: StringNullableFilter<"StorageConfig"> | string | null
    port?: IntNullableFilter<"StorageConfig"> | number | null
    username?: StringNullableFilter<"StorageConfig"> | string | null
    encryptedPassword?: StringNullableFilter<"StorageConfig"> | string | null
    basePath?: StringFilter<"StorageConfig"> | string
    isActive?: BoolFilter<"StorageConfig"> | boolean
    createdAt?: DateTimeFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeFilter<"StorageConfig"> | Date | string
  }, "id">

  export type StorageConfigOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    host?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    encryptedPassword?: SortOrderInput | SortOrder
    basePath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageConfigCountOrderByAggregateInput
    _avg?: StorageConfigAvgOrderByAggregateInput
    _max?: StorageConfigMaxOrderByAggregateInput
    _min?: StorageConfigMinOrderByAggregateInput
    _sum?: StorageConfigSumOrderByAggregateInput
  }

  export type StorageConfigScalarWhereWithAggregatesInput = {
    AND?: StorageConfigScalarWhereWithAggregatesInput | StorageConfigScalarWhereWithAggregatesInput[]
    OR?: StorageConfigScalarWhereWithAggregatesInput[]
    NOT?: StorageConfigScalarWhereWithAggregatesInput | StorageConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorageConfig"> | string
    type?: EnumStorageTypeWithAggregatesFilter<"StorageConfig"> | $Enums.StorageType
    name?: StringWithAggregatesFilter<"StorageConfig"> | string
    host?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    port?: IntNullableWithAggregatesFilter<"StorageConfig"> | number | null
    username?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    encryptedPassword?: StringNullableWithAggregatesFilter<"StorageConfig"> | string | null
    basePath?: StringWithAggregatesFilter<"StorageConfig"> | string
    isActive?: BoolWithAggregatesFilter<"StorageConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StorageConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageConfig"> | Date | string
  }

  export type ImpuestoWhereInput = {
    AND?: ImpuestoWhereInput | ImpuestoWhereInput[]
    OR?: ImpuestoWhereInput[]
    NOT?: ImpuestoWhereInput | ImpuestoWhereInput[]
    id?: StringFilter<"Impuesto"> | string
    nombre?: StringFilter<"Impuesto"> | string
    modelo?: StringFilter<"Impuesto"> | string
    descripcion?: StringNullableFilter<"Impuesto"> | string | null
    activo?: BoolFilter<"Impuesto"> | boolean
    createdAt?: DateTimeFilter<"Impuesto"> | Date | string
    updatedAt?: DateTimeFilter<"Impuesto"> | Date | string
    obligaciones?: ObligacionFiscalListRelationFilter
  }

  export type ImpuestoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    modelo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obligaciones?: ObligacionFiscalOrderByRelationAggregateInput
    _relevance?: ImpuestoOrderByRelevanceInput
  }

  export type ImpuestoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelo?: string
    AND?: ImpuestoWhereInput | ImpuestoWhereInput[]
    OR?: ImpuestoWhereInput[]
    NOT?: ImpuestoWhereInput | ImpuestoWhereInput[]
    nombre?: StringFilter<"Impuesto"> | string
    descripcion?: StringNullableFilter<"Impuesto"> | string | null
    activo?: BoolFilter<"Impuesto"> | boolean
    createdAt?: DateTimeFilter<"Impuesto"> | Date | string
    updatedAt?: DateTimeFilter<"Impuesto"> | Date | string
    obligaciones?: ObligacionFiscalListRelationFilter
  }, "id" | "modelo">

  export type ImpuestoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    modelo?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ImpuestoCountOrderByAggregateInput
    _max?: ImpuestoMaxOrderByAggregateInput
    _min?: ImpuestoMinOrderByAggregateInput
  }

  export type ImpuestoScalarWhereWithAggregatesInput = {
    AND?: ImpuestoScalarWhereWithAggregatesInput | ImpuestoScalarWhereWithAggregatesInput[]
    OR?: ImpuestoScalarWhereWithAggregatesInput[]
    NOT?: ImpuestoScalarWhereWithAggregatesInput | ImpuestoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Impuesto"> | string
    nombre?: StringWithAggregatesFilter<"Impuesto"> | string
    modelo?: StringWithAggregatesFilter<"Impuesto"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Impuesto"> | string | null
    activo?: BoolWithAggregatesFilter<"Impuesto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Impuesto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Impuesto"> | Date | string
  }

  export type ObligacionFiscalWhereInput = {
    AND?: ObligacionFiscalWhereInput | ObligacionFiscalWhereInput[]
    OR?: ObligacionFiscalWhereInput[]
    NOT?: ObligacionFiscalWhereInput | ObligacionFiscalWhereInput[]
    id?: StringFilter<"ObligacionFiscal"> | string
    clienteId?: StringFilter<"ObligacionFiscal"> | string
    impuestoId?: StringFilter<"ObligacionFiscal"> | string
    periodicidad?: EnumPeriodicidadFilter<"ObligacionFiscal"> | $Enums.Periodicidad
    diaVencimiento?: IntNullableFilter<"ObligacionFiscal"> | number | null
    fechaInicio?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"ObligacionFiscal"> | Date | string | null
    observaciones?: StringNullableFilter<"ObligacionFiscal"> | string | null
    fechaAsignacion?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    activo?: BoolFilter<"ObligacionFiscal"> | boolean
    createdAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    updatedAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    cliente?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    impuesto?: XOR<ImpuestoScalarRelationFilter, ImpuestoWhereInput>
    declaraciones?: DeclaracionListRelationFilter
  }

  export type ObligacionFiscalOrderByWithRelationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    impuestoId?: SortOrder
    periodicidad?: SortOrder
    diaVencimiento?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    fechaAsignacion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cliente?: ClientOrderByWithRelationInput
    impuesto?: ImpuestoOrderByWithRelationInput
    declaraciones?: DeclaracionOrderByRelationAggregateInput
    _relevance?: ObligacionFiscalOrderByRelevanceInput
  }

  export type ObligacionFiscalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObligacionFiscalWhereInput | ObligacionFiscalWhereInput[]
    OR?: ObligacionFiscalWhereInput[]
    NOT?: ObligacionFiscalWhereInput | ObligacionFiscalWhereInput[]
    clienteId?: StringFilter<"ObligacionFiscal"> | string
    impuestoId?: StringFilter<"ObligacionFiscal"> | string
    periodicidad?: EnumPeriodicidadFilter<"ObligacionFiscal"> | $Enums.Periodicidad
    diaVencimiento?: IntNullableFilter<"ObligacionFiscal"> | number | null
    fechaInicio?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"ObligacionFiscal"> | Date | string | null
    observaciones?: StringNullableFilter<"ObligacionFiscal"> | string | null
    fechaAsignacion?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    activo?: BoolFilter<"ObligacionFiscal"> | boolean
    createdAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    updatedAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    cliente?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    impuesto?: XOR<ImpuestoScalarRelationFilter, ImpuestoWhereInput>
    declaraciones?: DeclaracionListRelationFilter
  }, "id">

  export type ObligacionFiscalOrderByWithAggregationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    impuestoId?: SortOrder
    periodicidad?: SortOrder
    diaVencimiento?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    fechaAsignacion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ObligacionFiscalCountOrderByAggregateInput
    _avg?: ObligacionFiscalAvgOrderByAggregateInput
    _max?: ObligacionFiscalMaxOrderByAggregateInput
    _min?: ObligacionFiscalMinOrderByAggregateInput
    _sum?: ObligacionFiscalSumOrderByAggregateInput
  }

  export type ObligacionFiscalScalarWhereWithAggregatesInput = {
    AND?: ObligacionFiscalScalarWhereWithAggregatesInput | ObligacionFiscalScalarWhereWithAggregatesInput[]
    OR?: ObligacionFiscalScalarWhereWithAggregatesInput[]
    NOT?: ObligacionFiscalScalarWhereWithAggregatesInput | ObligacionFiscalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObligacionFiscal"> | string
    clienteId?: StringWithAggregatesFilter<"ObligacionFiscal"> | string
    impuestoId?: StringWithAggregatesFilter<"ObligacionFiscal"> | string
    periodicidad?: EnumPeriodicidadWithAggregatesFilter<"ObligacionFiscal"> | $Enums.Periodicidad
    diaVencimiento?: IntNullableWithAggregatesFilter<"ObligacionFiscal"> | number | null
    fechaInicio?: DateTimeWithAggregatesFilter<"ObligacionFiscal"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"ObligacionFiscal"> | Date | string | null
    observaciones?: StringNullableWithAggregatesFilter<"ObligacionFiscal"> | string | null
    fechaAsignacion?: DateTimeWithAggregatesFilter<"ObligacionFiscal"> | Date | string
    activo?: BoolWithAggregatesFilter<"ObligacionFiscal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ObligacionFiscal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ObligacionFiscal"> | Date | string
  }

  export type CalendarioAEATWhereInput = {
    AND?: CalendarioAEATWhereInput | CalendarioAEATWhereInput[]
    OR?: CalendarioAEATWhereInput[]
    NOT?: CalendarioAEATWhereInput | CalendarioAEATWhereInput[]
    id?: StringFilter<"CalendarioAEAT"> | string
    modelo?: StringFilter<"CalendarioAEAT"> | string
    periodicidad?: EnumPeriodicidadFilter<"CalendarioAEAT"> | $Enums.Periodicidad
    periodoContable?: StringFilter<"CalendarioAEAT"> | string
    fechaInicio?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    fechaFin?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    createdAt?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    declaraciones?: DeclaracionListRelationFilter
  }

  export type CalendarioAEATOrderByWithRelationInput = {
    id?: SortOrder
    modelo?: SortOrder
    periodicidad?: SortOrder
    periodoContable?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    declaraciones?: DeclaracionOrderByRelationAggregateInput
    _relevance?: CalendarioAEATOrderByRelevanceInput
  }

  export type CalendarioAEATWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    modelo_periodicidad_periodoContable?: CalendarioAEATModeloPeriodicidadPeriodoContableCompoundUniqueInput
    AND?: CalendarioAEATWhereInput | CalendarioAEATWhereInput[]
    OR?: CalendarioAEATWhereInput[]
    NOT?: CalendarioAEATWhereInput | CalendarioAEATWhereInput[]
    modelo?: StringFilter<"CalendarioAEAT"> | string
    periodicidad?: EnumPeriodicidadFilter<"CalendarioAEAT"> | $Enums.Periodicidad
    periodoContable?: StringFilter<"CalendarioAEAT"> | string
    fechaInicio?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    fechaFin?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    createdAt?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    updatedAt?: DateTimeFilter<"CalendarioAEAT"> | Date | string
    declaraciones?: DeclaracionListRelationFilter
  }, "id" | "modelo_periodicidad_periodoContable">

  export type CalendarioAEATOrderByWithAggregationInput = {
    id?: SortOrder
    modelo?: SortOrder
    periodicidad?: SortOrder
    periodoContable?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CalendarioAEATCountOrderByAggregateInput
    _max?: CalendarioAEATMaxOrderByAggregateInput
    _min?: CalendarioAEATMinOrderByAggregateInput
  }

  export type CalendarioAEATScalarWhereWithAggregatesInput = {
    AND?: CalendarioAEATScalarWhereWithAggregatesInput | CalendarioAEATScalarWhereWithAggregatesInput[]
    OR?: CalendarioAEATScalarWhereWithAggregatesInput[]
    NOT?: CalendarioAEATScalarWhereWithAggregatesInput | CalendarioAEATScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CalendarioAEAT"> | string
    modelo?: StringWithAggregatesFilter<"CalendarioAEAT"> | string
    periodicidad?: EnumPeriodicidadWithAggregatesFilter<"CalendarioAEAT"> | $Enums.Periodicidad
    periodoContable?: StringWithAggregatesFilter<"CalendarioAEAT"> | string
    fechaInicio?: DateTimeWithAggregatesFilter<"CalendarioAEAT"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"CalendarioAEAT"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CalendarioAEAT"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CalendarioAEAT"> | Date | string
  }

  export type DeclaracionWhereInput = {
    AND?: DeclaracionWhereInput | DeclaracionWhereInput[]
    OR?: DeclaracionWhereInput[]
    NOT?: DeclaracionWhereInput | DeclaracionWhereInput[]
    id?: StringFilter<"Declaracion"> | string
    obligacionId?: StringFilter<"Declaracion"> | string
    calendarioId?: StringFilter<"Declaracion"> | string
    estado?: EnumEstadoDeclaracionFilter<"Declaracion"> | $Enums.EstadoDeclaracion
    fechaPresentacion?: DateTimeNullableFilter<"Declaracion"> | Date | string | null
    archivoPdf?: StringNullableFilter<"Declaracion"> | string | null
    notas?: StringNullableFilter<"Declaracion"> | string | null
    createdAt?: DateTimeFilter<"Declaracion"> | Date | string
    updatedAt?: DateTimeFilter<"Declaracion"> | Date | string
    obligacion?: XOR<ObligacionFiscalScalarRelationFilter, ObligacionFiscalWhereInput>
    calendario?: XOR<CalendarioAEATScalarRelationFilter, CalendarioAEATWhereInput>
  }

  export type DeclaracionOrderByWithRelationInput = {
    id?: SortOrder
    obligacionId?: SortOrder
    calendarioId?: SortOrder
    estado?: SortOrder
    fechaPresentacion?: SortOrderInput | SortOrder
    archivoPdf?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    obligacion?: ObligacionFiscalOrderByWithRelationInput
    calendario?: CalendarioAEATOrderByWithRelationInput
    _relevance?: DeclaracionOrderByRelevanceInput
  }

  export type DeclaracionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeclaracionWhereInput | DeclaracionWhereInput[]
    OR?: DeclaracionWhereInput[]
    NOT?: DeclaracionWhereInput | DeclaracionWhereInput[]
    obligacionId?: StringFilter<"Declaracion"> | string
    calendarioId?: StringFilter<"Declaracion"> | string
    estado?: EnumEstadoDeclaracionFilter<"Declaracion"> | $Enums.EstadoDeclaracion
    fechaPresentacion?: DateTimeNullableFilter<"Declaracion"> | Date | string | null
    archivoPdf?: StringNullableFilter<"Declaracion"> | string | null
    notas?: StringNullableFilter<"Declaracion"> | string | null
    createdAt?: DateTimeFilter<"Declaracion"> | Date | string
    updatedAt?: DateTimeFilter<"Declaracion"> | Date | string
    obligacion?: XOR<ObligacionFiscalScalarRelationFilter, ObligacionFiscalWhereInput>
    calendario?: XOR<CalendarioAEATScalarRelationFilter, CalendarioAEATWhereInput>
  }, "id">

  export type DeclaracionOrderByWithAggregationInput = {
    id?: SortOrder
    obligacionId?: SortOrder
    calendarioId?: SortOrder
    estado?: SortOrder
    fechaPresentacion?: SortOrderInput | SortOrder
    archivoPdf?: SortOrderInput | SortOrder
    notas?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeclaracionCountOrderByAggregateInput
    _max?: DeclaracionMaxOrderByAggregateInput
    _min?: DeclaracionMinOrderByAggregateInput
  }

  export type DeclaracionScalarWhereWithAggregatesInput = {
    AND?: DeclaracionScalarWhereWithAggregatesInput | DeclaracionScalarWhereWithAggregatesInput[]
    OR?: DeclaracionScalarWhereWithAggregatesInput[]
    NOT?: DeclaracionScalarWhereWithAggregatesInput | DeclaracionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Declaracion"> | string
    obligacionId?: StringWithAggregatesFilter<"Declaracion"> | string
    calendarioId?: StringWithAggregatesFilter<"Declaracion"> | string
    estado?: EnumEstadoDeclaracionWithAggregatesFilter<"Declaracion"> | $Enums.EstadoDeclaracion
    fechaPresentacion?: DateTimeNullableWithAggregatesFilter<"Declaracion"> | Date | string | null
    archivoPdf?: StringNullableWithAggregatesFilter<"Declaracion"> | string | null
    notas?: StringNullableWithAggregatesFilter<"Declaracion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Declaracion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Declaracion"> | Date | string
  }

  export type NotificacionWhereInput = {
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    id?: StringFilter<"Notificacion"> | string
    clienteId?: StringFilter<"Notificacion"> | string
    periodo?: StringFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFilter<"Notificacion"> | Date | string
    enviada?: BoolFilter<"Notificacion"> | boolean
    asunto?: StringNullableFilter<"Notificacion"> | string | null
    mensaje?: StringNullableFilter<"Notificacion"> | string | null
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    cliente?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type NotificacionOrderByWithRelationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    periodo?: SortOrder
    tipo?: SortOrder
    fechaEnvio?: SortOrder
    enviada?: SortOrder
    asunto?: SortOrderInput | SortOrder
    mensaje?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    cliente?: ClientOrderByWithRelationInput
    _relevance?: NotificacionOrderByRelevanceInput
  }

  export type NotificacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificacionWhereInput | NotificacionWhereInput[]
    OR?: NotificacionWhereInput[]
    NOT?: NotificacionWhereInput | NotificacionWhereInput[]
    clienteId?: StringFilter<"Notificacion"> | string
    periodo?: StringFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFilter<"Notificacion"> | Date | string
    enviada?: BoolFilter<"Notificacion"> | boolean
    asunto?: StringNullableFilter<"Notificacion"> | string | null
    mensaje?: StringNullableFilter<"Notificacion"> | string | null
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
    cliente?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type NotificacionOrderByWithAggregationInput = {
    id?: SortOrder
    clienteId?: SortOrder
    periodo?: SortOrder
    tipo?: SortOrder
    fechaEnvio?: SortOrder
    enviada?: SortOrder
    asunto?: SortOrderInput | SortOrder
    mensaje?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificacionCountOrderByAggregateInput
    _max?: NotificacionMaxOrderByAggregateInput
    _min?: NotificacionMinOrderByAggregateInput
  }

  export type NotificacionScalarWhereWithAggregatesInput = {
    AND?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    OR?: NotificacionScalarWhereWithAggregatesInput[]
    NOT?: NotificacionScalarWhereWithAggregatesInput | NotificacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notificacion"> | string
    clienteId?: StringWithAggregatesFilter<"Notificacion"> | string
    periodo?: StringWithAggregatesFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionWithAggregatesFilter<"Notificacion"> | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
    enviada?: BoolWithAggregatesFilter<"Notificacion"> | boolean
    asunto?: StringNullableWithAggregatesFilter<"Notificacion"> | string | null
    mensaje?: StringNullableWithAggregatesFilter<"Notificacion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notificacion"> | Date | string
  }

  export type taxModelWhereInput = {
    AND?: taxModelWhereInput | taxModelWhereInput[]
    OR?: taxModelWhereInput[]
    NOT?: taxModelWhereInput | taxModelWhereInput[]
    id?: StringFilter<"taxModel"> | string
    nombre?: StringFilter<"taxModel"> | string
    descripcion?: StringNullableFilter<"taxModel"> | string | null
    periods?: TaxPeriodListRelationFilter
  }

  export type taxModelOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    periods?: taxPeriodOrderByRelationAggregateInput
    _relevance?: taxModelOrderByRelevanceInput
  }

  export type taxModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: taxModelWhereInput | taxModelWhereInput[]
    OR?: taxModelWhereInput[]
    NOT?: taxModelWhereInput | taxModelWhereInput[]
    nombre?: StringFilter<"taxModel"> | string
    descripcion?: StringNullableFilter<"taxModel"> | string | null
    periods?: TaxPeriodListRelationFilter
  }, "id">

  export type taxModelOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: taxModelCountOrderByAggregateInput
    _max?: taxModelMaxOrderByAggregateInput
    _min?: taxModelMinOrderByAggregateInput
  }

  export type taxModelScalarWhereWithAggregatesInput = {
    AND?: taxModelScalarWhereWithAggregatesInput | taxModelScalarWhereWithAggregatesInput[]
    OR?: taxModelScalarWhereWithAggregatesInput[]
    NOT?: taxModelScalarWhereWithAggregatesInput | taxModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"taxModel"> | string
    nombre?: StringWithAggregatesFilter<"taxModel"> | string
    descripcion?: StringNullableWithAggregatesFilter<"taxModel"> | string | null
  }

  export type taxPeriodWhereInput = {
    AND?: taxPeriodWhereInput | taxPeriodWhereInput[]
    OR?: taxPeriodWhereInput[]
    NOT?: taxPeriodWhereInput | taxPeriodWhereInput[]
    id?: StringFilter<"taxPeriod"> | string
    modeloId?: StringFilter<"taxPeriod"> | string
    anio?: IntFilter<"taxPeriod"> | number
    trimestre?: IntNullableFilter<"taxPeriod"> | number | null
    mes?: IntNullableFilter<"taxPeriod"> | number | null
    inicioPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
    finPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
    modelo?: XOR<TaxModelScalarRelationFilter, taxModelWhereInput>
    clientTaxes?: ClientTaxListRelationFilter
  }

  export type taxPeriodOrderByWithRelationInput = {
    id?: SortOrder
    modeloId?: SortOrder
    anio?: SortOrder
    trimestre?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    inicioPresentacion?: SortOrder
    finPresentacion?: SortOrder
    modelo?: taxModelOrderByWithRelationInput
    clientTaxes?: clientTaxOrderByRelationAggregateInput
    _relevance?: taxPeriodOrderByRelevanceInput
  }

  export type taxPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: taxPeriodWhereInput | taxPeriodWhereInput[]
    OR?: taxPeriodWhereInput[]
    NOT?: taxPeriodWhereInput | taxPeriodWhereInput[]
    modeloId?: StringFilter<"taxPeriod"> | string
    anio?: IntFilter<"taxPeriod"> | number
    trimestre?: IntNullableFilter<"taxPeriod"> | number | null
    mes?: IntNullableFilter<"taxPeriod"> | number | null
    inicioPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
    finPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
    modelo?: XOR<TaxModelScalarRelationFilter, taxModelWhereInput>
    clientTaxes?: ClientTaxListRelationFilter
  }, "id">

  export type taxPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    modeloId?: SortOrder
    anio?: SortOrder
    trimestre?: SortOrderInput | SortOrder
    mes?: SortOrderInput | SortOrder
    inicioPresentacion?: SortOrder
    finPresentacion?: SortOrder
    _count?: taxPeriodCountOrderByAggregateInput
    _avg?: taxPeriodAvgOrderByAggregateInput
    _max?: taxPeriodMaxOrderByAggregateInput
    _min?: taxPeriodMinOrderByAggregateInput
    _sum?: taxPeriodSumOrderByAggregateInput
  }

  export type taxPeriodScalarWhereWithAggregatesInput = {
    AND?: taxPeriodScalarWhereWithAggregatesInput | taxPeriodScalarWhereWithAggregatesInput[]
    OR?: taxPeriodScalarWhereWithAggregatesInput[]
    NOT?: taxPeriodScalarWhereWithAggregatesInput | taxPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"taxPeriod"> | string
    modeloId?: StringWithAggregatesFilter<"taxPeriod"> | string
    anio?: IntWithAggregatesFilter<"taxPeriod"> | number
    trimestre?: IntNullableWithAggregatesFilter<"taxPeriod"> | number | null
    mes?: IntNullableWithAggregatesFilter<"taxPeriod"> | number | null
    inicioPresentacion?: DateTimeWithAggregatesFilter<"taxPeriod"> | Date | string
    finPresentacion?: DateTimeWithAggregatesFilter<"taxPeriod"> | Date | string
  }

  export type clientTaxWhereInput = {
    AND?: clientTaxWhereInput | clientTaxWhereInput[]
    OR?: clientTaxWhereInput[]
    NOT?: clientTaxWhereInput | clientTaxWhereInput[]
    id?: StringFilter<"clientTax"> | string
    clientId?: StringFilter<"clientTax"> | string
    taxPeriodId?: StringFilter<"clientTax"> | string
    estado?: StringFilter<"clientTax"> | string
    notas?: StringNullableFilter<"clientTax"> | string | null
    displayText?: StringNullableFilter<"clientTax"> | string | null
    colorTag?: StringNullableFilter<"clientTax"> | string | null
    fechaCreacion?: DateTimeFilter<"clientTax"> | Date | string
    fechaActualizacion?: DateTimeFilter<"clientTax"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    period?: XOR<TaxPeriodScalarRelationFilter, taxPeriodWhereInput>
    files?: TaxFileListRelationFilter
  }

  export type clientTaxOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxPeriodId?: SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    displayText?: SortOrderInput | SortOrder
    colorTag?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    client?: ClientOrderByWithRelationInput
    period?: taxPeriodOrderByWithRelationInput
    files?: taxFileOrderByRelationAggregateInput
    _relevance?: clientTaxOrderByRelevanceInput
  }

  export type clientTaxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clientTaxWhereInput | clientTaxWhereInput[]
    OR?: clientTaxWhereInput[]
    NOT?: clientTaxWhereInput | clientTaxWhereInput[]
    clientId?: StringFilter<"clientTax"> | string
    taxPeriodId?: StringFilter<"clientTax"> | string
    estado?: StringFilter<"clientTax"> | string
    notas?: StringNullableFilter<"clientTax"> | string | null
    displayText?: StringNullableFilter<"clientTax"> | string | null
    colorTag?: StringNullableFilter<"clientTax"> | string | null
    fechaCreacion?: DateTimeFilter<"clientTax"> | Date | string
    fechaActualizacion?: DateTimeFilter<"clientTax"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    period?: XOR<TaxPeriodScalarRelationFilter, taxPeriodWhereInput>
    files?: TaxFileListRelationFilter
  }, "id">

  export type clientTaxOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxPeriodId?: SortOrder
    estado?: SortOrder
    notas?: SortOrderInput | SortOrder
    displayText?: SortOrderInput | SortOrder
    colorTag?: SortOrderInput | SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    _count?: clientTaxCountOrderByAggregateInput
    _max?: clientTaxMaxOrderByAggregateInput
    _min?: clientTaxMinOrderByAggregateInput
  }

  export type clientTaxScalarWhereWithAggregatesInput = {
    AND?: clientTaxScalarWhereWithAggregatesInput | clientTaxScalarWhereWithAggregatesInput[]
    OR?: clientTaxScalarWhereWithAggregatesInput[]
    NOT?: clientTaxScalarWhereWithAggregatesInput | clientTaxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"clientTax"> | string
    clientId?: StringWithAggregatesFilter<"clientTax"> | string
    taxPeriodId?: StringWithAggregatesFilter<"clientTax"> | string
    estado?: StringWithAggregatesFilter<"clientTax"> | string
    notas?: StringNullableWithAggregatesFilter<"clientTax"> | string | null
    displayText?: StringNullableWithAggregatesFilter<"clientTax"> | string | null
    colorTag?: StringNullableWithAggregatesFilter<"clientTax"> | string | null
    fechaCreacion?: DateTimeWithAggregatesFilter<"clientTax"> | Date | string
    fechaActualizacion?: DateTimeWithAggregatesFilter<"clientTax"> | Date | string
  }

  export type taxFileWhereInput = {
    AND?: taxFileWhereInput | taxFileWhereInput[]
    OR?: taxFileWhereInput[]
    NOT?: taxFileWhereInput | taxFileWhereInput[]
    id?: StringFilter<"taxFile"> | string
    clientTaxId?: StringFilter<"taxFile"> | string
    nombreArchivo?: StringFilter<"taxFile"> | string
    s3Url?: StringFilter<"taxFile"> | string
    s3Key?: StringFilter<"taxFile"> | string
    tipo?: StringNullableFilter<"taxFile"> | string | null
    tamanio?: IntNullableFilter<"taxFile"> | number | null
    fechaSubida?: DateTimeFilter<"taxFile"> | Date | string
    subidoPor?: StringNullableFilter<"taxFile"> | string | null
    clientTax?: XOR<ClientTaxScalarRelationFilter, clientTaxWhereInput>
  }

  export type taxFileOrderByWithRelationInput = {
    id?: SortOrder
    clientTaxId?: SortOrder
    nombreArchivo?: SortOrder
    s3Url?: SortOrder
    s3Key?: SortOrder
    tipo?: SortOrderInput | SortOrder
    tamanio?: SortOrderInput | SortOrder
    fechaSubida?: SortOrder
    subidoPor?: SortOrderInput | SortOrder
    clientTax?: clientTaxOrderByWithRelationInput
    _relevance?: taxFileOrderByRelevanceInput
  }

  export type taxFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: taxFileWhereInput | taxFileWhereInput[]
    OR?: taxFileWhereInput[]
    NOT?: taxFileWhereInput | taxFileWhereInput[]
    clientTaxId?: StringFilter<"taxFile"> | string
    nombreArchivo?: StringFilter<"taxFile"> | string
    s3Url?: StringFilter<"taxFile"> | string
    s3Key?: StringFilter<"taxFile"> | string
    tipo?: StringNullableFilter<"taxFile"> | string | null
    tamanio?: IntNullableFilter<"taxFile"> | number | null
    fechaSubida?: DateTimeFilter<"taxFile"> | Date | string
    subidoPor?: StringNullableFilter<"taxFile"> | string | null
    clientTax?: XOR<ClientTaxScalarRelationFilter, clientTaxWhereInput>
  }, "id">

  export type taxFileOrderByWithAggregationInput = {
    id?: SortOrder
    clientTaxId?: SortOrder
    nombreArchivo?: SortOrder
    s3Url?: SortOrder
    s3Key?: SortOrder
    tipo?: SortOrderInput | SortOrder
    tamanio?: SortOrderInput | SortOrder
    fechaSubida?: SortOrder
    subidoPor?: SortOrderInput | SortOrder
    _count?: taxFileCountOrderByAggregateInput
    _avg?: taxFileAvgOrderByAggregateInput
    _max?: taxFileMaxOrderByAggregateInput
    _min?: taxFileMinOrderByAggregateInput
    _sum?: taxFileSumOrderByAggregateInput
  }

  export type taxFileScalarWhereWithAggregatesInput = {
    AND?: taxFileScalarWhereWithAggregatesInput | taxFileScalarWhereWithAggregatesInput[]
    OR?: taxFileScalarWhereWithAggregatesInput[]
    NOT?: taxFileScalarWhereWithAggregatesInput | taxFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"taxFile"> | string
    clientTaxId?: StringWithAggregatesFilter<"taxFile"> | string
    nombreArchivo?: StringWithAggregatesFilter<"taxFile"> | string
    s3Url?: StringWithAggregatesFilter<"taxFile"> | string
    s3Key?: StringWithAggregatesFilter<"taxFile"> | string
    tipo?: StringNullableWithAggregatesFilter<"taxFile"> | string | null
    tamanio?: IntNullableWithAggregatesFilter<"taxFile"> | number | null
    fechaSubida?: DateTimeWithAggregatesFilter<"taxFile"> | Date | string
    subidoPor?: StringNullableWithAggregatesFilter<"taxFile"> | string | null
  }

  export type clientTaxRequirementWhereInput = {
    AND?: clientTaxRequirementWhereInput | clientTaxRequirementWhereInput[]
    OR?: clientTaxRequirementWhereInput[]
    NOT?: clientTaxRequirementWhereInput | clientTaxRequirementWhereInput[]
    id?: StringFilter<"clientTaxRequirement"> | string
    clientId?: StringFilter<"clientTaxRequirement"> | string
    impuesto?: StringFilter<"clientTaxRequirement"> | string
    detalle?: StringNullableFilter<"clientTaxRequirement"> | string | null
    taxModelCode?: StringNullableFilter<"clientTaxRequirement"> | string | null
    required?: BoolFilter<"clientTaxRequirement"> | boolean
    note?: StringNullableFilter<"clientTaxRequirement"> | string | null
    colorTag?: StringNullableFilter<"clientTaxRequirement"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }

  export type clientTaxRequirementOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    impuesto?: SortOrder
    detalle?: SortOrderInput | SortOrder
    taxModelCode?: SortOrderInput | SortOrder
    required?: SortOrder
    note?: SortOrderInput | SortOrder
    colorTag?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    _relevance?: clientTaxRequirementOrderByRelevanceInput
  }

  export type clientTaxRequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clientTaxRequirementWhereInput | clientTaxRequirementWhereInput[]
    OR?: clientTaxRequirementWhereInput[]
    NOT?: clientTaxRequirementWhereInput | clientTaxRequirementWhereInput[]
    clientId?: StringFilter<"clientTaxRequirement"> | string
    impuesto?: StringFilter<"clientTaxRequirement"> | string
    detalle?: StringNullableFilter<"clientTaxRequirement"> | string | null
    taxModelCode?: StringNullableFilter<"clientTaxRequirement"> | string | null
    required?: BoolFilter<"clientTaxRequirement"> | boolean
    note?: StringNullableFilter<"clientTaxRequirement"> | string | null
    colorTag?: StringNullableFilter<"clientTaxRequirement"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
  }, "id">

  export type clientTaxRequirementOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    impuesto?: SortOrder
    detalle?: SortOrderInput | SortOrder
    taxModelCode?: SortOrderInput | SortOrder
    required?: SortOrder
    note?: SortOrderInput | SortOrder
    colorTag?: SortOrderInput | SortOrder
    _count?: clientTaxRequirementCountOrderByAggregateInput
    _max?: clientTaxRequirementMaxOrderByAggregateInput
    _min?: clientTaxRequirementMinOrderByAggregateInput
  }

  export type clientTaxRequirementScalarWhereWithAggregatesInput = {
    AND?: clientTaxRequirementScalarWhereWithAggregatesInput | clientTaxRequirementScalarWhereWithAggregatesInput[]
    OR?: clientTaxRequirementScalarWhereWithAggregatesInput[]
    NOT?: clientTaxRequirementScalarWhereWithAggregatesInput | clientTaxRequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"clientTaxRequirement"> | string
    clientId?: StringWithAggregatesFilter<"clientTaxRequirement"> | string
    impuesto?: StringWithAggregatesFilter<"clientTaxRequirement"> | string
    detalle?: StringNullableWithAggregatesFilter<"clientTaxRequirement"> | string | null
    taxModelCode?: StringNullableWithAggregatesFilter<"clientTaxRequirement"> | string | null
    required?: BoolWithAggregatesFilter<"clientTaxRequirement"> | boolean
    note?: StringNullableWithAggregatesFilter<"clientTaxRequirement"> | string | null
    colorTag?: StringNullableWithAggregatesFilter<"clientTaxRequirement"> | string | null
  }

  export type fiscalPeriodWhereInput = {
    AND?: fiscalPeriodWhereInput | fiscalPeriodWhereInput[]
    OR?: fiscalPeriodWhereInput[]
    NOT?: fiscalPeriodWhereInput | fiscalPeriodWhereInput[]
    id?: StringFilter<"fiscalPeriod"> | string
    year?: IntFilter<"fiscalPeriod"> | number
    quarter?: IntFilter<"fiscalPeriod"> | number
    label?: StringFilter<"fiscalPeriod"> | string
    startsAt?: DateTimeFilter<"fiscalPeriod"> | Date | string
    endsAt?: DateTimeFilter<"fiscalPeriod"> | Date | string
    filings?: ClientTaxFilingListRelationFilter
  }

  export type fiscalPeriodOrderByWithRelationInput = {
    id?: SortOrder
    year?: SortOrder
    quarter?: SortOrder
    label?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    filings?: clientTaxFilingOrderByRelationAggregateInput
    _relevance?: fiscalPeriodOrderByRelevanceInput
  }

  export type fiscalPeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: fiscalPeriodWhereInput | fiscalPeriodWhereInput[]
    OR?: fiscalPeriodWhereInput[]
    NOT?: fiscalPeriodWhereInput | fiscalPeriodWhereInput[]
    year?: IntFilter<"fiscalPeriod"> | number
    quarter?: IntFilter<"fiscalPeriod"> | number
    label?: StringFilter<"fiscalPeriod"> | string
    startsAt?: DateTimeFilter<"fiscalPeriod"> | Date | string
    endsAt?: DateTimeFilter<"fiscalPeriod"> | Date | string
    filings?: ClientTaxFilingListRelationFilter
  }, "id">

  export type fiscalPeriodOrderByWithAggregationInput = {
    id?: SortOrder
    year?: SortOrder
    quarter?: SortOrder
    label?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    _count?: fiscalPeriodCountOrderByAggregateInput
    _avg?: fiscalPeriodAvgOrderByAggregateInput
    _max?: fiscalPeriodMaxOrderByAggregateInput
    _min?: fiscalPeriodMinOrderByAggregateInput
    _sum?: fiscalPeriodSumOrderByAggregateInput
  }

  export type fiscalPeriodScalarWhereWithAggregatesInput = {
    AND?: fiscalPeriodScalarWhereWithAggregatesInput | fiscalPeriodScalarWhereWithAggregatesInput[]
    OR?: fiscalPeriodScalarWhereWithAggregatesInput[]
    NOT?: fiscalPeriodScalarWhereWithAggregatesInput | fiscalPeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"fiscalPeriod"> | string
    year?: IntWithAggregatesFilter<"fiscalPeriod"> | number
    quarter?: IntWithAggregatesFilter<"fiscalPeriod"> | number
    label?: StringWithAggregatesFilter<"fiscalPeriod"> | string
    startsAt?: DateTimeWithAggregatesFilter<"fiscalPeriod"> | Date | string
    endsAt?: DateTimeWithAggregatesFilter<"fiscalPeriod"> | Date | string
  }

  export type clientTaxFilingWhereInput = {
    AND?: clientTaxFilingWhereInput | clientTaxFilingWhereInput[]
    OR?: clientTaxFilingWhereInput[]
    NOT?: clientTaxFilingWhereInput | clientTaxFilingWhereInput[]
    id?: StringFilter<"clientTaxFiling"> | string
    clientId?: StringFilter<"clientTaxFiling"> | string
    taxModelCode?: StringFilter<"clientTaxFiling"> | string
    periodId?: StringFilter<"clientTaxFiling"> | string
    status?: StringFilter<"clientTaxFiling"> | string
    notes?: StringNullableFilter<"clientTaxFiling"> | string | null
    presentedAt?: DateTimeNullableFilter<"clientTaxFiling"> | Date | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    period?: XOR<FiscalPeriodNullableScalarRelationFilter, fiscalPeriodWhereInput> | null
  }

  export type clientTaxFilingOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxModelCode?: SortOrder
    periodId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    presentedAt?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    period?: fiscalPeriodOrderByWithRelationInput
    _relevance?: clientTaxFilingOrderByRelevanceInput
  }

  export type clientTaxFilingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_taxModelCode_periodId?: clientTaxFilingClientIdTaxModelCodePeriodIdCompoundUniqueInput
    AND?: clientTaxFilingWhereInput | clientTaxFilingWhereInput[]
    OR?: clientTaxFilingWhereInput[]
    NOT?: clientTaxFilingWhereInput | clientTaxFilingWhereInput[]
    clientId?: StringFilter<"clientTaxFiling"> | string
    taxModelCode?: StringFilter<"clientTaxFiling"> | string
    periodId?: StringFilter<"clientTaxFiling"> | string
    status?: StringFilter<"clientTaxFiling"> | string
    notes?: StringNullableFilter<"clientTaxFiling"> | string | null
    presentedAt?: DateTimeNullableFilter<"clientTaxFiling"> | Date | string | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    period?: XOR<FiscalPeriodNullableScalarRelationFilter, fiscalPeriodWhereInput> | null
  }, "id" | "clientId_taxModelCode_periodId">

  export type clientTaxFilingOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxModelCode?: SortOrder
    periodId?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    presentedAt?: SortOrderInput | SortOrder
    _count?: clientTaxFilingCountOrderByAggregateInput
    _max?: clientTaxFilingMaxOrderByAggregateInput
    _min?: clientTaxFilingMinOrderByAggregateInput
  }

  export type clientTaxFilingScalarWhereWithAggregatesInput = {
    AND?: clientTaxFilingScalarWhereWithAggregatesInput | clientTaxFilingScalarWhereWithAggregatesInput[]
    OR?: clientTaxFilingScalarWhereWithAggregatesInput[]
    NOT?: clientTaxFilingScalarWhereWithAggregatesInput | clientTaxFilingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"clientTaxFiling"> | string
    clientId?: StringWithAggregatesFilter<"clientTaxFiling"> | string
    taxModelCode?: StringWithAggregatesFilter<"clientTaxFiling"> | string
    periodId?: StringWithAggregatesFilter<"clientTaxFiling"> | string
    status?: StringWithAggregatesFilter<"clientTaxFiling"> | string
    notes?: StringNullableWithAggregatesFilter<"clientTaxFiling"> | string | null
    presentedAt?: DateTimeNullableWithAggregatesFilter<"clientTaxFiling"> | Date | string | null
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionCreateInput = {
    id?: string
    resource: string
    action: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUncheckedCreateInput = {
    id?: string
    resource: string
    action: string
    description?: string | null
    createdAt?: Date | string
    roles?: RolePermissionUncheckedCreateNestedManyWithoutPermissionInput
  }

  export type PermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput
  }

  export type PermissionCreateManyInput = {
    id?: string
    resource: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyInput = {
    id?: string
    roleId: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientEmployeeCreateInput = {
    isPrimary?: boolean
    assignedAt?: Date | string
    client: ClientCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutClientsAssignedInput
  }

  export type ClientEmployeeUncheckedCreateInput = {
    clientId: string
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type ClientEmployeeUpdateInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutClientsAssignedNestedInput
  }

  export type ClientEmployeeUncheckedUpdateInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmployeeCreateManyInput = {
    clientId: string
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type ClientEmployeeUpdateManyMutationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmployeeUncheckedUpdateManyInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    cliente?: ClientCreateNestedOneWithoutTasksInput
    asignado?: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    clienteId?: string | null
    asignadoA?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneWithoutTasksNestedInput
    asignado?: UserUpdateOneWithoutTasksAssignedNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
    asignadoA?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    clienteId?: string | null
    asignadoA?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
    asignadoA?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualCreateInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    autor: UserCreateNestedOneWithoutManualsAuthoredInput
    attachments?: ManualAttachmentCreateNestedManyWithoutManualInput
    versions?: ManualVersionCreateNestedManyWithoutManualInput
  }

  export type ManualUncheckedCreateInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    autorId: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    attachments?: ManualAttachmentUncheckedCreateNestedManyWithoutManualInput
    versions?: ManualVersionUncheckedCreateNestedManyWithoutManualInput
  }

  export type ManualUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: UserUpdateOneRequiredWithoutManualsAuthoredNestedInput
    attachments?: ManualAttachmentUpdateManyWithoutManualNestedInput
    versions?: ManualVersionUpdateManyWithoutManualNestedInput
  }

  export type ManualUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: ManualAttachmentUncheckedUpdateManyWithoutManualNestedInput
    versions?: ManualVersionUncheckedUpdateManyWithoutManualNestedInput
  }

  export type ManualCreateManyInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    autorId: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
  }

  export type ManualUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ManualUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ManualAttachmentCreateInput = {
    id?: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
    manual: ManualCreateNestedOneWithoutAttachmentsInput
  }

  export type ManualAttachmentUncheckedCreateInput = {
    id?: string
    manualId: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type ManualAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manual?: ManualUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type ManualAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    manualId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualAttachmentCreateManyInput = {
    id?: string
    manualId: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type ManualAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    manualId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionCreateInput = {
    id?: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
    manual: ManualCreateNestedOneWithoutVersionsInput
  }

  export type ManualVersionUncheckedCreateInput = {
    id?: string
    manualId: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ManualVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    manual?: ManualUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type ManualVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    manualId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionCreateManyInput = {
    id?: string
    manualId: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ManualVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    manualId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    id?: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
    usuario: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    usuarioId: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    usuarioId: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateInput = {
    id?: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
    usuario: UserCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateInput = {
    id?: string
    usuarioId: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
  }

  export type AuditTrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UserUpdateOneRequiredWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateManyInput = {
    id?: string
    usuarioId: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
  }

  export type AuditTrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SmtpConfigCreateInput = {
    id?: string
    host: string
    port: number
    user: string
    password: string
    secure?: boolean
  }

  export type SmtpConfigUncheckedCreateInput = {
    id?: string
    host: string
    port: number
    user: string
    password: string
    secure?: boolean
  }

  export type SmtpConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secure?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SmtpConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secure?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SmtpConfigCreateManyInput = {
    id?: string
    host: string
    port: number
    user: string
    password: string
    secure?: boolean
  }

  export type SmtpConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secure?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SmtpConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    secure?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobRunCreateInput = {
    id?: string
    jobName: string
    startedAt: Date | string
    completedAt?: Date | string | null
    status: string
    recordsProcessed?: number | null
    errorMessage?: string | null
    metadata?: string | null
  }

  export type JobRunUncheckedCreateInput = {
    id?: string
    jobName: string
    startedAt: Date | string
    completedAt?: Date | string | null
    status: string
    recordsProcessed?: number | null
    errorMessage?: string | null
    metadata?: string | null
  }

  export type JobRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRunCreateManyInput = {
    id?: string
    jobName: string
    startedAt: Date | string
    completedAt?: Date | string | null
    status: string
    recordsProcessed?: number | null
    errorMessage?: string | null
    metadata?: string | null
  }

  export type JobRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jobName?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    recordsProcessed?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemSettingsCreateInput = {
    id?: string
    registrationEnabled?: boolean
    updatedAt?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    registrationEnabled?: boolean
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    registrationEnabled?: boolean
    updatedAt?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationEnabled?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMTPAccountCreateInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
    creador?: UserCreateNestedOneWithoutSmtpAccountsCreatedInput
    logs?: NotificationLogCreateNestedManyWithoutSmtpAccountInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountUncheckedCreateInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: string | null
    fechaCreacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutSmtpAccountInput
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutSmtpAccountsCreatedNestedInput
    logs?: NotificationLogUpdateManyWithoutSmtpAccountNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutSmtpAccountNestedInput
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountCreateManyInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: string | null
    fechaCreacion?: Date | string
  }

  export type SMTPAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMTPAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateCreateInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    creador?: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    logs?: NotificationLogCreateNestedManyWithoutPlantillaInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateUncheckedCreateInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    creadoPor?: string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutPlantillaInput
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutNotificationTemplatesCreatedNestedInput
    logs?: NotificationLogUpdateManyWithoutPlantillaNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutPlantillaNestedInput
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateCreateManyInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    creadoPor?: string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateInput = {
    id?: string
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateCreateNestedOneWithoutLogsInput
    smtpAccount?: SMTPAccountCreateNestedOneWithoutLogsInput
    enviador?: UserCreateNestedOneWithoutNotificationsSentInput
  }

  export type NotificationLogUncheckedCreateInput = {
    id?: string
    plantillaId?: string | null
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateUpdateOneWithoutLogsNestedInput
    smtpAccount?: SMTPAccountUpdateOneWithoutLogsNestedInput
    enviador?: UserUpdateOneWithoutNotificationsSentNestedInput
  }

  export type NotificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogCreateManyInput = {
    id?: string
    plantillaId?: string | null
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationCreateInput = {
    id?: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
    plantilla: NotificationTemplateCreateNestedOneWithoutScheduledInput
    smtpAccount?: SMTPAccountCreateNestedOneWithoutScheduledInput
    creador?: UserCreateNestedOneWithoutScheduledNotificationsCreatedInput
  }

  export type ScheduledNotificationUncheckedCreateInput = {
    id?: string
    plantillaId: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type ScheduledNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    plantilla?: NotificationTemplateUpdateOneRequiredWithoutScheduledNestedInput
    smtpAccount?: SMTPAccountUpdateOneWithoutScheduledNestedInput
    creador?: UserUpdateOneWithoutScheduledNotificationsCreatedNestedInput
  }

  export type ScheduledNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationCreateManyInput = {
    id?: string
    plantillaId: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type ScheduledNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isEditable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isEditable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    isEditable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isEditable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemBackupCreateInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutBackupsCreatedInput
  }

  export type SystemBackupUncheckedCreateInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemBackupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutBackupsCreatedNestedInput
  }

  export type SystemBackupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemBackupCreateManyInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemBackupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemBackupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateCreateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    initiator?: UserCreateNestedOneWithoutUpdatesInitiatedInput
  }

  export type SystemUpdateUncheckedCreateInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    initiatedBy?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    initiator?: UserUpdateOneWithoutUpdatesInitiatedNestedInput
  }

  export type SystemUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateCreateManyInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    initiatedBy?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    initiatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StorageConfigCreateInput = {
    id?: string
    type?: $Enums.StorageType
    name: string
    host?: string | null
    port?: number | null
    username?: string | null
    encryptedPassword?: string | null
    basePath?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUncheckedCreateInput = {
    id?: string
    type?: $Enums.StorageType
    name: string
    host?: string | null
    port?: number | null
    username?: string | null
    encryptedPassword?: string | null
    basePath?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigCreateManyInput = {
    id?: string
    type?: $Enums.StorageType
    name: string
    host?: string | null
    port?: number | null
    username?: string | null
    encryptedPassword?: string | null
    basePath?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumStorageTypeFieldUpdateOperationsInput | $Enums.StorageType
    name?: StringFieldUpdateOperationsInput | string
    host?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    encryptedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    basePath?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpuestoCreateInput = {
    id?: string
    nombre: string
    modelo: string
    descripcion?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obligaciones?: ObligacionFiscalCreateNestedManyWithoutImpuestoInput
  }

  export type ImpuestoUncheckedCreateInput = {
    id?: string
    nombre: string
    modelo: string
    descripcion?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    obligaciones?: ObligacionFiscalUncheckedCreateNestedManyWithoutImpuestoInput
  }

  export type ImpuestoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obligaciones?: ObligacionFiscalUpdateManyWithoutImpuestoNestedInput
  }

  export type ImpuestoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obligaciones?: ObligacionFiscalUncheckedUpdateManyWithoutImpuestoNestedInput
  }

  export type ImpuestoCreateManyInput = {
    id?: string
    nombre: string
    modelo: string
    descripcion?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpuestoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpuestoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObligacionFiscalCreateInput = {
    id?: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClientCreateNestedOneWithoutObligacionesFiscalesInput
    impuesto: ImpuestoCreateNestedOneWithoutObligacionesInput
    declaraciones?: DeclaracionCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalUncheckedCreateInput = {
    id?: string
    clienteId: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    declaraciones?: DeclaracionUncheckedCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutObligacionesFiscalesNestedInput
    impuesto?: ImpuestoUpdateOneRequiredWithoutObligacionesNestedInput
    declaraciones?: DeclaracionUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    impuestoId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    declaraciones?: DeclaracionUncheckedUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalCreateManyInput = {
    id?: string
    clienteId: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObligacionFiscalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObligacionFiscalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    impuestoId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarioAEATCreateInput = {
    id?: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date | string
    fechaFin: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    declaraciones?: DeclaracionCreateNestedManyWithoutCalendarioInput
  }

  export type CalendarioAEATUncheckedCreateInput = {
    id?: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date | string
    fechaFin: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    declaraciones?: DeclaracionUncheckedCreateNestedManyWithoutCalendarioInput
  }

  export type CalendarioAEATUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    declaraciones?: DeclaracionUpdateManyWithoutCalendarioNestedInput
  }

  export type CalendarioAEATUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    declaraciones?: DeclaracionUncheckedUpdateManyWithoutCalendarioNestedInput
  }

  export type CalendarioAEATCreateManyInput = {
    id?: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date | string
    fechaFin: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarioAEATUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarioAEATUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionCreateInput = {
    id?: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obligacion: ObligacionFiscalCreateNestedOneWithoutDeclaracionesInput
    calendario: CalendarioAEATCreateNestedOneWithoutDeclaracionesInput
  }

  export type DeclaracionUncheckedCreateInput = {
    id?: string
    obligacionId: string
    calendarioId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obligacion?: ObligacionFiscalUpdateOneRequiredWithoutDeclaracionesNestedInput
    calendario?: CalendarioAEATUpdateOneRequiredWithoutDeclaracionesNestedInput
  }

  export type DeclaracionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    obligacionId?: StringFieldUpdateOperationsInput | string
    calendarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionCreateManyInput = {
    id?: string
    obligacionId: string
    calendarioId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    obligacionId?: StringFieldUpdateOperationsInput | string
    calendarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateInput = {
    id?: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
    cliente: ClientCreateNestedOneWithoutNotificacionesInput
  }

  export type NotificacionUncheckedCreateInput = {
    id?: string
    clienteId: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutNotificacionesNestedInput
  }

  export type NotificacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionCreateManyInput = {
    id?: string
    clienteId: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxModelCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    periods?: taxPeriodCreateNestedManyWithoutModeloInput
  }

  export type taxModelUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    periods?: taxPeriodUncheckedCreateNestedManyWithoutModeloInput
  }

  export type taxModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: taxPeriodUpdateManyWithoutModeloNestedInput
  }

  export type taxModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    periods?: taxPeriodUncheckedUpdateManyWithoutModeloNestedInput
  }

  export type taxModelCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type taxModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxPeriodCreateInput = {
    id?: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
    modelo: taxModelCreateNestedOneWithoutPeriodsInput
    clientTaxes?: clientTaxCreateNestedManyWithoutPeriodInput
  }

  export type taxPeriodUncheckedCreateInput = {
    id?: string
    modeloId: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type taxPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    modelo?: taxModelUpdateOneRequiredWithoutPeriodsNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutPeriodNestedInput
  }

  export type taxPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloId?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type taxPeriodCreateManyInput = {
    id?: string
    modeloId: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
  }

  export type taxPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloId?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxCreateInput = {
    id?: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    client: ClientCreateNestedOneWithoutClientTaxesInput
    period: taxPeriodCreateNestedOneWithoutClientTaxesInput
    files?: taxFileCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxUncheckedCreateInput = {
    id?: string
    clientId: string
    taxPeriodId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    files?: taxFileUncheckedCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientTaxesNestedInput
    period?: taxPeriodUpdateOneRequiredWithoutClientTaxesNestedInput
    files?: taxFileUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxPeriodId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: taxFileUncheckedUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxCreateManyInput = {
    id?: string
    clientId: string
    taxPeriodId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
  }

  export type clientTaxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxPeriodId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxFileCreateInput = {
    id?: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
    clientTax: clientTaxCreateNestedOneWithoutFilesInput
  }

  export type taxFileUncheckedCreateInput = {
    id?: string
    clientTaxId: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
  }

  export type taxFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    clientTax?: clientTaxUpdateOneRequiredWithoutFilesNestedInput
  }

  export type taxFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientTaxId?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxFileCreateManyInput = {
    id?: string
    clientTaxId: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
  }

  export type taxFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientTaxId?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxRequirementCreateInput = {
    id?: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
    client: ClientCreateNestedOneWithoutClientTaxRequirementsInput
  }

  export type clientTaxRequirementUncheckedCreateInput = {
    id?: string
    clientId: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
  }

  export type clientTaxRequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutClientTaxRequirementsNestedInput
  }

  export type clientTaxRequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxRequirementCreateManyInput = {
    id?: string
    clientId: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
  }

  export type clientTaxRequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxRequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type fiscalPeriodCreateInput = {
    id?: string
    year: number
    quarter: number
    label: string
    startsAt: Date | string
    endsAt: Date | string
    filings?: clientTaxFilingCreateNestedManyWithoutPeriodInput
  }

  export type fiscalPeriodUncheckedCreateInput = {
    id?: string
    year: number
    quarter: number
    label: string
    startsAt: Date | string
    endsAt: Date | string
    filings?: clientTaxFilingUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type fiscalPeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filings?: clientTaxFilingUpdateManyWithoutPeriodNestedInput
  }

  export type fiscalPeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    filings?: clientTaxFilingUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type fiscalPeriodCreateManyInput = {
    id?: string
    year: number
    quarter: number
    label: string
    startsAt: Date | string
    endsAt: Date | string
  }

  export type fiscalPeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fiscalPeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxFilingCreateInput = {
    id?: string
    taxModelCode: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
    client?: ClientCreateNestedOneWithoutTaxFilingsInput
    period?: fiscalPeriodCreateNestedOneWithoutFilingsInput
  }

  export type clientTaxFilingUncheckedCreateInput = {
    id?: string
    clientId: string
    taxModelCode: string
    periodId: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type clientTaxFilingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneWithoutTaxFilingsNestedInput
    period?: fiscalPeriodUpdateOneWithoutFilingsNestedInput
  }

  export type clientTaxFilingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientTaxFilingCreateManyInput = {
    id?: string
    clientId: string
    taxModelCode: string
    periodId: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type clientTaxFilingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientTaxFilingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type RolePermissionListRelationFilter = {
    every?: RolePermissionWhereInput
    some?: RolePermissionWhereInput
    none?: RolePermissionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleOrderByRelevanceInput = {
    fields: RoleOrderByRelevanceFieldEnum | RoleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isSystem?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PermissionOrderByRelevanceInput = {
    fields: PermissionOrderByRelevanceFieldEnum | PermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PermissionResourceActionCompoundUniqueInput = {
    resource: string
    action: string
  }

  export type PermissionCountOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    id?: SortOrder
    resource?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type PermissionScalarRelationFilter = {
    is?: PermissionWhereInput
    isNot?: PermissionWhereInput
  }

  export type RolePermissionOrderByRelevanceInput = {
    fields: RolePermissionOrderByRelevanceFieldEnum | RolePermissionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RolePermissionRoleIdPermissionIdCompoundUniqueInput = {
    roleId: string
    permissionId: string
  }

  export type RolePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RolePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    permissionId?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleNullableScalarRelationFilter = {
    is?: RoleWhereInput | null
    isNot?: RoleWhereInput | null
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type ClientEmployeeListRelationFilter = {
    every?: ClientEmployeeWhereInput
    some?: ClientEmployeeWhereInput
    none?: ClientEmployeeWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ManualListRelationFilter = {
    every?: ManualWhereInput
    some?: ManualWhereInput
    none?: ManualWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type AuditTrailListRelationFilter = {
    every?: AuditTrailWhereInput
    some?: AuditTrailWhereInput
    none?: AuditTrailWhereInput
  }

  export type SMTPAccountListRelationFilter = {
    every?: SMTPAccountWhereInput
    some?: SMTPAccountWhereInput
    none?: SMTPAccountWhereInput
  }

  export type NotificationTemplateListRelationFilter = {
    every?: NotificationTemplateWhereInput
    some?: NotificationTemplateWhereInput
    none?: NotificationTemplateWhereInput
  }

  export type NotificationLogListRelationFilter = {
    every?: NotificationLogWhereInput
    some?: NotificationLogWhereInput
    none?: NotificationLogWhereInput
  }

  export type ScheduledNotificationListRelationFilter = {
    every?: ScheduledNotificationWhereInput
    some?: ScheduledNotificationWhereInput
    none?: ScheduledNotificationWhereInput
  }

  export type SystemBackupListRelationFilter = {
    every?: SystemBackupWhereInput
    some?: SystemBackupWhereInput
    none?: SystemBackupWhereInput
  }

  export type SystemUpdateListRelationFilter = {
    every?: SystemUpdateWhereInput
    some?: SystemUpdateWhereInput
    none?: SystemUpdateWhereInput
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientEmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SMTPAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduledNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemBackupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    roleId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ClientTaxListRelationFilter = {
    every?: clientTaxWhereInput
    some?: clientTaxWhereInput
    none?: clientTaxWhereInput
  }

  export type ClientTaxRequirementListRelationFilter = {
    every?: clientTaxRequirementWhereInput
    some?: clientTaxRequirementWhereInput
    none?: clientTaxRequirementWhereInput
  }

  export type ClientTaxFilingListRelationFilter = {
    every?: clientTaxFilingWhereInput
    some?: clientTaxFilingWhereInput
    none?: clientTaxFilingWhereInput
  }

  export type ObligacionFiscalListRelationFilter = {
    every?: ObligacionFiscalWhereInput
    some?: ObligacionFiscalWhereInput
    none?: ObligacionFiscalWhereInput
  }

  export type NotificacionListRelationFilter = {
    every?: NotificacionWhereInput
    some?: NotificacionWhereInput
    none?: NotificacionWhereInput
  }

  export type clientTaxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientTaxRequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientTaxFilingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObligacionFiscalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelevanceInput = {
    fields: ClientOrderByRelevanceFieldEnum | ClientOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    razonSocial?: SortOrder
    nifCif?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fechaAlta?: SortOrder
    fechaBaja?: SortOrder
    responsableAsignado?: SortOrder
    taxModels?: SortOrder
    isActive?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    razonSocial?: SortOrder
    nifCif?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fechaAlta?: SortOrder
    fechaBaja?: SortOrder
    responsableAsignado?: SortOrder
    isActive?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    razonSocial?: SortOrder
    nifCif?: SortOrder
    tipo?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    direccion?: SortOrder
    fechaAlta?: SortOrder
    fechaBaja?: SortOrder
    responsableAsignado?: SortOrder
    isActive?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClientEmployeeOrderByRelevanceInput = {
    fields: ClientEmployeeOrderByRelevanceFieldEnum | ClientEmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ClientEmployeeClientIdUserIdCompoundUniqueInput = {
    clientId: string
    userId: string
  }

  export type ClientEmployeeCountOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type ClientEmployeeMaxOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type ClientEmployeeMinOrderByAggregateInput = {
    clientId?: SortOrder
    userId?: SortOrder
    isPrimary?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type EnumTaskVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskVisibility | EnumTaskVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskVisibility[]
    notIn?: $Enums.TaskVisibility[]
    not?: NestedEnumTaskVisibilityFilter<$PrismaModel> | $Enums.TaskVisibility
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type TaskOrderByRelevanceInput = {
    fields: TaskOrderByRelevanceFieldEnum | TaskOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    clienteId?: SortOrder
    asignadoA?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    visibilidad?: SortOrder
    fechaVencimiento?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    clienteId?: SortOrder
    asignadoA?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    visibilidad?: SortOrder
    fechaVencimiento?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    clienteId?: SortOrder
    asignadoA?: SortOrder
    prioridad?: SortOrder
    estado?: SortOrder
    visibilidad?: SortOrder
    fechaVencimiento?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type EnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumTaskVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskVisibility | EnumTaskVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskVisibility[]
    notIn?: $Enums.TaskVisibility[]
    not?: NestedEnumTaskVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.TaskVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskVisibilityFilter<$PrismaModel>
    _max?: NestedEnumTaskVisibilityFilter<$PrismaModel>
  }

  export type EnumManualStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ManualStatus | EnumManualStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ManualStatus[]
    notIn?: $Enums.ManualStatus[]
    not?: NestedEnumManualStatusFilter<$PrismaModel> | $Enums.ManualStatus
  }

  export type ManualAttachmentListRelationFilter = {
    every?: ManualAttachmentWhereInput
    some?: ManualAttachmentWhereInput
    none?: ManualAttachmentWhereInput
  }

  export type ManualVersionListRelationFilter = {
    every?: ManualVersionWhereInput
    some?: ManualVersionWhereInput
    none?: ManualVersionWhereInput
  }

  export type ManualAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManualOrderByRelevanceInput = {
    fields: ManualOrderByRelevanceFieldEnum | ManualOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ManualCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    autorId?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    fechaPublicacion?: SortOrder
  }

  export type ManualMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    autorId?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    fechaPublicacion?: SortOrder
  }

  export type ManualMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    autorId?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    status?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
    fechaPublicacion?: SortOrder
  }

  export type EnumManualStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManualStatus | EnumManualStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ManualStatus[]
    notIn?: $Enums.ManualStatus[]
    not?: NestedEnumManualStatusWithAggregatesFilter<$PrismaModel> | $Enums.ManualStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManualStatusFilter<$PrismaModel>
    _max?: NestedEnumManualStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ManualScalarRelationFilter = {
    is?: ManualWhereInput
    isNot?: ManualWhereInput
  }

  export type ManualAttachmentOrderByRelevanceInput = {
    fields: ManualAttachmentOrderByRelevanceFieldEnum | ManualAttachmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ManualAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ManualAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ManualAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ManualAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    fileName?: SortOrder
    originalName?: SortOrder
    filePath?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ManualAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ManualVersionOrderByRelevanceInput = {
    fields: ManualVersionOrderByRelevanceFieldEnum | ManualVersionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ManualVersionManualIdVersionNumberCompoundUniqueInput = {
    manualId: string
    versionNumber: number
  }

  export type ManualVersionCountOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    versionNumber?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ManualVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    versionNumber?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualVersionMinOrderByAggregateInput = {
    id?: SortOrder
    manualId?: SortOrder
    versionNumber?: SortOrder
    titulo?: SortOrder
    contenidoHtml?: SortOrder
    etiquetas?: SortOrder
    categoria?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ManualVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ActivityLogOrderByRelevanceInput = {
    fields: ActivityLogOrderByRelevanceFieldEnum | ActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    modulo?: SortOrder
    detalles?: SortOrder
    fecha?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    modulo?: SortOrder
    detalles?: SortOrder
    fecha?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    modulo?: SortOrder
    detalles?: SortOrder
    fecha?: SortOrder
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type AuditTrailOrderByRelevanceInput = {
    fields: AuditTrailOrderByRelevanceFieldEnum | AuditTrailOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    valorAnterior?: SortOrder
    valorNuevo?: SortOrder
    cambios?: SortOrder
    requestId?: SortOrder
    fecha?: SortOrder
  }

  export type AuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    valorAnterior?: SortOrder
    valorNuevo?: SortOrder
    cambios?: SortOrder
    requestId?: SortOrder
    fecha?: SortOrder
  }

  export type AuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    registroId?: SortOrder
    valorAnterior?: SortOrder
    valorNuevo?: SortOrder
    cambios?: SortOrder
    requestId?: SortOrder
    fecha?: SortOrder
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type SmtpConfigOrderByRelevanceInput = {
    fields: SmtpConfigOrderByRelevanceFieldEnum | SmtpConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SmtpConfigCountOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    secure?: SortOrder
  }

  export type SmtpConfigAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type SmtpConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    secure?: SortOrder
  }

  export type SmtpConfigMinOrderByAggregateInput = {
    id?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    secure?: SortOrder
  }

  export type SmtpConfigSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type JobRunOrderByRelevanceInput = {
    fields: JobRunOrderByRelevanceFieldEnum | JobRunOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type JobRunCountOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
  }

  export type JobRunAvgOrderByAggregateInput = {
    recordsProcessed?: SortOrder
  }

  export type JobRunMaxOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
  }

  export type JobRunMinOrderByAggregateInput = {
    id?: SortOrder
    jobName?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    recordsProcessed?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
  }

  export type JobRunSumOrderByAggregateInput = {
    recordsProcessed?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SystemSettingsOrderByRelevanceInput = {
    fields: SystemSettingsOrderByRelevanceFieldEnum | SystemSettingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    registrationEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    registrationEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    registrationEnabled?: SortOrder
    updatedAt?: SortOrder
  }

  export type SMTPAccountOrderByRelevanceInput = {
    fields: SMTPAccountOrderByRelevanceFieldEnum | SMTPAccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SMTPAccountCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    isPredeterminada?: SortOrder
    activa?: SortOrder
    creadaPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type SMTPAccountAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type SMTPAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    isPredeterminada?: SortOrder
    activa?: SortOrder
    creadaPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type SMTPAccountMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    host?: SortOrder
    port?: SortOrder
    user?: SortOrder
    password?: SortOrder
    isPredeterminada?: SortOrder
    activa?: SortOrder
    creadaPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type SMTPAccountSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type NotificationTemplateOrderByRelevanceInput = {
    fields: NotificationTemplateOrderByRelevanceFieldEnum | NotificationTemplateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    asunto?: SortOrder
    contenidoHTML?: SortOrder
    variables?: SortOrder
    tipo?: SortOrder
    activa?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    asunto?: SortOrder
    contenidoHTML?: SortOrder
    tipo?: SortOrder
    activa?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    asunto?: SortOrder
    contenidoHTML?: SortOrder
    tipo?: SortOrder
    activa?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NotificationTemplateNullableScalarRelationFilter = {
    is?: NotificationTemplateWhereInput | null
    isNot?: NotificationTemplateWhereInput | null
  }

  export type SMTPAccountNullableScalarRelationFilter = {
    is?: SMTPAccountWhereInput | null
    isNot?: SMTPAccountWhereInput | null
  }

  export type NotificationLogOrderByRelevanceInput = {
    fields: NotificationLogOrderByRelevanceFieldEnum | NotificationLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    destinatarios?: SortOrder
    asunto?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    fechaEnvio?: SortOrder
    enviadoPor?: SortOrder
    metadata?: SortOrder
  }

  export type NotificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    asunto?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    fechaEnvio?: SortOrder
    enviadoPor?: SortOrder
  }

  export type NotificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    asunto?: SortOrder
    contenido?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    fechaEnvio?: SortOrder
    enviadoPor?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type NotificationTemplateScalarRelationFilter = {
    is?: NotificationTemplateWhereInput
    isNot?: NotificationTemplateWhereInput
  }

  export type ScheduledNotificationOrderByRelevanceInput = {
    fields: ScheduledNotificationOrderByRelevanceFieldEnum | ScheduledNotificationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ScheduledNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    destinatariosSeleccionados?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    recurrencia?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ScheduledNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    recurrencia?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type ScheduledNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    plantillaId?: SortOrder
    smtpAccountId?: SortOrder
    fechaProgramada?: SortOrder
    estado?: SortOrder
    recurrencia?: SortOrder
    creadoPor?: SortOrder
    fechaCreacion?: SortOrder
  }

  export type SystemConfigOrderByRelevanceInput = {
    fields: SystemConfigOrderByRelevanceFieldEnum | SystemConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isEditable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isEditable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    isEditable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type EnumBackupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupStatus | EnumBackupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackupStatus[]
    notIn?: $Enums.BackupStatus[]
    not?: NestedEnumBackupStatusFilter<$PrismaModel> | $Enums.BackupStatus
  }

  export type SystemBackupOrderByRelevanceInput = {
    fields: SystemBackupOrderByRelevanceFieldEnum | SystemBackupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemBackupCountOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dbFile?: SortOrder
    filesFile?: SortOrder
    dbSize?: SortOrder
    filesSize?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemBackupAvgOrderByAggregateInput = {
    dbSize?: SortOrder
    filesSize?: SortOrder
  }

  export type SystemBackupMaxOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dbFile?: SortOrder
    filesFile?: SortOrder
    dbSize?: SortOrder
    filesSize?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemBackupMinOrderByAggregateInput = {
    id?: SortOrder
    version?: SortOrder
    dbFile?: SortOrder
    filesFile?: SortOrder
    dbSize?: SortOrder
    filesSize?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemBackupSumOrderByAggregateInput = {
    dbSize?: SortOrder
    filesSize?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type EnumBackupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupStatus | EnumBackupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackupStatus[]
    notIn?: $Enums.BackupStatus[]
    not?: NestedEnumBackupStatusWithAggregatesFilter<$PrismaModel> | $Enums.BackupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackupStatusFilter<$PrismaModel>
    _max?: NestedEnumBackupStatusFilter<$PrismaModel>
  }

  export type EnumUpdateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateStatus | EnumUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateStatus[]
    notIn?: $Enums.UpdateStatus[]
    not?: NestedEnumUpdateStatusFilter<$PrismaModel> | $Enums.UpdateStatus
  }

  export type SystemUpdateOrderByRelevanceInput = {
    fields: SystemUpdateOrderByRelevanceFieldEnum | SystemUpdateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    status?: SortOrder
    logs?: SortOrder
    backupId?: SortOrder
    errorMessage?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    status?: SortOrder
    backupId?: SortOrder
    errorMessage?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type SystemUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    fromVersion?: SortOrder
    toVersion?: SortOrder
    status?: SortOrder
    backupId?: SortOrder
    errorMessage?: SortOrder
    initiatedBy?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type EnumUpdateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateStatus | EnumUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateStatus[]
    notIn?: $Enums.UpdateStatus[]
    not?: NestedEnumUpdateStatusWithAggregatesFilter<$PrismaModel> | $Enums.UpdateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUpdateStatusFilter<$PrismaModel>
    _max?: NestedEnumUpdateStatusFilter<$PrismaModel>
  }

  export type EnumStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeFilter<$PrismaModel> | $Enums.StorageType
  }

  export type StorageConfigOrderByRelevanceInput = {
    fields: StorageConfigOrderByRelevanceFieldEnum | StorageConfigOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StorageConfigCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    encryptedPassword?: SortOrder
    basePath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type StorageConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    encryptedPassword?: SortOrder
    basePath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    host?: SortOrder
    port?: SortOrder
    username?: SortOrder
    encryptedPassword?: SortOrder
    basePath?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageConfigSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type EnumStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumStorageTypeFilter<$PrismaModel>
  }

  export type ImpuestoOrderByRelevanceInput = {
    fields: ImpuestoOrderByRelevanceFieldEnum | ImpuestoOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImpuestoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    modelo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpuestoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    modelo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ImpuestoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    modelo?: SortOrder
    descripcion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPeriodicidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Periodicidad | EnumPeriodicidadFieldRefInput<$PrismaModel>
    in?: $Enums.Periodicidad[]
    notIn?: $Enums.Periodicidad[]
    not?: NestedEnumPeriodicidadFilter<$PrismaModel> | $Enums.Periodicidad
  }

  export type ImpuestoScalarRelationFilter = {
    is?: ImpuestoWhereInput
    isNot?: ImpuestoWhereInput
  }

  export type DeclaracionListRelationFilter = {
    every?: DeclaracionWhereInput
    some?: DeclaracionWhereInput
    none?: DeclaracionWhereInput
  }

  export type DeclaracionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObligacionFiscalOrderByRelevanceInput = {
    fields: ObligacionFiscalOrderByRelevanceFieldEnum | ObligacionFiscalOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ObligacionFiscalCountOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    impuestoId?: SortOrder
    periodicidad?: SortOrder
    diaVencimiento?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    observaciones?: SortOrder
    fechaAsignacion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObligacionFiscalAvgOrderByAggregateInput = {
    diaVencimiento?: SortOrder
  }

  export type ObligacionFiscalMaxOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    impuestoId?: SortOrder
    periodicidad?: SortOrder
    diaVencimiento?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    observaciones?: SortOrder
    fechaAsignacion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObligacionFiscalMinOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    impuestoId?: SortOrder
    periodicidad?: SortOrder
    diaVencimiento?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    observaciones?: SortOrder
    fechaAsignacion?: SortOrder
    activo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ObligacionFiscalSumOrderByAggregateInput = {
    diaVencimiento?: SortOrder
  }

  export type EnumPeriodicidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Periodicidad | EnumPeriodicidadFieldRefInput<$PrismaModel>
    in?: $Enums.Periodicidad[]
    notIn?: $Enums.Periodicidad[]
    not?: NestedEnumPeriodicidadWithAggregatesFilter<$PrismaModel> | $Enums.Periodicidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeriodicidadFilter<$PrismaModel>
    _max?: NestedEnumPeriodicidadFilter<$PrismaModel>
  }

  export type CalendarioAEATOrderByRelevanceInput = {
    fields: CalendarioAEATOrderByRelevanceFieldEnum | CalendarioAEATOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CalendarioAEATModeloPeriodicidadPeriodoContableCompoundUniqueInput = {
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
  }

  export type CalendarioAEATCountOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    periodicidad?: SortOrder
    periodoContable?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarioAEATMaxOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    periodicidad?: SortOrder
    periodoContable?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CalendarioAEATMinOrderByAggregateInput = {
    id?: SortOrder
    modelo?: SortOrder
    periodicidad?: SortOrder
    periodoContable?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEstadoDeclaracionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDeclaracion | EnumEstadoDeclaracionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDeclaracion[]
    notIn?: $Enums.EstadoDeclaracion[]
    not?: NestedEnumEstadoDeclaracionFilter<$PrismaModel> | $Enums.EstadoDeclaracion
  }

  export type ObligacionFiscalScalarRelationFilter = {
    is?: ObligacionFiscalWhereInput
    isNot?: ObligacionFiscalWhereInput
  }

  export type CalendarioAEATScalarRelationFilter = {
    is?: CalendarioAEATWhereInput
    isNot?: CalendarioAEATWhereInput
  }

  export type DeclaracionOrderByRelevanceInput = {
    fields: DeclaracionOrderByRelevanceFieldEnum | DeclaracionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type DeclaracionCountOrderByAggregateInput = {
    id?: SortOrder
    obligacionId?: SortOrder
    calendarioId?: SortOrder
    estado?: SortOrder
    fechaPresentacion?: SortOrder
    archivoPdf?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclaracionMaxOrderByAggregateInput = {
    id?: SortOrder
    obligacionId?: SortOrder
    calendarioId?: SortOrder
    estado?: SortOrder
    fechaPresentacion?: SortOrder
    archivoPdf?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeclaracionMinOrderByAggregateInput = {
    id?: SortOrder
    obligacionId?: SortOrder
    calendarioId?: SortOrder
    estado?: SortOrder
    fechaPresentacion?: SortOrder
    archivoPdf?: SortOrder
    notas?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEstadoDeclaracionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDeclaracion | EnumEstadoDeclaracionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDeclaracion[]
    notIn?: $Enums.EstadoDeclaracion[]
    not?: NestedEnumEstadoDeclaracionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDeclaracion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDeclaracionFilter<$PrismaModel>
    _max?: NestedEnumEstadoDeclaracionFilter<$PrismaModel>
  }

  export type EnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NotificacionOrderByRelevanceInput = {
    fields: NotificacionOrderByRelevanceFieldEnum | NotificacionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NotificacionCountOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    periodo?: SortOrder
    tipo?: SortOrder
    fechaEnvio?: SortOrder
    enviada?: SortOrder
    asunto?: SortOrder
    mensaje?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMaxOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    periodo?: SortOrder
    tipo?: SortOrder
    fechaEnvio?: SortOrder
    enviada?: SortOrder
    asunto?: SortOrder
    mensaje?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificacionMinOrderByAggregateInput = {
    id?: SortOrder
    clienteId?: SortOrder
    periodo?: SortOrder
    tipo?: SortOrder
    fechaEnvio?: SortOrder
    enviada?: SortOrder
    asunto?: SortOrder
    mensaje?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type TaxPeriodListRelationFilter = {
    every?: taxPeriodWhereInput
    some?: taxPeriodWhereInput
    none?: taxPeriodWhereInput
  }

  export type taxPeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type taxModelOrderByRelevanceInput = {
    fields: taxModelOrderByRelevanceFieldEnum | taxModelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type taxModelCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type taxModelMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type taxModelMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type TaxModelScalarRelationFilter = {
    is?: taxModelWhereInput
    isNot?: taxModelWhereInput
  }

  export type taxPeriodOrderByRelevanceInput = {
    fields: taxPeriodOrderByRelevanceFieldEnum | taxPeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type taxPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    modeloId?: SortOrder
    anio?: SortOrder
    trimestre?: SortOrder
    mes?: SortOrder
    inicioPresentacion?: SortOrder
    finPresentacion?: SortOrder
  }

  export type taxPeriodAvgOrderByAggregateInput = {
    anio?: SortOrder
    trimestre?: SortOrder
    mes?: SortOrder
  }

  export type taxPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    modeloId?: SortOrder
    anio?: SortOrder
    trimestre?: SortOrder
    mes?: SortOrder
    inicioPresentacion?: SortOrder
    finPresentacion?: SortOrder
  }

  export type taxPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    modeloId?: SortOrder
    anio?: SortOrder
    trimestre?: SortOrder
    mes?: SortOrder
    inicioPresentacion?: SortOrder
    finPresentacion?: SortOrder
  }

  export type taxPeriodSumOrderByAggregateInput = {
    anio?: SortOrder
    trimestre?: SortOrder
    mes?: SortOrder
  }

  export type TaxPeriodScalarRelationFilter = {
    is?: taxPeriodWhereInput
    isNot?: taxPeriodWhereInput
  }

  export type TaxFileListRelationFilter = {
    every?: taxFileWhereInput
    some?: taxFileWhereInput
    none?: taxFileWhereInput
  }

  export type taxFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientTaxOrderByRelevanceInput = {
    fields: clientTaxOrderByRelevanceFieldEnum | clientTaxOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clientTaxCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxPeriodId?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    displayText?: SortOrder
    colorTag?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type clientTaxMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxPeriodId?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    displayText?: SortOrder
    colorTag?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type clientTaxMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxPeriodId?: SortOrder
    estado?: SortOrder
    notas?: SortOrder
    displayText?: SortOrder
    colorTag?: SortOrder
    fechaCreacion?: SortOrder
    fechaActualizacion?: SortOrder
  }

  export type ClientTaxScalarRelationFilter = {
    is?: clientTaxWhereInput
    isNot?: clientTaxWhereInput
  }

  export type taxFileOrderByRelevanceInput = {
    fields: taxFileOrderByRelevanceFieldEnum | taxFileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type taxFileCountOrderByAggregateInput = {
    id?: SortOrder
    clientTaxId?: SortOrder
    nombreArchivo?: SortOrder
    s3Url?: SortOrder
    s3Key?: SortOrder
    tipo?: SortOrder
    tamanio?: SortOrder
    fechaSubida?: SortOrder
    subidoPor?: SortOrder
  }

  export type taxFileAvgOrderByAggregateInput = {
    tamanio?: SortOrder
  }

  export type taxFileMaxOrderByAggregateInput = {
    id?: SortOrder
    clientTaxId?: SortOrder
    nombreArchivo?: SortOrder
    s3Url?: SortOrder
    s3Key?: SortOrder
    tipo?: SortOrder
    tamanio?: SortOrder
    fechaSubida?: SortOrder
    subidoPor?: SortOrder
  }

  export type taxFileMinOrderByAggregateInput = {
    id?: SortOrder
    clientTaxId?: SortOrder
    nombreArchivo?: SortOrder
    s3Url?: SortOrder
    s3Key?: SortOrder
    tipo?: SortOrder
    tamanio?: SortOrder
    fechaSubida?: SortOrder
    subidoPor?: SortOrder
  }

  export type taxFileSumOrderByAggregateInput = {
    tamanio?: SortOrder
  }

  export type clientTaxRequirementOrderByRelevanceInput = {
    fields: clientTaxRequirementOrderByRelevanceFieldEnum | clientTaxRequirementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clientTaxRequirementCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    impuesto?: SortOrder
    detalle?: SortOrder
    taxModelCode?: SortOrder
    required?: SortOrder
    note?: SortOrder
    colorTag?: SortOrder
  }

  export type clientTaxRequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    impuesto?: SortOrder
    detalle?: SortOrder
    taxModelCode?: SortOrder
    required?: SortOrder
    note?: SortOrder
    colorTag?: SortOrder
  }

  export type clientTaxRequirementMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    impuesto?: SortOrder
    detalle?: SortOrder
    taxModelCode?: SortOrder
    required?: SortOrder
    note?: SortOrder
    colorTag?: SortOrder
  }

  export type fiscalPeriodOrderByRelevanceInput = {
    fields: fiscalPeriodOrderByRelevanceFieldEnum | fiscalPeriodOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type fiscalPeriodCountOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    quarter?: SortOrder
    label?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
  }

  export type fiscalPeriodAvgOrderByAggregateInput = {
    year?: SortOrder
    quarter?: SortOrder
  }

  export type fiscalPeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    quarter?: SortOrder
    label?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
  }

  export type fiscalPeriodMinOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
    quarter?: SortOrder
    label?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
  }

  export type fiscalPeriodSumOrderByAggregateInput = {
    year?: SortOrder
    quarter?: SortOrder
  }

  export type FiscalPeriodNullableScalarRelationFilter = {
    is?: fiscalPeriodWhereInput | null
    isNot?: fiscalPeriodWhereInput | null
  }

  export type clientTaxFilingOrderByRelevanceInput = {
    fields: clientTaxFilingOrderByRelevanceFieldEnum | clientTaxFilingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clientTaxFilingClientIdTaxModelCodePeriodIdCompoundUniqueInput = {
    clientId: string
    taxModelCode: string
    periodId: string
  }

  export type clientTaxFilingCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxModelCode?: SortOrder
    periodId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    presentedAt?: SortOrder
  }

  export type clientTaxFilingMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxModelCode?: SortOrder
    periodId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    presentedAt?: SortOrder
  }

  export type clientTaxFilingMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    taxModelCode?: SortOrder
    periodId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    presentedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput> | RolePermissionCreateWithoutRoleInput[] | RolePermissionUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutRoleInput | RolePermissionCreateOrConnectWithoutRoleInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutRoleInput | RolePermissionUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: RolePermissionCreateManyRoleInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutRoleInput | RolePermissionUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutRoleInput | RolePermissionUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUncheckedCreateNestedManyWithoutPermissionInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
  }

  export type RolePermissionUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionNestedInput = {
    create?: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput> | RolePermissionCreateWithoutPermissionInput[] | RolePermissionUncheckedCreateWithoutPermissionInput[]
    connectOrCreate?: RolePermissionCreateOrConnectWithoutPermissionInput | RolePermissionCreateOrConnectWithoutPermissionInput[]
    upsert?: RolePermissionUpsertWithWhereUniqueWithoutPermissionInput | RolePermissionUpsertWithWhereUniqueWithoutPermissionInput[]
    createMany?: RolePermissionCreateManyPermissionInputEnvelope
    set?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    disconnect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    delete?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    connect?: RolePermissionWhereUniqueInput | RolePermissionWhereUniqueInput[]
    update?: RolePermissionUpdateWithWhereUniqueWithoutPermissionInput | RolePermissionUpdateWithWhereUniqueWithoutPermissionInput[]
    updateMany?: RolePermissionUpdateManyWithWhereWithoutPermissionInput | RolePermissionUpdateManyWithWhereWithoutPermissionInput[]
    deleteMany?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
  }

  export type RoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
  }

  export type PermissionCreateNestedOneWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    connect?: PermissionWhereUniqueInput
  }

  export type RoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: RoleCreateOrConnectWithoutPermissionsInput
    upsert?: RoleUpsertWithoutPermissionsInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutPermissionsInput, RoleUpdateWithoutPermissionsInput>, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type PermissionUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput
    upsert?: PermissionUpsertWithoutRolesInput
    connect?: PermissionWhereUniqueInput
    update?: XOR<XOR<PermissionUpdateToOneWithWhereWithoutRolesInput, PermissionUpdateWithoutRolesInput>, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type ClientCreateNestedManyWithoutResponsableInput = {
    create?: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput> | ClientCreateWithoutResponsableInput[] | ClientUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutResponsableInput | ClientCreateOrConnectWithoutResponsableInput[]
    createMany?: ClientCreateManyResponsableInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientEmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput> | ClientEmployeeCreateWithoutUserInput[] | ClientEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutUserInput | ClientEmployeeCreateOrConnectWithoutUserInput[]
    createMany?: ClientEmployeeCreateManyUserInputEnvelope
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutAsignadoInput = {
    create?: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput> | TaskCreateWithoutAsignadoInput[] | TaskUncheckedCreateWithoutAsignadoInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAsignadoInput | TaskCreateOrConnectWithoutAsignadoInput[]
    createMany?: TaskCreateManyAsignadoInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ManualCreateNestedManyWithoutAutorInput = {
    create?: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput> | ManualCreateWithoutAutorInput[] | ManualUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ManualCreateOrConnectWithoutAutorInput | ManualCreateOrConnectWithoutAutorInput[]
    createMany?: ManualCreateManyAutorInputEnvelope
    connect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput> | ActivityLogCreateWithoutUsuarioInput[] | ActivityLogUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUsuarioInput | ActivityLogCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActivityLogCreateManyUsuarioInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AuditTrailCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput> | AuditTrailCreateWithoutUsuarioInput[] | AuditTrailUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUsuarioInput | AuditTrailCreateOrConnectWithoutUsuarioInput[]
    createMany?: AuditTrailCreateManyUsuarioInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type SMTPAccountCreateNestedManyWithoutCreadorInput = {
    create?: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput> | SMTPAccountCreateWithoutCreadorInput[] | SMTPAccountUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutCreadorInput | SMTPAccountCreateOrConnectWithoutCreadorInput[]
    createMany?: SMTPAccountCreateManyCreadorInputEnvelope
    connect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
  }

  export type NotificationTemplateCreateNestedManyWithoutCreadorInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput> | NotificationTemplateCreateWithoutCreadorInput[] | NotificationTemplateUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreadorInput | NotificationTemplateCreateOrConnectWithoutCreadorInput[]
    createMany?: NotificationTemplateCreateManyCreadorInputEnvelope
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
  }

  export type NotificationLogCreateNestedManyWithoutEnviadorInput = {
    create?: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput> | NotificationLogCreateWithoutEnviadorInput[] | NotificationLogUncheckedCreateWithoutEnviadorInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutEnviadorInput | NotificationLogCreateOrConnectWithoutEnviadorInput[]
    createMany?: NotificationLogCreateManyEnviadorInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationCreateNestedManyWithoutCreadorInput = {
    create?: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput> | ScheduledNotificationCreateWithoutCreadorInput[] | ScheduledNotificationUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutCreadorInput | ScheduledNotificationCreateOrConnectWithoutCreadorInput[]
    createMany?: ScheduledNotificationCreateManyCreadorInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type SystemBackupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput> | SystemBackupCreateWithoutCreatorInput[] | SystemBackupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SystemBackupCreateOrConnectWithoutCreatorInput | SystemBackupCreateOrConnectWithoutCreatorInput[]
    createMany?: SystemBackupCreateManyCreatorInputEnvelope
    connect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
  }

  export type SystemUpdateCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput> | SystemUpdateCreateWithoutInitiatorInput[] | SystemUpdateUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutInitiatorInput | SystemUpdateCreateOrConnectWithoutInitiatorInput[]
    createMany?: SystemUpdateCreateManyInitiatorInputEnvelope
    connect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput> | ClientCreateWithoutResponsableInput[] | ClientUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutResponsableInput | ClientCreateOrConnectWithoutResponsableInput[]
    createMany?: ClientCreateManyResponsableInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type ClientEmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput> | ClientEmployeeCreateWithoutUserInput[] | ClientEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutUserInput | ClientEmployeeCreateOrConnectWithoutUserInput[]
    createMany?: ClientEmployeeCreateManyUserInputEnvelope
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAsignadoInput = {
    create?: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput> | TaskCreateWithoutAsignadoInput[] | TaskUncheckedCreateWithoutAsignadoInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAsignadoInput | TaskCreateOrConnectWithoutAsignadoInput[]
    createMany?: TaskCreateManyAsignadoInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ManualUncheckedCreateNestedManyWithoutAutorInput = {
    create?: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput> | ManualCreateWithoutAutorInput[] | ManualUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ManualCreateOrConnectWithoutAutorInput | ManualCreateOrConnectWithoutAutorInput[]
    createMany?: ManualCreateManyAutorInputEnvelope
    connect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput> | ActivityLogCreateWithoutUsuarioInput[] | ActivityLogUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUsuarioInput | ActivityLogCreateOrConnectWithoutUsuarioInput[]
    createMany?: ActivityLogCreateManyUsuarioInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput> | AuditTrailCreateWithoutUsuarioInput[] | AuditTrailUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUsuarioInput | AuditTrailCreateOrConnectWithoutUsuarioInput[]
    createMany?: AuditTrailCreateManyUsuarioInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput = {
    create?: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput> | SMTPAccountCreateWithoutCreadorInput[] | SMTPAccountUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutCreadorInput | SMTPAccountCreateOrConnectWithoutCreadorInput[]
    createMany?: SMTPAccountCreateManyCreadorInputEnvelope
    connect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
  }

  export type NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput> | NotificationTemplateCreateWithoutCreadorInput[] | NotificationTemplateUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreadorInput | NotificationTemplateCreateOrConnectWithoutCreadorInput[]
    createMany?: NotificationTemplateCreateManyCreadorInputEnvelope
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput = {
    create?: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput> | NotificationLogCreateWithoutEnviadorInput[] | NotificationLogUncheckedCreateWithoutEnviadorInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutEnviadorInput | NotificationLogCreateOrConnectWithoutEnviadorInput[]
    createMany?: NotificationLogCreateManyEnviadorInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput = {
    create?: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput> | ScheduledNotificationCreateWithoutCreadorInput[] | ScheduledNotificationUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutCreadorInput | ScheduledNotificationCreateOrConnectWithoutCreadorInput[]
    createMany?: ScheduledNotificationCreateManyCreadorInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type SystemBackupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput> | SystemBackupCreateWithoutCreatorInput[] | SystemBackupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SystemBackupCreateOrConnectWithoutCreatorInput | SystemBackupCreateOrConnectWithoutCreatorInput[]
    createMany?: SystemBackupCreateManyCreatorInputEnvelope
    connect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
  }

  export type SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput> | SystemUpdateCreateWithoutInitiatorInput[] | SystemUpdateUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutInitiatorInput | SystemUpdateCreateOrConnectWithoutInitiatorInput[]
    createMany?: SystemUpdateCreateManyInitiatorInputEnvelope
    connect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
  }

  export type RoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    disconnect?: RoleWhereInput | boolean
    delete?: RoleWhereInput | boolean
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type ClientUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput> | ClientCreateWithoutResponsableInput[] | ClientUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutResponsableInput | ClientCreateOrConnectWithoutResponsableInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutResponsableInput | ClientUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: ClientCreateManyResponsableInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutResponsableInput | ClientUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutResponsableInput | ClientUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientEmployeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput> | ClientEmployeeCreateWithoutUserInput[] | ClientEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutUserInput | ClientEmployeeCreateOrConnectWithoutUserInput[]
    upsert?: ClientEmployeeUpsertWithWhereUniqueWithoutUserInput | ClientEmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientEmployeeCreateManyUserInputEnvelope
    set?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    disconnect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    delete?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    update?: ClientEmployeeUpdateWithWhereUniqueWithoutUserInput | ClientEmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientEmployeeUpdateManyWithWhereWithoutUserInput | ClientEmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutAsignadoNestedInput = {
    create?: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput> | TaskCreateWithoutAsignadoInput[] | TaskUncheckedCreateWithoutAsignadoInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAsignadoInput | TaskCreateOrConnectWithoutAsignadoInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAsignadoInput | TaskUpsertWithWhereUniqueWithoutAsignadoInput[]
    createMany?: TaskCreateManyAsignadoInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAsignadoInput | TaskUpdateWithWhereUniqueWithoutAsignadoInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAsignadoInput | TaskUpdateManyWithWhereWithoutAsignadoInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ManualUpdateManyWithoutAutorNestedInput = {
    create?: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput> | ManualCreateWithoutAutorInput[] | ManualUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ManualCreateOrConnectWithoutAutorInput | ManualCreateOrConnectWithoutAutorInput[]
    upsert?: ManualUpsertWithWhereUniqueWithoutAutorInput | ManualUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: ManualCreateManyAutorInputEnvelope
    set?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    disconnect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    delete?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    connect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    update?: ManualUpdateWithWhereUniqueWithoutAutorInput | ManualUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: ManualUpdateManyWithWhereWithoutAutorInput | ManualUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: ManualScalarWhereInput | ManualScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput> | ActivityLogCreateWithoutUsuarioInput[] | ActivityLogUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUsuarioInput | ActivityLogCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUsuarioInput | ActivityLogUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActivityLogCreateManyUsuarioInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUsuarioInput | ActivityLogUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUsuarioInput | ActivityLogUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AuditTrailUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput> | AuditTrailCreateWithoutUsuarioInput[] | AuditTrailUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUsuarioInput | AuditTrailCreateOrConnectWithoutUsuarioInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUsuarioInput | AuditTrailUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AuditTrailCreateManyUsuarioInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUsuarioInput | AuditTrailUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUsuarioInput | AuditTrailUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type SMTPAccountUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput> | SMTPAccountCreateWithoutCreadorInput[] | SMTPAccountUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutCreadorInput | SMTPAccountCreateOrConnectWithoutCreadorInput[]
    upsert?: SMTPAccountUpsertWithWhereUniqueWithoutCreadorInput | SMTPAccountUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: SMTPAccountCreateManyCreadorInputEnvelope
    set?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    disconnect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    delete?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    connect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    update?: SMTPAccountUpdateWithWhereUniqueWithoutCreadorInput | SMTPAccountUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: SMTPAccountUpdateManyWithWhereWithoutCreadorInput | SMTPAccountUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: SMTPAccountScalarWhereInput | SMTPAccountScalarWhereInput[]
  }

  export type NotificationTemplateUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput> | NotificationTemplateCreateWithoutCreadorInput[] | NotificationTemplateUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreadorInput | NotificationTemplateCreateOrConnectWithoutCreadorInput[]
    upsert?: NotificationTemplateUpsertWithWhereUniqueWithoutCreadorInput | NotificationTemplateUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: NotificationTemplateCreateManyCreadorInputEnvelope
    set?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    disconnect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    delete?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    update?: NotificationTemplateUpdateWithWhereUniqueWithoutCreadorInput | NotificationTemplateUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: NotificationTemplateUpdateManyWithWhereWithoutCreadorInput | NotificationTemplateUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
  }

  export type NotificationLogUpdateManyWithoutEnviadorNestedInput = {
    create?: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput> | NotificationLogCreateWithoutEnviadorInput[] | NotificationLogUncheckedCreateWithoutEnviadorInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutEnviadorInput | NotificationLogCreateOrConnectWithoutEnviadorInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutEnviadorInput | NotificationLogUpsertWithWhereUniqueWithoutEnviadorInput[]
    createMany?: NotificationLogCreateManyEnviadorInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutEnviadorInput | NotificationLogUpdateWithWhereUniqueWithoutEnviadorInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutEnviadorInput | NotificationLogUpdateManyWithWhereWithoutEnviadorInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput> | ScheduledNotificationCreateWithoutCreadorInput[] | ScheduledNotificationUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutCreadorInput | ScheduledNotificationCreateOrConnectWithoutCreadorInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutCreadorInput | ScheduledNotificationUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: ScheduledNotificationCreateManyCreadorInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutCreadorInput | ScheduledNotificationUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutCreadorInput | ScheduledNotificationUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type SystemBackupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput> | SystemBackupCreateWithoutCreatorInput[] | SystemBackupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SystemBackupCreateOrConnectWithoutCreatorInput | SystemBackupCreateOrConnectWithoutCreatorInput[]
    upsert?: SystemBackupUpsertWithWhereUniqueWithoutCreatorInput | SystemBackupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SystemBackupCreateManyCreatorInputEnvelope
    set?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    disconnect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    delete?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    connect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    update?: SystemBackupUpdateWithWhereUniqueWithoutCreatorInput | SystemBackupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SystemBackupUpdateManyWithWhereWithoutCreatorInput | SystemBackupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SystemBackupScalarWhereInput | SystemBackupScalarWhereInput[]
  }

  export type SystemUpdateUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput> | SystemUpdateCreateWithoutInitiatorInput[] | SystemUpdateUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutInitiatorInput | SystemUpdateCreateOrConnectWithoutInitiatorInput[]
    upsert?: SystemUpdateUpsertWithWhereUniqueWithoutInitiatorInput | SystemUpdateUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: SystemUpdateCreateManyInitiatorInputEnvelope
    set?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    disconnect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    delete?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    connect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    update?: SystemUpdateUpdateWithWhereUniqueWithoutInitiatorInput | SystemUpdateUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: SystemUpdateUpdateManyWithWhereWithoutInitiatorInput | SystemUpdateUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: SystemUpdateScalarWhereInput | SystemUpdateScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput> | ClientCreateWithoutResponsableInput[] | ClientUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutResponsableInput | ClientCreateOrConnectWithoutResponsableInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutResponsableInput | ClientUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: ClientCreateManyResponsableInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutResponsableInput | ClientUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutResponsableInput | ClientUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput> | ClientEmployeeCreateWithoutUserInput[] | ClientEmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutUserInput | ClientEmployeeCreateOrConnectWithoutUserInput[]
    upsert?: ClientEmployeeUpsertWithWhereUniqueWithoutUserInput | ClientEmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClientEmployeeCreateManyUserInputEnvelope
    set?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    disconnect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    delete?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    update?: ClientEmployeeUpdateWithWhereUniqueWithoutUserInput | ClientEmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClientEmployeeUpdateManyWithWhereWithoutUserInput | ClientEmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAsignadoNestedInput = {
    create?: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput> | TaskCreateWithoutAsignadoInput[] | TaskUncheckedCreateWithoutAsignadoInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAsignadoInput | TaskCreateOrConnectWithoutAsignadoInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAsignadoInput | TaskUpsertWithWhereUniqueWithoutAsignadoInput[]
    createMany?: TaskCreateManyAsignadoInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAsignadoInput | TaskUpdateWithWhereUniqueWithoutAsignadoInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAsignadoInput | TaskUpdateManyWithWhereWithoutAsignadoInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ManualUncheckedUpdateManyWithoutAutorNestedInput = {
    create?: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput> | ManualCreateWithoutAutorInput[] | ManualUncheckedCreateWithoutAutorInput[]
    connectOrCreate?: ManualCreateOrConnectWithoutAutorInput | ManualCreateOrConnectWithoutAutorInput[]
    upsert?: ManualUpsertWithWhereUniqueWithoutAutorInput | ManualUpsertWithWhereUniqueWithoutAutorInput[]
    createMany?: ManualCreateManyAutorInputEnvelope
    set?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    disconnect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    delete?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    connect?: ManualWhereUniqueInput | ManualWhereUniqueInput[]
    update?: ManualUpdateWithWhereUniqueWithoutAutorInput | ManualUpdateWithWhereUniqueWithoutAutorInput[]
    updateMany?: ManualUpdateManyWithWhereWithoutAutorInput | ManualUpdateManyWithWhereWithoutAutorInput[]
    deleteMany?: ManualScalarWhereInput | ManualScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput> | ActivityLogCreateWithoutUsuarioInput[] | ActivityLogUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUsuarioInput | ActivityLogCreateOrConnectWithoutUsuarioInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUsuarioInput | ActivityLogUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: ActivityLogCreateManyUsuarioInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUsuarioInput | ActivityLogUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUsuarioInput | ActivityLogUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput> | AuditTrailCreateWithoutUsuarioInput[] | AuditTrailUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUsuarioInput | AuditTrailCreateOrConnectWithoutUsuarioInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUsuarioInput | AuditTrailUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AuditTrailCreateManyUsuarioInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUsuarioInput | AuditTrailUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUsuarioInput | AuditTrailUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput> | SMTPAccountCreateWithoutCreadorInput[] | SMTPAccountUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutCreadorInput | SMTPAccountCreateOrConnectWithoutCreadorInput[]
    upsert?: SMTPAccountUpsertWithWhereUniqueWithoutCreadorInput | SMTPAccountUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: SMTPAccountCreateManyCreadorInputEnvelope
    set?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    disconnect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    delete?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    connect?: SMTPAccountWhereUniqueInput | SMTPAccountWhereUniqueInput[]
    update?: SMTPAccountUpdateWithWhereUniqueWithoutCreadorInput | SMTPAccountUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: SMTPAccountUpdateManyWithWhereWithoutCreadorInput | SMTPAccountUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: SMTPAccountScalarWhereInput | SMTPAccountScalarWhereInput[]
  }

  export type NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput> | NotificationTemplateCreateWithoutCreadorInput[] | NotificationTemplateUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreadorInput | NotificationTemplateCreateOrConnectWithoutCreadorInput[]
    upsert?: NotificationTemplateUpsertWithWhereUniqueWithoutCreadorInput | NotificationTemplateUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: NotificationTemplateCreateManyCreadorInputEnvelope
    set?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    disconnect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    delete?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    update?: NotificationTemplateUpdateWithWhereUniqueWithoutCreadorInput | NotificationTemplateUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: NotificationTemplateUpdateManyWithWhereWithoutCreadorInput | NotificationTemplateUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput = {
    create?: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput> | NotificationLogCreateWithoutEnviadorInput[] | NotificationLogUncheckedCreateWithoutEnviadorInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutEnviadorInput | NotificationLogCreateOrConnectWithoutEnviadorInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutEnviadorInput | NotificationLogUpsertWithWhereUniqueWithoutEnviadorInput[]
    createMany?: NotificationLogCreateManyEnviadorInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutEnviadorInput | NotificationLogUpdateWithWhereUniqueWithoutEnviadorInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutEnviadorInput | NotificationLogUpdateManyWithWhereWithoutEnviadorInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput> | ScheduledNotificationCreateWithoutCreadorInput[] | ScheduledNotificationUncheckedCreateWithoutCreadorInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutCreadorInput | ScheduledNotificationCreateOrConnectWithoutCreadorInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutCreadorInput | ScheduledNotificationUpsertWithWhereUniqueWithoutCreadorInput[]
    createMany?: ScheduledNotificationCreateManyCreadorInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutCreadorInput | ScheduledNotificationUpdateWithWhereUniqueWithoutCreadorInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutCreadorInput | ScheduledNotificationUpdateManyWithWhereWithoutCreadorInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput> | SystemBackupCreateWithoutCreatorInput[] | SystemBackupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SystemBackupCreateOrConnectWithoutCreatorInput | SystemBackupCreateOrConnectWithoutCreatorInput[]
    upsert?: SystemBackupUpsertWithWhereUniqueWithoutCreatorInput | SystemBackupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SystemBackupCreateManyCreatorInputEnvelope
    set?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    disconnect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    delete?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    connect?: SystemBackupWhereUniqueInput | SystemBackupWhereUniqueInput[]
    update?: SystemBackupUpdateWithWhereUniqueWithoutCreatorInput | SystemBackupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SystemBackupUpdateManyWithWhereWithoutCreatorInput | SystemBackupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SystemBackupScalarWhereInput | SystemBackupScalarWhereInput[]
  }

  export type SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput> | SystemUpdateCreateWithoutInitiatorInput[] | SystemUpdateUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: SystemUpdateCreateOrConnectWithoutInitiatorInput | SystemUpdateCreateOrConnectWithoutInitiatorInput[]
    upsert?: SystemUpdateUpsertWithWhereUniqueWithoutInitiatorInput | SystemUpdateUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: SystemUpdateCreateManyInitiatorInputEnvelope
    set?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    disconnect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    delete?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    connect?: SystemUpdateWhereUniqueInput | SystemUpdateWhereUniqueInput[]
    update?: SystemUpdateUpdateWithWhereUniqueWithoutInitiatorInput | SystemUpdateUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: SystemUpdateUpdateManyWithWhereWithoutInitiatorInput | SystemUpdateUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: SystemUpdateScalarWhereInput | SystemUpdateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutClientsManagedInput = {
    create?: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsManagedInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutClienteInput = {
    create?: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput> | TaskCreateWithoutClienteInput[] | TaskUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClienteInput | TaskCreateOrConnectWithoutClienteInput[]
    createMany?: TaskCreateManyClienteInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ClientEmployeeCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput> | ClientEmployeeCreateWithoutClientInput[] | ClientEmployeeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutClientInput | ClientEmployeeCreateOrConnectWithoutClientInput[]
    createMany?: ClientEmployeeCreateManyClientInputEnvelope
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
  }

  export type clientTaxCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput> | clientTaxCreateWithoutClientInput[] | clientTaxUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutClientInput | clientTaxCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxCreateManyClientInputEnvelope
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
  }

  export type clientTaxRequirementCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput> | clientTaxRequirementCreateWithoutClientInput[] | clientTaxRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxRequirementCreateOrConnectWithoutClientInput | clientTaxRequirementCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxRequirementCreateManyClientInputEnvelope
    connect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
  }

  export type clientTaxFilingCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput> | clientTaxFilingCreateWithoutClientInput[] | clientTaxFilingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutClientInput | clientTaxFilingCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxFilingCreateManyClientInputEnvelope
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
  }

  export type ObligacionFiscalCreateNestedManyWithoutClienteInput = {
    create?: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput> | ObligacionFiscalCreateWithoutClienteInput[] | ObligacionFiscalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutClienteInput | ObligacionFiscalCreateOrConnectWithoutClienteInput[]
    createMany?: ObligacionFiscalCreateManyClienteInputEnvelope
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
  }

  export type NotificacionCreateNestedManyWithoutClienteInput = {
    create?: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput> | NotificacionCreateWithoutClienteInput[] | NotificacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutClienteInput | NotificacionCreateOrConnectWithoutClienteInput[]
    createMany?: NotificacionCreateManyClienteInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput> | TaskCreateWithoutClienteInput[] | TaskUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClienteInput | TaskCreateOrConnectWithoutClienteInput[]
    createMany?: TaskCreateManyClienteInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ClientEmployeeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput> | ClientEmployeeCreateWithoutClientInput[] | ClientEmployeeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutClientInput | ClientEmployeeCreateOrConnectWithoutClientInput[]
    createMany?: ClientEmployeeCreateManyClientInputEnvelope
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
  }

  export type clientTaxUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput> | clientTaxCreateWithoutClientInput[] | clientTaxUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutClientInput | clientTaxCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxCreateManyClientInputEnvelope
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
  }

  export type clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput> | clientTaxRequirementCreateWithoutClientInput[] | clientTaxRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxRequirementCreateOrConnectWithoutClientInput | clientTaxRequirementCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxRequirementCreateManyClientInputEnvelope
    connect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
  }

  export type clientTaxFilingUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput> | clientTaxFilingCreateWithoutClientInput[] | clientTaxFilingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutClientInput | clientTaxFilingCreateOrConnectWithoutClientInput[]
    createMany?: clientTaxFilingCreateManyClientInputEnvelope
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
  }

  export type ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput> | ObligacionFiscalCreateWithoutClienteInput[] | ObligacionFiscalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutClienteInput | ObligacionFiscalCreateOrConnectWithoutClienteInput[]
    createMany?: ObligacionFiscalCreateManyClienteInputEnvelope
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
  }

  export type NotificacionUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput> | NotificacionCreateWithoutClienteInput[] | NotificacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutClienteInput | NotificacionCreateOrConnectWithoutClienteInput[]
    createMany?: NotificacionCreateManyClienteInputEnvelope
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneWithoutClientsManagedNestedInput = {
    create?: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsManagedInput
    upsert?: UserUpsertWithoutClientsManagedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsManagedInput, UserUpdateWithoutClientsManagedInput>, UserUncheckedUpdateWithoutClientsManagedInput>
  }

  export type TaskUpdateManyWithoutClienteNestedInput = {
    create?: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput> | TaskCreateWithoutClienteInput[] | TaskUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClienteInput | TaskCreateOrConnectWithoutClienteInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClienteInput | TaskUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: TaskCreateManyClienteInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClienteInput | TaskUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClienteInput | TaskUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ClientEmployeeUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput> | ClientEmployeeCreateWithoutClientInput[] | ClientEmployeeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutClientInput | ClientEmployeeCreateOrConnectWithoutClientInput[]
    upsert?: ClientEmployeeUpsertWithWhereUniqueWithoutClientInput | ClientEmployeeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientEmployeeCreateManyClientInputEnvelope
    set?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    disconnect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    delete?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    update?: ClientEmployeeUpdateWithWhereUniqueWithoutClientInput | ClientEmployeeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientEmployeeUpdateManyWithWhereWithoutClientInput | ClientEmployeeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
  }

  export type clientTaxUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput> | clientTaxCreateWithoutClientInput[] | clientTaxUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutClientInput | clientTaxCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxUpsertWithWhereUniqueWithoutClientInput | clientTaxUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxCreateManyClientInputEnvelope
    set?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    disconnect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    delete?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    update?: clientTaxUpdateWithWhereUniqueWithoutClientInput | clientTaxUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxUpdateManyWithWhereWithoutClientInput | clientTaxUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
  }

  export type clientTaxRequirementUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput> | clientTaxRequirementCreateWithoutClientInput[] | clientTaxRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxRequirementCreateOrConnectWithoutClientInput | clientTaxRequirementCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxRequirementUpsertWithWhereUniqueWithoutClientInput | clientTaxRequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxRequirementCreateManyClientInputEnvelope
    set?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    disconnect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    delete?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    connect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    update?: clientTaxRequirementUpdateWithWhereUniqueWithoutClientInput | clientTaxRequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxRequirementUpdateManyWithWhereWithoutClientInput | clientTaxRequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxRequirementScalarWhereInput | clientTaxRequirementScalarWhereInput[]
  }

  export type clientTaxFilingUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput> | clientTaxFilingCreateWithoutClientInput[] | clientTaxFilingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutClientInput | clientTaxFilingCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxFilingUpsertWithWhereUniqueWithoutClientInput | clientTaxFilingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxFilingCreateManyClientInputEnvelope
    set?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    disconnect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    delete?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    update?: clientTaxFilingUpdateWithWhereUniqueWithoutClientInput | clientTaxFilingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxFilingUpdateManyWithWhereWithoutClientInput | clientTaxFilingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
  }

  export type ObligacionFiscalUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput> | ObligacionFiscalCreateWithoutClienteInput[] | ObligacionFiscalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutClienteInput | ObligacionFiscalCreateOrConnectWithoutClienteInput[]
    upsert?: ObligacionFiscalUpsertWithWhereUniqueWithoutClienteInput | ObligacionFiscalUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ObligacionFiscalCreateManyClienteInputEnvelope
    set?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    disconnect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    delete?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    update?: ObligacionFiscalUpdateWithWhereUniqueWithoutClienteInput | ObligacionFiscalUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ObligacionFiscalUpdateManyWithWhereWithoutClienteInput | ObligacionFiscalUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
  }

  export type NotificacionUpdateManyWithoutClienteNestedInput = {
    create?: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput> | NotificacionCreateWithoutClienteInput[] | NotificacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutClienteInput | NotificacionCreateOrConnectWithoutClienteInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutClienteInput | NotificacionUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: NotificacionCreateManyClienteInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutClienteInput | NotificacionUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutClienteInput | NotificacionUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput> | TaskCreateWithoutClienteInput[] | TaskUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutClienteInput | TaskCreateOrConnectWithoutClienteInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutClienteInput | TaskUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: TaskCreateManyClienteInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutClienteInput | TaskUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutClienteInput | TaskUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput> | ClientEmployeeCreateWithoutClientInput[] | ClientEmployeeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ClientEmployeeCreateOrConnectWithoutClientInput | ClientEmployeeCreateOrConnectWithoutClientInput[]
    upsert?: ClientEmployeeUpsertWithWhereUniqueWithoutClientInput | ClientEmployeeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ClientEmployeeCreateManyClientInputEnvelope
    set?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    disconnect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    delete?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    connect?: ClientEmployeeWhereUniqueInput | ClientEmployeeWhereUniqueInput[]
    update?: ClientEmployeeUpdateWithWhereUniqueWithoutClientInput | ClientEmployeeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ClientEmployeeUpdateManyWithWhereWithoutClientInput | ClientEmployeeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
  }

  export type clientTaxUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput> | clientTaxCreateWithoutClientInput[] | clientTaxUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutClientInput | clientTaxCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxUpsertWithWhereUniqueWithoutClientInput | clientTaxUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxCreateManyClientInputEnvelope
    set?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    disconnect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    delete?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    update?: clientTaxUpdateWithWhereUniqueWithoutClientInput | clientTaxUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxUpdateManyWithWhereWithoutClientInput | clientTaxUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
  }

  export type clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput> | clientTaxRequirementCreateWithoutClientInput[] | clientTaxRequirementUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxRequirementCreateOrConnectWithoutClientInput | clientTaxRequirementCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxRequirementUpsertWithWhereUniqueWithoutClientInput | clientTaxRequirementUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxRequirementCreateManyClientInputEnvelope
    set?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    disconnect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    delete?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    connect?: clientTaxRequirementWhereUniqueInput | clientTaxRequirementWhereUniqueInput[]
    update?: clientTaxRequirementUpdateWithWhereUniqueWithoutClientInput | clientTaxRequirementUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxRequirementUpdateManyWithWhereWithoutClientInput | clientTaxRequirementUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxRequirementScalarWhereInput | clientTaxRequirementScalarWhereInput[]
  }

  export type clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput> | clientTaxFilingCreateWithoutClientInput[] | clientTaxFilingUncheckedCreateWithoutClientInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutClientInput | clientTaxFilingCreateOrConnectWithoutClientInput[]
    upsert?: clientTaxFilingUpsertWithWhereUniqueWithoutClientInput | clientTaxFilingUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: clientTaxFilingCreateManyClientInputEnvelope
    set?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    disconnect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    delete?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    update?: clientTaxFilingUpdateWithWhereUniqueWithoutClientInput | clientTaxFilingUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: clientTaxFilingUpdateManyWithWhereWithoutClientInput | clientTaxFilingUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
  }

  export type ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput> | ObligacionFiscalCreateWithoutClienteInput[] | ObligacionFiscalUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutClienteInput | ObligacionFiscalCreateOrConnectWithoutClienteInput[]
    upsert?: ObligacionFiscalUpsertWithWhereUniqueWithoutClienteInput | ObligacionFiscalUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ObligacionFiscalCreateManyClienteInputEnvelope
    set?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    disconnect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    delete?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    update?: ObligacionFiscalUpdateWithWhereUniqueWithoutClienteInput | ObligacionFiscalUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ObligacionFiscalUpdateManyWithWhereWithoutClienteInput | ObligacionFiscalUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
  }

  export type NotificacionUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput> | NotificacionCreateWithoutClienteInput[] | NotificacionUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: NotificacionCreateOrConnectWithoutClienteInput | NotificacionCreateOrConnectWithoutClienteInput[]
    upsert?: NotificacionUpsertWithWhereUniqueWithoutClienteInput | NotificacionUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: NotificacionCreateManyClienteInputEnvelope
    set?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    disconnect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    delete?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    connect?: NotificacionWhereUniqueInput | NotificacionWhereUniqueInput[]
    update?: NotificacionUpdateWithWhereUniqueWithoutClienteInput | NotificacionUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: NotificacionUpdateManyWithWhereWithoutClienteInput | NotificacionUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ClientCreateWithoutEmployeesInput, ClientUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmployeesInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClientsAssignedInput = {
    create?: XOR<UserCreateWithoutClientsAssignedInput, UserUncheckedCreateWithoutClientsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<ClientCreateWithoutEmployeesInput, ClientUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutEmployeesInput
    upsert?: ClientUpsertWithoutEmployeesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutEmployeesInput, ClientUpdateWithoutEmployeesInput>, ClientUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneRequiredWithoutClientsAssignedNestedInput = {
    create?: XOR<UserCreateWithoutClientsAssignedInput, UserUncheckedCreateWithoutClientsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutClientsAssignedInput
    upsert?: UserUpsertWithoutClientsAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClientsAssignedInput, UserUpdateWithoutClientsAssignedInput>, UserUncheckedUpdateWithoutClientsAssignedInput>
  }

  export type ClientCreateNestedOneWithoutTasksInput = {
    create?: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTasksInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksAssignedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaskPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TaskPriority
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type EnumTaskVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.TaskVisibility
  }

  export type ClientUpdateOneWithoutTasksNestedInput = {
    create?: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTasksInput
    upsert?: ClientUpsertWithoutTasksInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTasksInput, ClientUpdateWithoutTasksInput>, ClientUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutTasksAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksAssignedInput
    upsert?: UserUpsertWithoutTasksAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksAssignedInput, UserUpdateWithoutTasksAssignedInput>, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserCreateNestedOneWithoutManualsAuthoredInput = {
    create?: XOR<UserCreateWithoutManualsAuthoredInput, UserUncheckedCreateWithoutManualsAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutManualsAuthoredInput
    connect?: UserWhereUniqueInput
  }

  export type ManualAttachmentCreateNestedManyWithoutManualInput = {
    create?: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput> | ManualAttachmentCreateWithoutManualInput[] | ManualAttachmentUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualAttachmentCreateOrConnectWithoutManualInput | ManualAttachmentCreateOrConnectWithoutManualInput[]
    createMany?: ManualAttachmentCreateManyManualInputEnvelope
    connect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
  }

  export type ManualVersionCreateNestedManyWithoutManualInput = {
    create?: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput> | ManualVersionCreateWithoutManualInput[] | ManualVersionUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualVersionCreateOrConnectWithoutManualInput | ManualVersionCreateOrConnectWithoutManualInput[]
    createMany?: ManualVersionCreateManyManualInputEnvelope
    connect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
  }

  export type ManualAttachmentUncheckedCreateNestedManyWithoutManualInput = {
    create?: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput> | ManualAttachmentCreateWithoutManualInput[] | ManualAttachmentUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualAttachmentCreateOrConnectWithoutManualInput | ManualAttachmentCreateOrConnectWithoutManualInput[]
    createMany?: ManualAttachmentCreateManyManualInputEnvelope
    connect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
  }

  export type ManualVersionUncheckedCreateNestedManyWithoutManualInput = {
    create?: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput> | ManualVersionCreateWithoutManualInput[] | ManualVersionUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualVersionCreateOrConnectWithoutManualInput | ManualVersionCreateOrConnectWithoutManualInput[]
    createMany?: ManualVersionCreateManyManualInputEnvelope
    connect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
  }

  export type EnumManualStatusFieldUpdateOperationsInput = {
    set?: $Enums.ManualStatus
  }

  export type UserUpdateOneRequiredWithoutManualsAuthoredNestedInput = {
    create?: XOR<UserCreateWithoutManualsAuthoredInput, UserUncheckedCreateWithoutManualsAuthoredInput>
    connectOrCreate?: UserCreateOrConnectWithoutManualsAuthoredInput
    upsert?: UserUpsertWithoutManualsAuthoredInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManualsAuthoredInput, UserUpdateWithoutManualsAuthoredInput>, UserUncheckedUpdateWithoutManualsAuthoredInput>
  }

  export type ManualAttachmentUpdateManyWithoutManualNestedInput = {
    create?: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput> | ManualAttachmentCreateWithoutManualInput[] | ManualAttachmentUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualAttachmentCreateOrConnectWithoutManualInput | ManualAttachmentCreateOrConnectWithoutManualInput[]
    upsert?: ManualAttachmentUpsertWithWhereUniqueWithoutManualInput | ManualAttachmentUpsertWithWhereUniqueWithoutManualInput[]
    createMany?: ManualAttachmentCreateManyManualInputEnvelope
    set?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    disconnect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    delete?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    connect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    update?: ManualAttachmentUpdateWithWhereUniqueWithoutManualInput | ManualAttachmentUpdateWithWhereUniqueWithoutManualInput[]
    updateMany?: ManualAttachmentUpdateManyWithWhereWithoutManualInput | ManualAttachmentUpdateManyWithWhereWithoutManualInput[]
    deleteMany?: ManualAttachmentScalarWhereInput | ManualAttachmentScalarWhereInput[]
  }

  export type ManualVersionUpdateManyWithoutManualNestedInput = {
    create?: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput> | ManualVersionCreateWithoutManualInput[] | ManualVersionUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualVersionCreateOrConnectWithoutManualInput | ManualVersionCreateOrConnectWithoutManualInput[]
    upsert?: ManualVersionUpsertWithWhereUniqueWithoutManualInput | ManualVersionUpsertWithWhereUniqueWithoutManualInput[]
    createMany?: ManualVersionCreateManyManualInputEnvelope
    set?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    disconnect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    delete?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    connect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    update?: ManualVersionUpdateWithWhereUniqueWithoutManualInput | ManualVersionUpdateWithWhereUniqueWithoutManualInput[]
    updateMany?: ManualVersionUpdateManyWithWhereWithoutManualInput | ManualVersionUpdateManyWithWhereWithoutManualInput[]
    deleteMany?: ManualVersionScalarWhereInput | ManualVersionScalarWhereInput[]
  }

  export type ManualAttachmentUncheckedUpdateManyWithoutManualNestedInput = {
    create?: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput> | ManualAttachmentCreateWithoutManualInput[] | ManualAttachmentUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualAttachmentCreateOrConnectWithoutManualInput | ManualAttachmentCreateOrConnectWithoutManualInput[]
    upsert?: ManualAttachmentUpsertWithWhereUniqueWithoutManualInput | ManualAttachmentUpsertWithWhereUniqueWithoutManualInput[]
    createMany?: ManualAttachmentCreateManyManualInputEnvelope
    set?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    disconnect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    delete?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    connect?: ManualAttachmentWhereUniqueInput | ManualAttachmentWhereUniqueInput[]
    update?: ManualAttachmentUpdateWithWhereUniqueWithoutManualInput | ManualAttachmentUpdateWithWhereUniqueWithoutManualInput[]
    updateMany?: ManualAttachmentUpdateManyWithWhereWithoutManualInput | ManualAttachmentUpdateManyWithWhereWithoutManualInput[]
    deleteMany?: ManualAttachmentScalarWhereInput | ManualAttachmentScalarWhereInput[]
  }

  export type ManualVersionUncheckedUpdateManyWithoutManualNestedInput = {
    create?: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput> | ManualVersionCreateWithoutManualInput[] | ManualVersionUncheckedCreateWithoutManualInput[]
    connectOrCreate?: ManualVersionCreateOrConnectWithoutManualInput | ManualVersionCreateOrConnectWithoutManualInput[]
    upsert?: ManualVersionUpsertWithWhereUniqueWithoutManualInput | ManualVersionUpsertWithWhereUniqueWithoutManualInput[]
    createMany?: ManualVersionCreateManyManualInputEnvelope
    set?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    disconnect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    delete?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    connect?: ManualVersionWhereUniqueInput | ManualVersionWhereUniqueInput[]
    update?: ManualVersionUpdateWithWhereUniqueWithoutManualInput | ManualVersionUpdateWithWhereUniqueWithoutManualInput[]
    updateMany?: ManualVersionUpdateManyWithWhereWithoutManualInput | ManualVersionUpdateManyWithWhereWithoutManualInput[]
    deleteMany?: ManualVersionScalarWhereInput | ManualVersionScalarWhereInput[]
  }

  export type ManualCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<ManualCreateWithoutAttachmentsInput, ManualUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ManualCreateOrConnectWithoutAttachmentsInput
    connect?: ManualWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ManualUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<ManualCreateWithoutAttachmentsInput, ManualUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: ManualCreateOrConnectWithoutAttachmentsInput
    upsert?: ManualUpsertWithoutAttachmentsInput
    connect?: ManualWhereUniqueInput
    update?: XOR<XOR<ManualUpdateToOneWithWhereWithoutAttachmentsInput, ManualUpdateWithoutAttachmentsInput>, ManualUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ManualCreateNestedOneWithoutVersionsInput = {
    create?: XOR<ManualCreateWithoutVersionsInput, ManualUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ManualCreateOrConnectWithoutVersionsInput
    connect?: ManualWhereUniqueInput
  }

  export type ManualUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<ManualCreateWithoutVersionsInput, ManualUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: ManualCreateOrConnectWithoutVersionsInput
    upsert?: ManualUpsertWithoutVersionsInput
    connect?: ManualWhereUniqueInput
    update?: XOR<XOR<ManualUpdateToOneWithWhereWithoutVersionsInput, ManualUpdateWithoutVersionsInput>, ManualUncheckedUpdateWithoutVersionsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutAuditTrailsInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type UserUpdateOneRequiredWithoutAuditTrailsNestedInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    upsert?: UserUpsertWithoutAuditTrailsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditTrailsInput, UserUpdateWithoutAuditTrailsInput>, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutSmtpAccountsCreatedInput = {
    create?: XOR<UserCreateWithoutSmtpAccountsCreatedInput, UserUncheckedCreateWithoutSmtpAccountsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmtpAccountsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationLogCreateNestedManyWithoutSmtpAccountInput = {
    create?: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput> | NotificationLogCreateWithoutSmtpAccountInput[] | NotificationLogUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutSmtpAccountInput | NotificationLogCreateOrConnectWithoutSmtpAccountInput[]
    createMany?: NotificationLogCreateManySmtpAccountInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationCreateNestedManyWithoutSmtpAccountInput = {
    create?: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput> | ScheduledNotificationCreateWithoutSmtpAccountInput[] | ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput | ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput[]
    createMany?: ScheduledNotificationCreateManySmtpAccountInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutSmtpAccountInput = {
    create?: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput> | NotificationLogCreateWithoutSmtpAccountInput[] | NotificationLogUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutSmtpAccountInput | NotificationLogCreateOrConnectWithoutSmtpAccountInput[]
    createMany?: NotificationLogCreateManySmtpAccountInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationUncheckedCreateNestedManyWithoutSmtpAccountInput = {
    create?: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput> | ScheduledNotificationCreateWithoutSmtpAccountInput[] | ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput | ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput[]
    createMany?: ScheduledNotificationCreateManySmtpAccountInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutSmtpAccountsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutSmtpAccountsCreatedInput, UserUncheckedCreateWithoutSmtpAccountsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSmtpAccountsCreatedInput
    upsert?: UserUpsertWithoutSmtpAccountsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSmtpAccountsCreatedInput, UserUpdateWithoutSmtpAccountsCreatedInput>, UserUncheckedUpdateWithoutSmtpAccountsCreatedInput>
  }

  export type NotificationLogUpdateManyWithoutSmtpAccountNestedInput = {
    create?: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput> | NotificationLogCreateWithoutSmtpAccountInput[] | NotificationLogUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutSmtpAccountInput | NotificationLogCreateOrConnectWithoutSmtpAccountInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutSmtpAccountInput | NotificationLogUpsertWithWhereUniqueWithoutSmtpAccountInput[]
    createMany?: NotificationLogCreateManySmtpAccountInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutSmtpAccountInput | NotificationLogUpdateWithWhereUniqueWithoutSmtpAccountInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutSmtpAccountInput | NotificationLogUpdateManyWithWhereWithoutSmtpAccountInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUpdateManyWithoutSmtpAccountNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput> | ScheduledNotificationCreateWithoutSmtpAccountInput[] | ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput | ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutSmtpAccountInput | ScheduledNotificationUpsertWithWhereUniqueWithoutSmtpAccountInput[]
    createMany?: ScheduledNotificationCreateManySmtpAccountInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutSmtpAccountInput | ScheduledNotificationUpdateWithWhereUniqueWithoutSmtpAccountInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutSmtpAccountInput | ScheduledNotificationUpdateManyWithWhereWithoutSmtpAccountInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutSmtpAccountNestedInput = {
    create?: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput> | NotificationLogCreateWithoutSmtpAccountInput[] | NotificationLogUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutSmtpAccountInput | NotificationLogCreateOrConnectWithoutSmtpAccountInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutSmtpAccountInput | NotificationLogUpsertWithWhereUniqueWithoutSmtpAccountInput[]
    createMany?: NotificationLogCreateManySmtpAccountInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutSmtpAccountInput | NotificationLogUpdateWithWhereUniqueWithoutSmtpAccountInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutSmtpAccountInput | NotificationLogUpdateManyWithWhereWithoutSmtpAccountInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput> | ScheduledNotificationCreateWithoutSmtpAccountInput[] | ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput | ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutSmtpAccountInput | ScheduledNotificationUpsertWithWhereUniqueWithoutSmtpAccountInput[]
    createMany?: ScheduledNotificationCreateManySmtpAccountInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutSmtpAccountInput | ScheduledNotificationUpdateWithWhereUniqueWithoutSmtpAccountInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutSmtpAccountInput | ScheduledNotificationUpdateManyWithWhereWithoutSmtpAccountInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationTemplatesCreatedInput = {
    create?: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTemplatesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationLogCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput> | NotificationLogCreateWithoutPlantillaInput[] | NotificationLogUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutPlantillaInput | NotificationLogCreateOrConnectWithoutPlantillaInput[]
    createMany?: NotificationLogCreateManyPlantillaInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput> | ScheduledNotificationCreateWithoutPlantillaInput[] | ScheduledNotificationUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutPlantillaInput | ScheduledNotificationCreateOrConnectWithoutPlantillaInput[]
    createMany?: ScheduledNotificationCreateManyPlantillaInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type NotificationLogUncheckedCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput> | NotificationLogCreateWithoutPlantillaInput[] | NotificationLogUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutPlantillaInput | NotificationLogCreateOrConnectWithoutPlantillaInput[]
    createMany?: NotificationLogCreateManyPlantillaInputEnvelope
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
  }

  export type ScheduledNotificationUncheckedCreateNestedManyWithoutPlantillaInput = {
    create?: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput> | ScheduledNotificationCreateWithoutPlantillaInput[] | ScheduledNotificationUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutPlantillaInput | ScheduledNotificationCreateOrConnectWithoutPlantillaInput[]
    createMany?: ScheduledNotificationCreateManyPlantillaInputEnvelope
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutNotificationTemplatesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTemplatesCreatedInput
    upsert?: UserUpsertWithoutNotificationTemplatesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationTemplatesCreatedInput, UserUpdateWithoutNotificationTemplatesCreatedInput>, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
  }

  export type NotificationLogUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput> | NotificationLogCreateWithoutPlantillaInput[] | NotificationLogUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutPlantillaInput | NotificationLogCreateOrConnectWithoutPlantillaInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutPlantillaInput | NotificationLogUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: NotificationLogCreateManyPlantillaInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutPlantillaInput | NotificationLogUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutPlantillaInput | NotificationLogUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput> | ScheduledNotificationCreateWithoutPlantillaInput[] | ScheduledNotificationUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutPlantillaInput | ScheduledNotificationCreateOrConnectWithoutPlantillaInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutPlantillaInput | ScheduledNotificationUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: ScheduledNotificationCreateManyPlantillaInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutPlantillaInput | ScheduledNotificationUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutPlantillaInput | ScheduledNotificationUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type NotificationLogUncheckedUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput> | NotificationLogCreateWithoutPlantillaInput[] | NotificationLogUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: NotificationLogCreateOrConnectWithoutPlantillaInput | NotificationLogCreateOrConnectWithoutPlantillaInput[]
    upsert?: NotificationLogUpsertWithWhereUniqueWithoutPlantillaInput | NotificationLogUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: NotificationLogCreateManyPlantillaInputEnvelope
    set?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    disconnect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    delete?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    connect?: NotificationLogWhereUniqueInput | NotificationLogWhereUniqueInput[]
    update?: NotificationLogUpdateWithWhereUniqueWithoutPlantillaInput | NotificationLogUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: NotificationLogUpdateManyWithWhereWithoutPlantillaInput | NotificationLogUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutPlantillaNestedInput = {
    create?: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput> | ScheduledNotificationCreateWithoutPlantillaInput[] | ScheduledNotificationUncheckedCreateWithoutPlantillaInput[]
    connectOrCreate?: ScheduledNotificationCreateOrConnectWithoutPlantillaInput | ScheduledNotificationCreateOrConnectWithoutPlantillaInput[]
    upsert?: ScheduledNotificationUpsertWithWhereUniqueWithoutPlantillaInput | ScheduledNotificationUpsertWithWhereUniqueWithoutPlantillaInput[]
    createMany?: ScheduledNotificationCreateManyPlantillaInputEnvelope
    set?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    disconnect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    delete?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    connect?: ScheduledNotificationWhereUniqueInput | ScheduledNotificationWhereUniqueInput[]
    update?: ScheduledNotificationUpdateWithWhereUniqueWithoutPlantillaInput | ScheduledNotificationUpdateWithWhereUniqueWithoutPlantillaInput[]
    updateMany?: ScheduledNotificationUpdateManyWithWhereWithoutPlantillaInput | ScheduledNotificationUpdateManyWithWhereWithoutPlantillaInput[]
    deleteMany?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
  }

  export type NotificationTemplateCreateNestedOneWithoutLogsInput = {
    create?: XOR<NotificationTemplateCreateWithoutLogsInput, NotificationTemplateUncheckedCreateWithoutLogsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutLogsInput
    connect?: NotificationTemplateWhereUniqueInput
  }

  export type SMTPAccountCreateNestedOneWithoutLogsInput = {
    create?: XOR<SMTPAccountCreateWithoutLogsInput, SMTPAccountUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutLogsInput
    connect?: SMTPAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsSentInput = {
    create?: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationTemplateUpdateOneWithoutLogsNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutLogsInput, NotificationTemplateUncheckedCreateWithoutLogsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutLogsInput
    upsert?: NotificationTemplateUpsertWithoutLogsInput
    disconnect?: NotificationTemplateWhereInput | boolean
    delete?: NotificationTemplateWhereInput | boolean
    connect?: NotificationTemplateWhereUniqueInput
    update?: XOR<XOR<NotificationTemplateUpdateToOneWithWhereWithoutLogsInput, NotificationTemplateUpdateWithoutLogsInput>, NotificationTemplateUncheckedUpdateWithoutLogsInput>
  }

  export type SMTPAccountUpdateOneWithoutLogsNestedInput = {
    create?: XOR<SMTPAccountCreateWithoutLogsInput, SMTPAccountUncheckedCreateWithoutLogsInput>
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutLogsInput
    upsert?: SMTPAccountUpsertWithoutLogsInput
    disconnect?: SMTPAccountWhereInput | boolean
    delete?: SMTPAccountWhereInput | boolean
    connect?: SMTPAccountWhereUniqueInput
    update?: XOR<XOR<SMTPAccountUpdateToOneWithWhereWithoutLogsInput, SMTPAccountUpdateWithoutLogsInput>, SMTPAccountUncheckedUpdateWithoutLogsInput>
  }

  export type UserUpdateOneWithoutNotificationsSentNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsSentInput
    upsert?: UserUpsertWithoutNotificationsSentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsSentInput, UserUpdateWithoutNotificationsSentInput>, UserUncheckedUpdateWithoutNotificationsSentInput>
  }

  export type NotificationTemplateCreateNestedOneWithoutScheduledInput = {
    create?: XOR<NotificationTemplateCreateWithoutScheduledInput, NotificationTemplateUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutScheduledInput
    connect?: NotificationTemplateWhereUniqueInput
  }

  export type SMTPAccountCreateNestedOneWithoutScheduledInput = {
    create?: XOR<SMTPAccountCreateWithoutScheduledInput, SMTPAccountUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutScheduledInput
    connect?: SMTPAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutScheduledNotificationsCreatedInput = {
    create?: XOR<UserCreateWithoutScheduledNotificationsCreatedInput, UserUncheckedCreateWithoutScheduledNotificationsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledNotificationsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationTemplateUpdateOneRequiredWithoutScheduledNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutScheduledInput, NotificationTemplateUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutScheduledInput
    upsert?: NotificationTemplateUpsertWithoutScheduledInput
    connect?: NotificationTemplateWhereUniqueInput
    update?: XOR<XOR<NotificationTemplateUpdateToOneWithWhereWithoutScheduledInput, NotificationTemplateUpdateWithoutScheduledInput>, NotificationTemplateUncheckedUpdateWithoutScheduledInput>
  }

  export type SMTPAccountUpdateOneWithoutScheduledNestedInput = {
    create?: XOR<SMTPAccountCreateWithoutScheduledInput, SMTPAccountUncheckedCreateWithoutScheduledInput>
    connectOrCreate?: SMTPAccountCreateOrConnectWithoutScheduledInput
    upsert?: SMTPAccountUpsertWithoutScheduledInput
    disconnect?: SMTPAccountWhereInput | boolean
    delete?: SMTPAccountWhereInput | boolean
    connect?: SMTPAccountWhereUniqueInput
    update?: XOR<XOR<SMTPAccountUpdateToOneWithWhereWithoutScheduledInput, SMTPAccountUpdateWithoutScheduledInput>, SMTPAccountUncheckedUpdateWithoutScheduledInput>
  }

  export type UserUpdateOneWithoutScheduledNotificationsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutScheduledNotificationsCreatedInput, UserUncheckedCreateWithoutScheduledNotificationsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutScheduledNotificationsCreatedInput
    upsert?: UserUpsertWithoutScheduledNotificationsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutScheduledNotificationsCreatedInput, UserUpdateWithoutScheduledNotificationsCreatedInput>, UserUncheckedUpdateWithoutScheduledNotificationsCreatedInput>
  }

  export type UserCreateNestedOneWithoutBackupsCreatedInput = {
    create?: XOR<UserCreateWithoutBackupsCreatedInput, UserUncheckedCreateWithoutBackupsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBackupsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnumBackupStatusFieldUpdateOperationsInput = {
    set?: $Enums.BackupStatus
  }

  export type UserUpdateOneWithoutBackupsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutBackupsCreatedInput, UserUncheckedCreateWithoutBackupsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBackupsCreatedInput
    upsert?: UserUpsertWithoutBackupsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBackupsCreatedInput, UserUpdateWithoutBackupsCreatedInput>, UserUncheckedUpdateWithoutBackupsCreatedInput>
  }

  export type UserCreateNestedOneWithoutUpdatesInitiatedInput = {
    create?: XOR<UserCreateWithoutUpdatesInitiatedInput, UserUncheckedCreateWithoutUpdatesInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatesInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumUpdateStatusFieldUpdateOperationsInput = {
    set?: $Enums.UpdateStatus
  }

  export type UserUpdateOneWithoutUpdatesInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutUpdatesInitiatedInput, UserUncheckedCreateWithoutUpdatesInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatesInitiatedInput
    upsert?: UserUpsertWithoutUpdatesInitiatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatesInitiatedInput, UserUpdateWithoutUpdatesInitiatedInput>, UserUncheckedUpdateWithoutUpdatesInitiatedInput>
  }

  export type EnumStorageTypeFieldUpdateOperationsInput = {
    set?: $Enums.StorageType
  }

  export type ObligacionFiscalCreateNestedManyWithoutImpuestoInput = {
    create?: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput> | ObligacionFiscalCreateWithoutImpuestoInput[] | ObligacionFiscalUncheckedCreateWithoutImpuestoInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutImpuestoInput | ObligacionFiscalCreateOrConnectWithoutImpuestoInput[]
    createMany?: ObligacionFiscalCreateManyImpuestoInputEnvelope
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
  }

  export type ObligacionFiscalUncheckedCreateNestedManyWithoutImpuestoInput = {
    create?: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput> | ObligacionFiscalCreateWithoutImpuestoInput[] | ObligacionFiscalUncheckedCreateWithoutImpuestoInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutImpuestoInput | ObligacionFiscalCreateOrConnectWithoutImpuestoInput[]
    createMany?: ObligacionFiscalCreateManyImpuestoInputEnvelope
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
  }

  export type ObligacionFiscalUpdateManyWithoutImpuestoNestedInput = {
    create?: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput> | ObligacionFiscalCreateWithoutImpuestoInput[] | ObligacionFiscalUncheckedCreateWithoutImpuestoInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutImpuestoInput | ObligacionFiscalCreateOrConnectWithoutImpuestoInput[]
    upsert?: ObligacionFiscalUpsertWithWhereUniqueWithoutImpuestoInput | ObligacionFiscalUpsertWithWhereUniqueWithoutImpuestoInput[]
    createMany?: ObligacionFiscalCreateManyImpuestoInputEnvelope
    set?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    disconnect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    delete?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    update?: ObligacionFiscalUpdateWithWhereUniqueWithoutImpuestoInput | ObligacionFiscalUpdateWithWhereUniqueWithoutImpuestoInput[]
    updateMany?: ObligacionFiscalUpdateManyWithWhereWithoutImpuestoInput | ObligacionFiscalUpdateManyWithWhereWithoutImpuestoInput[]
    deleteMany?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
  }

  export type ObligacionFiscalUncheckedUpdateManyWithoutImpuestoNestedInput = {
    create?: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput> | ObligacionFiscalCreateWithoutImpuestoInput[] | ObligacionFiscalUncheckedCreateWithoutImpuestoInput[]
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutImpuestoInput | ObligacionFiscalCreateOrConnectWithoutImpuestoInput[]
    upsert?: ObligacionFiscalUpsertWithWhereUniqueWithoutImpuestoInput | ObligacionFiscalUpsertWithWhereUniqueWithoutImpuestoInput[]
    createMany?: ObligacionFiscalCreateManyImpuestoInputEnvelope
    set?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    disconnect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    delete?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    connect?: ObligacionFiscalWhereUniqueInput | ObligacionFiscalWhereUniqueInput[]
    update?: ObligacionFiscalUpdateWithWhereUniqueWithoutImpuestoInput | ObligacionFiscalUpdateWithWhereUniqueWithoutImpuestoInput[]
    updateMany?: ObligacionFiscalUpdateManyWithWhereWithoutImpuestoInput | ObligacionFiscalUpdateManyWithWhereWithoutImpuestoInput[]
    deleteMany?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutObligacionesFiscalesInput = {
    create?: XOR<ClientCreateWithoutObligacionesFiscalesInput, ClientUncheckedCreateWithoutObligacionesFiscalesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutObligacionesFiscalesInput
    connect?: ClientWhereUniqueInput
  }

  export type ImpuestoCreateNestedOneWithoutObligacionesInput = {
    create?: XOR<ImpuestoCreateWithoutObligacionesInput, ImpuestoUncheckedCreateWithoutObligacionesInput>
    connectOrCreate?: ImpuestoCreateOrConnectWithoutObligacionesInput
    connect?: ImpuestoWhereUniqueInput
  }

  export type DeclaracionCreateNestedManyWithoutObligacionInput = {
    create?: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput> | DeclaracionCreateWithoutObligacionInput[] | DeclaracionUncheckedCreateWithoutObligacionInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutObligacionInput | DeclaracionCreateOrConnectWithoutObligacionInput[]
    createMany?: DeclaracionCreateManyObligacionInputEnvelope
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
  }

  export type DeclaracionUncheckedCreateNestedManyWithoutObligacionInput = {
    create?: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput> | DeclaracionCreateWithoutObligacionInput[] | DeclaracionUncheckedCreateWithoutObligacionInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutObligacionInput | DeclaracionCreateOrConnectWithoutObligacionInput[]
    createMany?: DeclaracionCreateManyObligacionInputEnvelope
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
  }

  export type EnumPeriodicidadFieldUpdateOperationsInput = {
    set?: $Enums.Periodicidad
  }

  export type ClientUpdateOneRequiredWithoutObligacionesFiscalesNestedInput = {
    create?: XOR<ClientCreateWithoutObligacionesFiscalesInput, ClientUncheckedCreateWithoutObligacionesFiscalesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutObligacionesFiscalesInput
    upsert?: ClientUpsertWithoutObligacionesFiscalesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutObligacionesFiscalesInput, ClientUpdateWithoutObligacionesFiscalesInput>, ClientUncheckedUpdateWithoutObligacionesFiscalesInput>
  }

  export type ImpuestoUpdateOneRequiredWithoutObligacionesNestedInput = {
    create?: XOR<ImpuestoCreateWithoutObligacionesInput, ImpuestoUncheckedCreateWithoutObligacionesInput>
    connectOrCreate?: ImpuestoCreateOrConnectWithoutObligacionesInput
    upsert?: ImpuestoUpsertWithoutObligacionesInput
    connect?: ImpuestoWhereUniqueInput
    update?: XOR<XOR<ImpuestoUpdateToOneWithWhereWithoutObligacionesInput, ImpuestoUpdateWithoutObligacionesInput>, ImpuestoUncheckedUpdateWithoutObligacionesInput>
  }

  export type DeclaracionUpdateManyWithoutObligacionNestedInput = {
    create?: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput> | DeclaracionCreateWithoutObligacionInput[] | DeclaracionUncheckedCreateWithoutObligacionInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutObligacionInput | DeclaracionCreateOrConnectWithoutObligacionInput[]
    upsert?: DeclaracionUpsertWithWhereUniqueWithoutObligacionInput | DeclaracionUpsertWithWhereUniqueWithoutObligacionInput[]
    createMany?: DeclaracionCreateManyObligacionInputEnvelope
    set?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    disconnect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    delete?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    update?: DeclaracionUpdateWithWhereUniqueWithoutObligacionInput | DeclaracionUpdateWithWhereUniqueWithoutObligacionInput[]
    updateMany?: DeclaracionUpdateManyWithWhereWithoutObligacionInput | DeclaracionUpdateManyWithWhereWithoutObligacionInput[]
    deleteMany?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
  }

  export type DeclaracionUncheckedUpdateManyWithoutObligacionNestedInput = {
    create?: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput> | DeclaracionCreateWithoutObligacionInput[] | DeclaracionUncheckedCreateWithoutObligacionInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutObligacionInput | DeclaracionCreateOrConnectWithoutObligacionInput[]
    upsert?: DeclaracionUpsertWithWhereUniqueWithoutObligacionInput | DeclaracionUpsertWithWhereUniqueWithoutObligacionInput[]
    createMany?: DeclaracionCreateManyObligacionInputEnvelope
    set?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    disconnect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    delete?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    update?: DeclaracionUpdateWithWhereUniqueWithoutObligacionInput | DeclaracionUpdateWithWhereUniqueWithoutObligacionInput[]
    updateMany?: DeclaracionUpdateManyWithWhereWithoutObligacionInput | DeclaracionUpdateManyWithWhereWithoutObligacionInput[]
    deleteMany?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
  }

  export type DeclaracionCreateNestedManyWithoutCalendarioInput = {
    create?: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput> | DeclaracionCreateWithoutCalendarioInput[] | DeclaracionUncheckedCreateWithoutCalendarioInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutCalendarioInput | DeclaracionCreateOrConnectWithoutCalendarioInput[]
    createMany?: DeclaracionCreateManyCalendarioInputEnvelope
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
  }

  export type DeclaracionUncheckedCreateNestedManyWithoutCalendarioInput = {
    create?: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput> | DeclaracionCreateWithoutCalendarioInput[] | DeclaracionUncheckedCreateWithoutCalendarioInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutCalendarioInput | DeclaracionCreateOrConnectWithoutCalendarioInput[]
    createMany?: DeclaracionCreateManyCalendarioInputEnvelope
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
  }

  export type DeclaracionUpdateManyWithoutCalendarioNestedInput = {
    create?: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput> | DeclaracionCreateWithoutCalendarioInput[] | DeclaracionUncheckedCreateWithoutCalendarioInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutCalendarioInput | DeclaracionCreateOrConnectWithoutCalendarioInput[]
    upsert?: DeclaracionUpsertWithWhereUniqueWithoutCalendarioInput | DeclaracionUpsertWithWhereUniqueWithoutCalendarioInput[]
    createMany?: DeclaracionCreateManyCalendarioInputEnvelope
    set?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    disconnect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    delete?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    update?: DeclaracionUpdateWithWhereUniqueWithoutCalendarioInput | DeclaracionUpdateWithWhereUniqueWithoutCalendarioInput[]
    updateMany?: DeclaracionUpdateManyWithWhereWithoutCalendarioInput | DeclaracionUpdateManyWithWhereWithoutCalendarioInput[]
    deleteMany?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
  }

  export type DeclaracionUncheckedUpdateManyWithoutCalendarioNestedInput = {
    create?: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput> | DeclaracionCreateWithoutCalendarioInput[] | DeclaracionUncheckedCreateWithoutCalendarioInput[]
    connectOrCreate?: DeclaracionCreateOrConnectWithoutCalendarioInput | DeclaracionCreateOrConnectWithoutCalendarioInput[]
    upsert?: DeclaracionUpsertWithWhereUniqueWithoutCalendarioInput | DeclaracionUpsertWithWhereUniqueWithoutCalendarioInput[]
    createMany?: DeclaracionCreateManyCalendarioInputEnvelope
    set?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    disconnect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    delete?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    connect?: DeclaracionWhereUniqueInput | DeclaracionWhereUniqueInput[]
    update?: DeclaracionUpdateWithWhereUniqueWithoutCalendarioInput | DeclaracionUpdateWithWhereUniqueWithoutCalendarioInput[]
    updateMany?: DeclaracionUpdateManyWithWhereWithoutCalendarioInput | DeclaracionUpdateManyWithWhereWithoutCalendarioInput[]
    deleteMany?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
  }

  export type ObligacionFiscalCreateNestedOneWithoutDeclaracionesInput = {
    create?: XOR<ObligacionFiscalCreateWithoutDeclaracionesInput, ObligacionFiscalUncheckedCreateWithoutDeclaracionesInput>
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutDeclaracionesInput
    connect?: ObligacionFiscalWhereUniqueInput
  }

  export type CalendarioAEATCreateNestedOneWithoutDeclaracionesInput = {
    create?: XOR<CalendarioAEATCreateWithoutDeclaracionesInput, CalendarioAEATUncheckedCreateWithoutDeclaracionesInput>
    connectOrCreate?: CalendarioAEATCreateOrConnectWithoutDeclaracionesInput
    connect?: CalendarioAEATWhereUniqueInput
  }

  export type EnumEstadoDeclaracionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoDeclaracion
  }

  export type ObligacionFiscalUpdateOneRequiredWithoutDeclaracionesNestedInput = {
    create?: XOR<ObligacionFiscalCreateWithoutDeclaracionesInput, ObligacionFiscalUncheckedCreateWithoutDeclaracionesInput>
    connectOrCreate?: ObligacionFiscalCreateOrConnectWithoutDeclaracionesInput
    upsert?: ObligacionFiscalUpsertWithoutDeclaracionesInput
    connect?: ObligacionFiscalWhereUniqueInput
    update?: XOR<XOR<ObligacionFiscalUpdateToOneWithWhereWithoutDeclaracionesInput, ObligacionFiscalUpdateWithoutDeclaracionesInput>, ObligacionFiscalUncheckedUpdateWithoutDeclaracionesInput>
  }

  export type CalendarioAEATUpdateOneRequiredWithoutDeclaracionesNestedInput = {
    create?: XOR<CalendarioAEATCreateWithoutDeclaracionesInput, CalendarioAEATUncheckedCreateWithoutDeclaracionesInput>
    connectOrCreate?: CalendarioAEATCreateOrConnectWithoutDeclaracionesInput
    upsert?: CalendarioAEATUpsertWithoutDeclaracionesInput
    connect?: CalendarioAEATWhereUniqueInput
    update?: XOR<XOR<CalendarioAEATUpdateToOneWithWhereWithoutDeclaracionesInput, CalendarioAEATUpdateWithoutDeclaracionesInput>, CalendarioAEATUncheckedUpdateWithoutDeclaracionesInput>
  }

  export type ClientCreateNestedOneWithoutNotificacionesInput = {
    create?: XOR<ClientCreateWithoutNotificacionesInput, ClientUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificacionesInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumTipoNotificacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoNotificacion
  }

  export type ClientUpdateOneRequiredWithoutNotificacionesNestedInput = {
    create?: XOR<ClientCreateWithoutNotificacionesInput, ClientUncheckedCreateWithoutNotificacionesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutNotificacionesInput
    upsert?: ClientUpsertWithoutNotificacionesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutNotificacionesInput, ClientUpdateWithoutNotificacionesInput>, ClientUncheckedUpdateWithoutNotificacionesInput>
  }

  export type taxPeriodCreateNestedManyWithoutModeloInput = {
    create?: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput> | taxPeriodCreateWithoutModeloInput[] | taxPeriodUncheckedCreateWithoutModeloInput[]
    connectOrCreate?: taxPeriodCreateOrConnectWithoutModeloInput | taxPeriodCreateOrConnectWithoutModeloInput[]
    createMany?: taxPeriodCreateManyModeloInputEnvelope
    connect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
  }

  export type taxPeriodUncheckedCreateNestedManyWithoutModeloInput = {
    create?: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput> | taxPeriodCreateWithoutModeloInput[] | taxPeriodUncheckedCreateWithoutModeloInput[]
    connectOrCreate?: taxPeriodCreateOrConnectWithoutModeloInput | taxPeriodCreateOrConnectWithoutModeloInput[]
    createMany?: taxPeriodCreateManyModeloInputEnvelope
    connect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
  }

  export type taxPeriodUpdateManyWithoutModeloNestedInput = {
    create?: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput> | taxPeriodCreateWithoutModeloInput[] | taxPeriodUncheckedCreateWithoutModeloInput[]
    connectOrCreate?: taxPeriodCreateOrConnectWithoutModeloInput | taxPeriodCreateOrConnectWithoutModeloInput[]
    upsert?: taxPeriodUpsertWithWhereUniqueWithoutModeloInput | taxPeriodUpsertWithWhereUniqueWithoutModeloInput[]
    createMany?: taxPeriodCreateManyModeloInputEnvelope
    set?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    disconnect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    delete?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    connect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    update?: taxPeriodUpdateWithWhereUniqueWithoutModeloInput | taxPeriodUpdateWithWhereUniqueWithoutModeloInput[]
    updateMany?: taxPeriodUpdateManyWithWhereWithoutModeloInput | taxPeriodUpdateManyWithWhereWithoutModeloInput[]
    deleteMany?: taxPeriodScalarWhereInput | taxPeriodScalarWhereInput[]
  }

  export type taxPeriodUncheckedUpdateManyWithoutModeloNestedInput = {
    create?: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput> | taxPeriodCreateWithoutModeloInput[] | taxPeriodUncheckedCreateWithoutModeloInput[]
    connectOrCreate?: taxPeriodCreateOrConnectWithoutModeloInput | taxPeriodCreateOrConnectWithoutModeloInput[]
    upsert?: taxPeriodUpsertWithWhereUniqueWithoutModeloInput | taxPeriodUpsertWithWhereUniqueWithoutModeloInput[]
    createMany?: taxPeriodCreateManyModeloInputEnvelope
    set?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    disconnect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    delete?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    connect?: taxPeriodWhereUniqueInput | taxPeriodWhereUniqueInput[]
    update?: taxPeriodUpdateWithWhereUniqueWithoutModeloInput | taxPeriodUpdateWithWhereUniqueWithoutModeloInput[]
    updateMany?: taxPeriodUpdateManyWithWhereWithoutModeloInput | taxPeriodUpdateManyWithWhereWithoutModeloInput[]
    deleteMany?: taxPeriodScalarWhereInput | taxPeriodScalarWhereInput[]
  }

  export type taxModelCreateNestedOneWithoutPeriodsInput = {
    create?: XOR<taxModelCreateWithoutPeriodsInput, taxModelUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: taxModelCreateOrConnectWithoutPeriodsInput
    connect?: taxModelWhereUniqueInput
  }

  export type clientTaxCreateNestedManyWithoutPeriodInput = {
    create?: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput> | clientTaxCreateWithoutPeriodInput[] | clientTaxUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutPeriodInput | clientTaxCreateOrConnectWithoutPeriodInput[]
    createMany?: clientTaxCreateManyPeriodInputEnvelope
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
  }

  export type clientTaxUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput> | clientTaxCreateWithoutPeriodInput[] | clientTaxUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutPeriodInput | clientTaxCreateOrConnectWithoutPeriodInput[]
    createMany?: clientTaxCreateManyPeriodInputEnvelope
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
  }

  export type taxModelUpdateOneRequiredWithoutPeriodsNestedInput = {
    create?: XOR<taxModelCreateWithoutPeriodsInput, taxModelUncheckedCreateWithoutPeriodsInput>
    connectOrCreate?: taxModelCreateOrConnectWithoutPeriodsInput
    upsert?: taxModelUpsertWithoutPeriodsInput
    connect?: taxModelWhereUniqueInput
    update?: XOR<XOR<taxModelUpdateToOneWithWhereWithoutPeriodsInput, taxModelUpdateWithoutPeriodsInput>, taxModelUncheckedUpdateWithoutPeriodsInput>
  }

  export type clientTaxUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput> | clientTaxCreateWithoutPeriodInput[] | clientTaxUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutPeriodInput | clientTaxCreateOrConnectWithoutPeriodInput[]
    upsert?: clientTaxUpsertWithWhereUniqueWithoutPeriodInput | clientTaxUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: clientTaxCreateManyPeriodInputEnvelope
    set?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    disconnect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    delete?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    update?: clientTaxUpdateWithWhereUniqueWithoutPeriodInput | clientTaxUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: clientTaxUpdateManyWithWhereWithoutPeriodInput | clientTaxUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
  }

  export type clientTaxUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput> | clientTaxCreateWithoutPeriodInput[] | clientTaxUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxCreateOrConnectWithoutPeriodInput | clientTaxCreateOrConnectWithoutPeriodInput[]
    upsert?: clientTaxUpsertWithWhereUniqueWithoutPeriodInput | clientTaxUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: clientTaxCreateManyPeriodInputEnvelope
    set?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    disconnect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    delete?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    connect?: clientTaxWhereUniqueInput | clientTaxWhereUniqueInput[]
    update?: clientTaxUpdateWithWhereUniqueWithoutPeriodInput | clientTaxUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: clientTaxUpdateManyWithWhereWithoutPeriodInput | clientTaxUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutClientTaxesInput = {
    create?: XOR<ClientCreateWithoutClientTaxesInput, ClientUncheckedCreateWithoutClientTaxesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTaxesInput
    connect?: ClientWhereUniqueInput
  }

  export type taxPeriodCreateNestedOneWithoutClientTaxesInput = {
    create?: XOR<taxPeriodCreateWithoutClientTaxesInput, taxPeriodUncheckedCreateWithoutClientTaxesInput>
    connectOrCreate?: taxPeriodCreateOrConnectWithoutClientTaxesInput
    connect?: taxPeriodWhereUniqueInput
  }

  export type taxFileCreateNestedManyWithoutClientTaxInput = {
    create?: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput> | taxFileCreateWithoutClientTaxInput[] | taxFileUncheckedCreateWithoutClientTaxInput[]
    connectOrCreate?: taxFileCreateOrConnectWithoutClientTaxInput | taxFileCreateOrConnectWithoutClientTaxInput[]
    createMany?: taxFileCreateManyClientTaxInputEnvelope
    connect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
  }

  export type taxFileUncheckedCreateNestedManyWithoutClientTaxInput = {
    create?: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput> | taxFileCreateWithoutClientTaxInput[] | taxFileUncheckedCreateWithoutClientTaxInput[]
    connectOrCreate?: taxFileCreateOrConnectWithoutClientTaxInput | taxFileCreateOrConnectWithoutClientTaxInput[]
    createMany?: taxFileCreateManyClientTaxInputEnvelope
    connect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutClientTaxesNestedInput = {
    create?: XOR<ClientCreateWithoutClientTaxesInput, ClientUncheckedCreateWithoutClientTaxesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTaxesInput
    upsert?: ClientUpsertWithoutClientTaxesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientTaxesInput, ClientUpdateWithoutClientTaxesInput>, ClientUncheckedUpdateWithoutClientTaxesInput>
  }

  export type taxPeriodUpdateOneRequiredWithoutClientTaxesNestedInput = {
    create?: XOR<taxPeriodCreateWithoutClientTaxesInput, taxPeriodUncheckedCreateWithoutClientTaxesInput>
    connectOrCreate?: taxPeriodCreateOrConnectWithoutClientTaxesInput
    upsert?: taxPeriodUpsertWithoutClientTaxesInput
    connect?: taxPeriodWhereUniqueInput
    update?: XOR<XOR<taxPeriodUpdateToOneWithWhereWithoutClientTaxesInput, taxPeriodUpdateWithoutClientTaxesInput>, taxPeriodUncheckedUpdateWithoutClientTaxesInput>
  }

  export type taxFileUpdateManyWithoutClientTaxNestedInput = {
    create?: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput> | taxFileCreateWithoutClientTaxInput[] | taxFileUncheckedCreateWithoutClientTaxInput[]
    connectOrCreate?: taxFileCreateOrConnectWithoutClientTaxInput | taxFileCreateOrConnectWithoutClientTaxInput[]
    upsert?: taxFileUpsertWithWhereUniqueWithoutClientTaxInput | taxFileUpsertWithWhereUniqueWithoutClientTaxInput[]
    createMany?: taxFileCreateManyClientTaxInputEnvelope
    set?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    disconnect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    delete?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    connect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    update?: taxFileUpdateWithWhereUniqueWithoutClientTaxInput | taxFileUpdateWithWhereUniqueWithoutClientTaxInput[]
    updateMany?: taxFileUpdateManyWithWhereWithoutClientTaxInput | taxFileUpdateManyWithWhereWithoutClientTaxInput[]
    deleteMany?: taxFileScalarWhereInput | taxFileScalarWhereInput[]
  }

  export type taxFileUncheckedUpdateManyWithoutClientTaxNestedInput = {
    create?: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput> | taxFileCreateWithoutClientTaxInput[] | taxFileUncheckedCreateWithoutClientTaxInput[]
    connectOrCreate?: taxFileCreateOrConnectWithoutClientTaxInput | taxFileCreateOrConnectWithoutClientTaxInput[]
    upsert?: taxFileUpsertWithWhereUniqueWithoutClientTaxInput | taxFileUpsertWithWhereUniqueWithoutClientTaxInput[]
    createMany?: taxFileCreateManyClientTaxInputEnvelope
    set?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    disconnect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    delete?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    connect?: taxFileWhereUniqueInput | taxFileWhereUniqueInput[]
    update?: taxFileUpdateWithWhereUniqueWithoutClientTaxInput | taxFileUpdateWithWhereUniqueWithoutClientTaxInput[]
    updateMany?: taxFileUpdateManyWithWhereWithoutClientTaxInput | taxFileUpdateManyWithWhereWithoutClientTaxInput[]
    deleteMany?: taxFileScalarWhereInput | taxFileScalarWhereInput[]
  }

  export type clientTaxCreateNestedOneWithoutFilesInput = {
    create?: XOR<clientTaxCreateWithoutFilesInput, clientTaxUncheckedCreateWithoutFilesInput>
    connectOrCreate?: clientTaxCreateOrConnectWithoutFilesInput
    connect?: clientTaxWhereUniqueInput
  }

  export type clientTaxUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<clientTaxCreateWithoutFilesInput, clientTaxUncheckedCreateWithoutFilesInput>
    connectOrCreate?: clientTaxCreateOrConnectWithoutFilesInput
    upsert?: clientTaxUpsertWithoutFilesInput
    connect?: clientTaxWhereUniqueInput
    update?: XOR<XOR<clientTaxUpdateToOneWithWhereWithoutFilesInput, clientTaxUpdateWithoutFilesInput>, clientTaxUncheckedUpdateWithoutFilesInput>
  }

  export type ClientCreateNestedOneWithoutClientTaxRequirementsInput = {
    create?: XOR<ClientCreateWithoutClientTaxRequirementsInput, ClientUncheckedCreateWithoutClientTaxRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTaxRequirementsInput
    connect?: ClientWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutClientTaxRequirementsNestedInput = {
    create?: XOR<ClientCreateWithoutClientTaxRequirementsInput, ClientUncheckedCreateWithoutClientTaxRequirementsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutClientTaxRequirementsInput
    upsert?: ClientUpsertWithoutClientTaxRequirementsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutClientTaxRequirementsInput, ClientUpdateWithoutClientTaxRequirementsInput>, ClientUncheckedUpdateWithoutClientTaxRequirementsInput>
  }

  export type clientTaxFilingCreateNestedManyWithoutPeriodInput = {
    create?: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput> | clientTaxFilingCreateWithoutPeriodInput[] | clientTaxFilingUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutPeriodInput | clientTaxFilingCreateOrConnectWithoutPeriodInput[]
    createMany?: clientTaxFilingCreateManyPeriodInputEnvelope
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
  }

  export type clientTaxFilingUncheckedCreateNestedManyWithoutPeriodInput = {
    create?: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput> | clientTaxFilingCreateWithoutPeriodInput[] | clientTaxFilingUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutPeriodInput | clientTaxFilingCreateOrConnectWithoutPeriodInput[]
    createMany?: clientTaxFilingCreateManyPeriodInputEnvelope
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
  }

  export type clientTaxFilingUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput> | clientTaxFilingCreateWithoutPeriodInput[] | clientTaxFilingUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutPeriodInput | clientTaxFilingCreateOrConnectWithoutPeriodInput[]
    upsert?: clientTaxFilingUpsertWithWhereUniqueWithoutPeriodInput | clientTaxFilingUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: clientTaxFilingCreateManyPeriodInputEnvelope
    set?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    disconnect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    delete?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    update?: clientTaxFilingUpdateWithWhereUniqueWithoutPeriodInput | clientTaxFilingUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: clientTaxFilingUpdateManyWithWhereWithoutPeriodInput | clientTaxFilingUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
  }

  export type clientTaxFilingUncheckedUpdateManyWithoutPeriodNestedInput = {
    create?: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput> | clientTaxFilingCreateWithoutPeriodInput[] | clientTaxFilingUncheckedCreateWithoutPeriodInput[]
    connectOrCreate?: clientTaxFilingCreateOrConnectWithoutPeriodInput | clientTaxFilingCreateOrConnectWithoutPeriodInput[]
    upsert?: clientTaxFilingUpsertWithWhereUniqueWithoutPeriodInput | clientTaxFilingUpsertWithWhereUniqueWithoutPeriodInput[]
    createMany?: clientTaxFilingCreateManyPeriodInputEnvelope
    set?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    disconnect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    delete?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    connect?: clientTaxFilingWhereUniqueInput | clientTaxFilingWhereUniqueInput[]
    update?: clientTaxFilingUpdateWithWhereUniqueWithoutPeriodInput | clientTaxFilingUpdateWithWhereUniqueWithoutPeriodInput[]
    updateMany?: clientTaxFilingUpdateManyWithWhereWithoutPeriodInput | clientTaxFilingUpdateManyWithWhereWithoutPeriodInput[]
    deleteMany?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutTaxFilingsInput = {
    create?: XOR<ClientCreateWithoutTaxFilingsInput, ClientUncheckedCreateWithoutTaxFilingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTaxFilingsInput
    connect?: ClientWhereUniqueInput
  }

  export type fiscalPeriodCreateNestedOneWithoutFilingsInput = {
    create?: XOR<fiscalPeriodCreateWithoutFilingsInput, fiscalPeriodUncheckedCreateWithoutFilingsInput>
    connectOrCreate?: fiscalPeriodCreateOrConnectWithoutFilingsInput
    connect?: fiscalPeriodWhereUniqueInput
  }

  export type ClientUpdateOneWithoutTaxFilingsNestedInput = {
    create?: XOR<ClientCreateWithoutTaxFilingsInput, ClientUncheckedCreateWithoutTaxFilingsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutTaxFilingsInput
    upsert?: ClientUpsertWithoutTaxFilingsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutTaxFilingsInput, ClientUpdateWithoutTaxFilingsInput>, ClientUncheckedUpdateWithoutTaxFilingsInput>
  }

  export type fiscalPeriodUpdateOneWithoutFilingsNestedInput = {
    create?: XOR<fiscalPeriodCreateWithoutFilingsInput, fiscalPeriodUncheckedCreateWithoutFilingsInput>
    connectOrCreate?: fiscalPeriodCreateOrConnectWithoutFilingsInput
    upsert?: fiscalPeriodUpsertWithoutFilingsInput
    disconnect?: fiscalPeriodWhereInput | boolean
    delete?: fiscalPeriodWhereInput | boolean
    connect?: fiscalPeriodWhereUniqueInput
    update?: XOR<XOR<fiscalPeriodUpdateToOneWithWhereWithoutFilingsInput, fiscalPeriodUpdateWithoutFilingsInput>, fiscalPeriodUncheckedUpdateWithoutFilingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[]
    notIn?: $Enums.ClientType[]
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTaskPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityFilter<$PrismaModel> | $Enums.TaskPriority
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskVisibility | EnumTaskVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskVisibility[]
    notIn?: $Enums.TaskVisibility[]
    not?: NestedEnumTaskVisibilityFilter<$PrismaModel> | $Enums.TaskVisibility
  }

  export type NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskPriority | EnumTaskPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskPriority[]
    notIn?: $Enums.TaskPriority[]
    not?: NestedEnumTaskPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TaskPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskPriorityFilter<$PrismaModel>
    _max?: NestedEnumTaskPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[]
    notIn?: $Enums.TaskStatus[]
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumTaskVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskVisibility | EnumTaskVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.TaskVisibility[]
    notIn?: $Enums.TaskVisibility[]
    not?: NestedEnumTaskVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.TaskVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskVisibilityFilter<$PrismaModel>
    _max?: NestedEnumTaskVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumManualStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ManualStatus | EnumManualStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ManualStatus[]
    notIn?: $Enums.ManualStatus[]
    not?: NestedEnumManualStatusFilter<$PrismaModel> | $Enums.ManualStatus
  }

  export type NestedEnumManualStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ManualStatus | EnumManualStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ManualStatus[]
    notIn?: $Enums.ManualStatus[]
    not?: NestedEnumManualStatusWithAggregatesFilter<$PrismaModel> | $Enums.ManualStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumManualStatusFilter<$PrismaModel>
    _max?: NestedEnumManualStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[]
    notIn?: $Enums.AuditAction[]
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumBackupStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupStatus | EnumBackupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackupStatus[]
    notIn?: $Enums.BackupStatus[]
    not?: NestedEnumBackupStatusFilter<$PrismaModel> | $Enums.BackupStatus
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumBackupStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BackupStatus | EnumBackupStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BackupStatus[]
    notIn?: $Enums.BackupStatus[]
    not?: NestedEnumBackupStatusWithAggregatesFilter<$PrismaModel> | $Enums.BackupStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBackupStatusFilter<$PrismaModel>
    _max?: NestedEnumBackupStatusFilter<$PrismaModel>
  }

  export type NestedEnumUpdateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateStatus | EnumUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateStatus[]
    notIn?: $Enums.UpdateStatus[]
    not?: NestedEnumUpdateStatusFilter<$PrismaModel> | $Enums.UpdateStatus
  }

  export type NestedEnumUpdateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UpdateStatus | EnumUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UpdateStatus[]
    notIn?: $Enums.UpdateStatus[]
    not?: NestedEnumUpdateStatusWithAggregatesFilter<$PrismaModel> | $Enums.UpdateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUpdateStatusFilter<$PrismaModel>
    _max?: NestedEnumUpdateStatusFilter<$PrismaModel>
  }

  export type NestedEnumStorageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeFilter<$PrismaModel> | $Enums.StorageType
  }

  export type NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StorageType | EnumStorageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StorageType[]
    notIn?: $Enums.StorageType[]
    not?: NestedEnumStorageTypeWithAggregatesFilter<$PrismaModel> | $Enums.StorageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStorageTypeFilter<$PrismaModel>
    _max?: NestedEnumStorageTypeFilter<$PrismaModel>
  }

  export type NestedEnumPeriodicidadFilter<$PrismaModel = never> = {
    equals?: $Enums.Periodicidad | EnumPeriodicidadFieldRefInput<$PrismaModel>
    in?: $Enums.Periodicidad[]
    notIn?: $Enums.Periodicidad[]
    not?: NestedEnumPeriodicidadFilter<$PrismaModel> | $Enums.Periodicidad
  }

  export type NestedEnumPeriodicidadWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Periodicidad | EnumPeriodicidadFieldRefInput<$PrismaModel>
    in?: $Enums.Periodicidad[]
    notIn?: $Enums.Periodicidad[]
    not?: NestedEnumPeriodicidadWithAggregatesFilter<$PrismaModel> | $Enums.Periodicidad
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPeriodicidadFilter<$PrismaModel>
    _max?: NestedEnumPeriodicidadFilter<$PrismaModel>
  }

  export type NestedEnumEstadoDeclaracionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDeclaracion | EnumEstadoDeclaracionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDeclaracion[]
    notIn?: $Enums.EstadoDeclaracion[]
    not?: NestedEnumEstadoDeclaracionFilter<$PrismaModel> | $Enums.EstadoDeclaracion
  }

  export type NestedEnumEstadoDeclaracionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDeclaracion | EnumEstadoDeclaracionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDeclaracion[]
    notIn?: $Enums.EstadoDeclaracion[]
    not?: NestedEnumEstadoDeclaracionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDeclaracion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDeclaracionFilter<$PrismaModel>
    _max?: NestedEnumEstadoDeclaracionFilter<$PrismaModel>
  }

  export type NestedEnumTipoNotificacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionFilter<$PrismaModel> | $Enums.TipoNotificacion
  }

  export type NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoNotificacion | EnumTipoNotificacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoNotificacion[]
    notIn?: $Enums.TipoNotificacion[]
    not?: NestedEnumTipoNotificacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoNotificacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoNotificacionFilter<$PrismaModel>
    _max?: NestedEnumTipoNotificacionFilter<$PrismaModel>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionCreateWithoutRoleInput = {
    id?: string
    createdAt?: Date | string
    permission: PermissionCreateNestedOneWithoutRolesInput
  }

  export type RolePermissionUncheckedCreateWithoutRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionCreateManyRoleInputEnvelope = {
    data: RolePermissionCreateManyRoleInput | RolePermissionCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    roleId?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
    create: XOR<RolePermissionCreateWithoutRoleInput, RolePermissionUncheckedCreateWithoutRoleInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutRoleInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutRoleInput, RolePermissionUncheckedUpdateWithoutRoleInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutRoleInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutRoleInput>
  }

  export type RolePermissionScalarWhereInput = {
    AND?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    OR?: RolePermissionScalarWhereInput[]
    NOT?: RolePermissionScalarWhereInput | RolePermissionScalarWhereInput[]
    id?: StringFilter<"RolePermission"> | string
    roleId?: StringFilter<"RolePermission"> | string
    permissionId?: StringFilter<"RolePermission"> | string
    createdAt?: DateTimeFilter<"RolePermission"> | Date | string
  }

  export type RolePermissionCreateWithoutPermissionInput = {
    id?: string
    createdAt?: Date | string
    role: RoleCreateNestedOneWithoutPermissionsInput
  }

  export type RolePermissionUncheckedCreateWithoutPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionCreateOrConnectWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionCreateManyPermissionInputEnvelope = {
    data: RolePermissionCreateManyPermissionInput | RolePermissionCreateManyPermissionInput[]
    skipDuplicates?: boolean
  }

  export type RolePermissionUpsertWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    update: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
    create: XOR<RolePermissionCreateWithoutPermissionInput, RolePermissionUncheckedCreateWithoutPermissionInput>
  }

  export type RolePermissionUpdateWithWhereUniqueWithoutPermissionInput = {
    where: RolePermissionWhereUniqueInput
    data: XOR<RolePermissionUpdateWithoutPermissionInput, RolePermissionUncheckedUpdateWithoutPermissionInput>
  }

  export type RolePermissionUpdateManyWithWhereWithoutPermissionInput = {
    where: RolePermissionScalarWhereInput
    data: XOR<RolePermissionUpdateManyMutationInput, RolePermissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type RoleCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutPermissionsInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
  }

  export type PermissionCreateWithoutRolesInput = {
    id?: string
    resource: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    id?: string
    resource: string
    action: string
    description?: string | null
    createdAt?: Date | string
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type RoleUpsertWithoutPermissionsInput = {
    update: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<RoleCreateWithoutPermissionsInput, RoleUncheckedCreateWithoutPermissionsInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutPermissionsInput, RoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type RoleUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type PermissionUpsertWithoutRolesInput = {
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
    where?: PermissionWhereInput
  }

  export type PermissionUpdateToOneWithWhereWithoutRolesInput = {
    where?: PermissionWhereInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    isSystem?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: RolePermissionUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ClientCreateWithoutResponsableInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutResponsableInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutResponsableInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput>
  }

  export type ClientCreateManyResponsableInputEnvelope = {
    data: ClientCreateManyResponsableInput | ClientCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type ClientEmployeeCreateWithoutUserInput = {
    isPrimary?: boolean
    assignedAt?: Date | string
    client: ClientCreateNestedOneWithoutEmployeesInput
  }

  export type ClientEmployeeUncheckedCreateWithoutUserInput = {
    clientId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type ClientEmployeeCreateOrConnectWithoutUserInput = {
    where: ClientEmployeeWhereUniqueInput
    create: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput>
  }

  export type ClientEmployeeCreateManyUserInputEnvelope = {
    data: ClientEmployeeCreateManyUserInput | ClientEmployeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutAsignadoInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    cliente?: ClientCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAsignadoInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    clienteId?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type TaskCreateOrConnectWithoutAsignadoInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput>
  }

  export type TaskCreateManyAsignadoInputEnvelope = {
    data: TaskCreateManyAsignadoInput | TaskCreateManyAsignadoInput[]
    skipDuplicates?: boolean
  }

  export type ManualCreateWithoutAutorInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    attachments?: ManualAttachmentCreateNestedManyWithoutManualInput
    versions?: ManualVersionCreateNestedManyWithoutManualInput
  }

  export type ManualUncheckedCreateWithoutAutorInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    attachments?: ManualAttachmentUncheckedCreateNestedManyWithoutManualInput
    versions?: ManualVersionUncheckedCreateNestedManyWithoutManualInput
  }

  export type ManualCreateOrConnectWithoutAutorInput = {
    where: ManualWhereUniqueInput
    create: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput>
  }

  export type ManualCreateManyAutorInputEnvelope = {
    data: ManualCreateManyAutorInput | ManualCreateManyAutorInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUsuarioInput = {
    id?: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUsuarioInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput>
  }

  export type ActivityLogCreateManyUsuarioInputEnvelope = {
    data: ActivityLogCreateManyUsuarioInput | ActivityLogCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type AuditTrailCreateWithoutUsuarioInput = {
    id?: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
  }

  export type AuditTrailUncheckedCreateWithoutUsuarioInput = {
    id?: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
  }

  export type AuditTrailCreateOrConnectWithoutUsuarioInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput>
  }

  export type AuditTrailCreateManyUsuarioInputEnvelope = {
    data: AuditTrailCreateManyUsuarioInput | AuditTrailCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type SMTPAccountCreateWithoutCreadorInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
    logs?: NotificationLogCreateNestedManyWithoutSmtpAccountInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountUncheckedCreateWithoutCreadorInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutSmtpAccountInput
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountCreateOrConnectWithoutCreadorInput = {
    where: SMTPAccountWhereUniqueInput
    create: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput>
  }

  export type SMTPAccountCreateManyCreadorInputEnvelope = {
    data: SMTPAccountCreateManyCreadorInput | SMTPAccountCreateManyCreadorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTemplateCreateWithoutCreadorInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    logs?: NotificationLogCreateNestedManyWithoutPlantillaInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateUncheckedCreateWithoutCreadorInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutPlantillaInput
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateCreateOrConnectWithoutCreadorInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput>
  }

  export type NotificationTemplateCreateManyCreadorInputEnvelope = {
    data: NotificationTemplateCreateManyCreadorInput | NotificationTemplateCreateManyCreadorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationLogCreateWithoutEnviadorInput = {
    id?: string
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateCreateNestedOneWithoutLogsInput
    smtpAccount?: SMTPAccountCreateNestedOneWithoutLogsInput
  }

  export type NotificationLogUncheckedCreateWithoutEnviadorInput = {
    id?: string
    plantillaId?: string | null
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogCreateOrConnectWithoutEnviadorInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput>
  }

  export type NotificationLogCreateManyEnviadorInputEnvelope = {
    data: NotificationLogCreateManyEnviadorInput | NotificationLogCreateManyEnviadorInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledNotificationCreateWithoutCreadorInput = {
    id?: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
    plantilla: NotificationTemplateCreateNestedOneWithoutScheduledInput
    smtpAccount?: SMTPAccountCreateNestedOneWithoutScheduledInput
  }

  export type ScheduledNotificationUncheckedCreateWithoutCreadorInput = {
    id?: string
    plantillaId: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
  }

  export type ScheduledNotificationCreateOrConnectWithoutCreadorInput = {
    where: ScheduledNotificationWhereUniqueInput
    create: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput>
  }

  export type ScheduledNotificationCreateManyCreadorInputEnvelope = {
    data: ScheduledNotificationCreateManyCreadorInput | ScheduledNotificationCreateManyCreadorInput[]
    skipDuplicates?: boolean
  }

  export type SystemBackupCreateWithoutCreatorInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemBackupUncheckedCreateWithoutCreatorInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemBackupCreateOrConnectWithoutCreatorInput = {
    where: SystemBackupWhereUniqueInput
    create: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput>
  }

  export type SystemBackupCreateManyCreatorInputEnvelope = {
    data: SystemBackupCreateManyCreatorInput | SystemBackupCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SystemUpdateCreateWithoutInitiatorInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateUncheckedCreateWithoutInitiatorInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateCreateOrConnectWithoutInitiatorInput = {
    where: SystemUpdateWhereUniqueInput
    create: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput>
  }

  export type SystemUpdateCreateManyInitiatorInputEnvelope = {
    data: SystemUpdateCreateManyInitiatorInput | SystemUpdateCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: RolePermissionUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type ClientUpsertWithWhereUniqueWithoutResponsableInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutResponsableInput, ClientUncheckedUpdateWithoutResponsableInput>
    create: XOR<ClientCreateWithoutResponsableInput, ClientUncheckedCreateWithoutResponsableInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutResponsableInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutResponsableInput, ClientUncheckedUpdateWithoutResponsableInput>
  }

  export type ClientUpdateManyWithWhereWithoutResponsableInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutResponsableInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    razonSocial?: StringFilter<"Client"> | string
    nifCif?: StringFilter<"Client"> | string
    tipo?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    email?: StringNullableFilter<"Client"> | string | null
    telefono?: StringNullableFilter<"Client"> | string | null
    direccion?: StringNullableFilter<"Client"> | string | null
    fechaAlta?: DateTimeFilter<"Client"> | Date | string
    fechaBaja?: DateTimeNullableFilter<"Client"> | Date | string | null
    responsableAsignado?: StringNullableFilter<"Client"> | string | null
    taxModels?: JsonNullableFilter<"Client">
    isActive?: BoolFilter<"Client"> | boolean
  }

  export type ClientEmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: ClientEmployeeWhereUniqueInput
    update: XOR<ClientEmployeeUpdateWithoutUserInput, ClientEmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<ClientEmployeeCreateWithoutUserInput, ClientEmployeeUncheckedCreateWithoutUserInput>
  }

  export type ClientEmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: ClientEmployeeWhereUniqueInput
    data: XOR<ClientEmployeeUpdateWithoutUserInput, ClientEmployeeUncheckedUpdateWithoutUserInput>
  }

  export type ClientEmployeeUpdateManyWithWhereWithoutUserInput = {
    where: ClientEmployeeScalarWhereInput
    data: XOR<ClientEmployeeUpdateManyMutationInput, ClientEmployeeUncheckedUpdateManyWithoutUserInput>
  }

  export type ClientEmployeeScalarWhereInput = {
    AND?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
    OR?: ClientEmployeeScalarWhereInput[]
    NOT?: ClientEmployeeScalarWhereInput | ClientEmployeeScalarWhereInput[]
    clientId?: StringFilter<"ClientEmployee"> | string
    userId?: StringFilter<"ClientEmployee"> | string
    isPrimary?: BoolFilter<"ClientEmployee"> | boolean
    assignedAt?: DateTimeFilter<"ClientEmployee"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAsignadoInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAsignadoInput, TaskUncheckedUpdateWithoutAsignadoInput>
    create: XOR<TaskCreateWithoutAsignadoInput, TaskUncheckedCreateWithoutAsignadoInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAsignadoInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAsignadoInput, TaskUncheckedUpdateWithoutAsignadoInput>
  }

  export type TaskUpdateManyWithWhereWithoutAsignadoInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAsignadoInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    titulo?: StringFilter<"Task"> | string
    descripcion?: StringNullableFilter<"Task"> | string | null
    clienteId?: StringNullableFilter<"Task"> | string | null
    asignadoA?: StringNullableFilter<"Task"> | string | null
    prioridad?: EnumTaskPriorityFilter<"Task"> | $Enums.TaskPriority
    estado?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFilter<"Task"> | $Enums.TaskVisibility
    fechaVencimiento?: DateTimeNullableFilter<"Task"> | Date | string | null
    fechaCreacion?: DateTimeFilter<"Task"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Task"> | Date | string
  }

  export type ManualUpsertWithWhereUniqueWithoutAutorInput = {
    where: ManualWhereUniqueInput
    update: XOR<ManualUpdateWithoutAutorInput, ManualUncheckedUpdateWithoutAutorInput>
    create: XOR<ManualCreateWithoutAutorInput, ManualUncheckedCreateWithoutAutorInput>
  }

  export type ManualUpdateWithWhereUniqueWithoutAutorInput = {
    where: ManualWhereUniqueInput
    data: XOR<ManualUpdateWithoutAutorInput, ManualUncheckedUpdateWithoutAutorInput>
  }

  export type ManualUpdateManyWithWhereWithoutAutorInput = {
    where: ManualScalarWhereInput
    data: XOR<ManualUpdateManyMutationInput, ManualUncheckedUpdateManyWithoutAutorInput>
  }

  export type ManualScalarWhereInput = {
    AND?: ManualScalarWhereInput | ManualScalarWhereInput[]
    OR?: ManualScalarWhereInput[]
    NOT?: ManualScalarWhereInput | ManualScalarWhereInput[]
    id?: StringFilter<"Manual"> | string
    titulo?: StringFilter<"Manual"> | string
    contenidoHtml?: StringFilter<"Manual"> | string
    autorId?: StringFilter<"Manual"> | string
    etiquetas?: StringNullableFilter<"Manual"> | string | null
    categoria?: StringNullableFilter<"Manual"> | string | null
    status?: EnumManualStatusFilter<"Manual"> | $Enums.ManualStatus
    fechaCreacion?: DateTimeFilter<"Manual"> | Date | string
    fechaActualizacion?: DateTimeFilter<"Manual"> | Date | string
    fechaPublicacion?: DateTimeNullableFilter<"Manual"> | Date | string | null
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUsuarioInput, ActivityLogUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ActivityLogCreateWithoutUsuarioInput, ActivityLogUncheckedCreateWithoutUsuarioInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUsuarioInput, ActivityLogUncheckedUpdateWithoutUsuarioInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUsuarioInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    usuarioId?: StringFilter<"ActivityLog"> | string
    accion?: StringFilter<"ActivityLog"> | string
    modulo?: StringFilter<"ActivityLog"> | string
    detalles?: StringNullableFilter<"ActivityLog"> | string | null
    fecha?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type AuditTrailUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AuditTrailWhereUniqueInput
    update: XOR<AuditTrailUpdateWithoutUsuarioInput, AuditTrailUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AuditTrailCreateWithoutUsuarioInput, AuditTrailUncheckedCreateWithoutUsuarioInput>
  }

  export type AuditTrailUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AuditTrailWhereUniqueInput
    data: XOR<AuditTrailUpdateWithoutUsuarioInput, AuditTrailUncheckedUpdateWithoutUsuarioInput>
  }

  export type AuditTrailUpdateManyWithWhereWithoutUsuarioInput = {
    where: AuditTrailScalarWhereInput
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type AuditTrailScalarWhereInput = {
    AND?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    OR?: AuditTrailScalarWhereInput[]
    NOT?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    usuarioId?: StringFilter<"AuditTrail"> | string
    accion?: EnumAuditActionFilter<"AuditTrail"> | $Enums.AuditAction
    tabla?: StringFilter<"AuditTrail"> | string
    registroId?: StringFilter<"AuditTrail"> | string
    valorAnterior?: StringNullableFilter<"AuditTrail"> | string | null
    valorNuevo?: StringNullableFilter<"AuditTrail"> | string | null
    cambios?: StringNullableFilter<"AuditTrail"> | string | null
    requestId?: StringNullableFilter<"AuditTrail"> | string | null
    fecha?: DateTimeFilter<"AuditTrail"> | Date | string
  }

  export type SMTPAccountUpsertWithWhereUniqueWithoutCreadorInput = {
    where: SMTPAccountWhereUniqueInput
    update: XOR<SMTPAccountUpdateWithoutCreadorInput, SMTPAccountUncheckedUpdateWithoutCreadorInput>
    create: XOR<SMTPAccountCreateWithoutCreadorInput, SMTPAccountUncheckedCreateWithoutCreadorInput>
  }

  export type SMTPAccountUpdateWithWhereUniqueWithoutCreadorInput = {
    where: SMTPAccountWhereUniqueInput
    data: XOR<SMTPAccountUpdateWithoutCreadorInput, SMTPAccountUncheckedUpdateWithoutCreadorInput>
  }

  export type SMTPAccountUpdateManyWithWhereWithoutCreadorInput = {
    where: SMTPAccountScalarWhereInput
    data: XOR<SMTPAccountUpdateManyMutationInput, SMTPAccountUncheckedUpdateManyWithoutCreadorInput>
  }

  export type SMTPAccountScalarWhereInput = {
    AND?: SMTPAccountScalarWhereInput | SMTPAccountScalarWhereInput[]
    OR?: SMTPAccountScalarWhereInput[]
    NOT?: SMTPAccountScalarWhereInput | SMTPAccountScalarWhereInput[]
    id?: StringFilter<"SMTPAccount"> | string
    nombre?: StringFilter<"SMTPAccount"> | string
    host?: StringFilter<"SMTPAccount"> | string
    port?: IntFilter<"SMTPAccount"> | number
    user?: StringFilter<"SMTPAccount"> | string
    password?: StringFilter<"SMTPAccount"> | string
    isPredeterminada?: BoolFilter<"SMTPAccount"> | boolean
    activa?: BoolFilter<"SMTPAccount"> | boolean
    creadaPor?: StringNullableFilter<"SMTPAccount"> | string | null
    fechaCreacion?: DateTimeFilter<"SMTPAccount"> | Date | string
  }

  export type NotificationTemplateUpsertWithWhereUniqueWithoutCreadorInput = {
    where: NotificationTemplateWhereUniqueInput
    update: XOR<NotificationTemplateUpdateWithoutCreadorInput, NotificationTemplateUncheckedUpdateWithoutCreadorInput>
    create: XOR<NotificationTemplateCreateWithoutCreadorInput, NotificationTemplateUncheckedCreateWithoutCreadorInput>
  }

  export type NotificationTemplateUpdateWithWhereUniqueWithoutCreadorInput = {
    where: NotificationTemplateWhereUniqueInput
    data: XOR<NotificationTemplateUpdateWithoutCreadorInput, NotificationTemplateUncheckedUpdateWithoutCreadorInput>
  }

  export type NotificationTemplateUpdateManyWithWhereWithoutCreadorInput = {
    where: NotificationTemplateScalarWhereInput
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyWithoutCreadorInput>
  }

  export type NotificationTemplateScalarWhereInput = {
    AND?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
    OR?: NotificationTemplateScalarWhereInput[]
    NOT?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    nombre?: StringFilter<"NotificationTemplate"> | string
    asunto?: StringFilter<"NotificationTemplate"> | string
    contenidoHTML?: StringFilter<"NotificationTemplate"> | string
    variables?: JsonNullableFilter<"NotificationTemplate">
    tipo?: StringFilter<"NotificationTemplate"> | string
    activa?: BoolFilter<"NotificationTemplate"> | boolean
    creadoPor?: StringNullableFilter<"NotificationTemplate"> | string | null
    fechaCreacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
    fechaActualizacion?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutEnviadorInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutEnviadorInput, NotificationLogUncheckedUpdateWithoutEnviadorInput>
    create: XOR<NotificationLogCreateWithoutEnviadorInput, NotificationLogUncheckedCreateWithoutEnviadorInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutEnviadorInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutEnviadorInput, NotificationLogUncheckedUpdateWithoutEnviadorInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutEnviadorInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutEnviadorInput>
  }

  export type NotificationLogScalarWhereInput = {
    AND?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    OR?: NotificationLogScalarWhereInput[]
    NOT?: NotificationLogScalarWhereInput | NotificationLogScalarWhereInput[]
    id?: StringFilter<"NotificationLog"> | string
    plantillaId?: StringNullableFilter<"NotificationLog"> | string | null
    smtpAccountId?: StringNullableFilter<"NotificationLog"> | string | null
    destinatarios?: JsonFilter<"NotificationLog">
    asunto?: StringFilter<"NotificationLog"> | string
    contenido?: StringFilter<"NotificationLog"> | string
    tipo?: StringFilter<"NotificationLog"> | string
    estado?: StringFilter<"NotificationLog"> | string
    fechaEnvio?: DateTimeFilter<"NotificationLog"> | Date | string
    enviadoPor?: StringNullableFilter<"NotificationLog"> | string | null
    metadata?: JsonNullableFilter<"NotificationLog">
  }

  export type ScheduledNotificationUpsertWithWhereUniqueWithoutCreadorInput = {
    where: ScheduledNotificationWhereUniqueInput
    update: XOR<ScheduledNotificationUpdateWithoutCreadorInput, ScheduledNotificationUncheckedUpdateWithoutCreadorInput>
    create: XOR<ScheduledNotificationCreateWithoutCreadorInput, ScheduledNotificationUncheckedCreateWithoutCreadorInput>
  }

  export type ScheduledNotificationUpdateWithWhereUniqueWithoutCreadorInput = {
    where: ScheduledNotificationWhereUniqueInput
    data: XOR<ScheduledNotificationUpdateWithoutCreadorInput, ScheduledNotificationUncheckedUpdateWithoutCreadorInput>
  }

  export type ScheduledNotificationUpdateManyWithWhereWithoutCreadorInput = {
    where: ScheduledNotificationScalarWhereInput
    data: XOR<ScheduledNotificationUpdateManyMutationInput, ScheduledNotificationUncheckedUpdateManyWithoutCreadorInput>
  }

  export type ScheduledNotificationScalarWhereInput = {
    AND?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
    OR?: ScheduledNotificationScalarWhereInput[]
    NOT?: ScheduledNotificationScalarWhereInput | ScheduledNotificationScalarWhereInput[]
    id?: StringFilter<"ScheduledNotification"> | string
    plantillaId?: StringFilter<"ScheduledNotification"> | string
    smtpAccountId?: StringNullableFilter<"ScheduledNotification"> | string | null
    destinatariosSeleccionados?: JsonFilter<"ScheduledNotification">
    fechaProgramada?: DateTimeFilter<"ScheduledNotification"> | Date | string
    estado?: StringFilter<"ScheduledNotification"> | string
    recurrencia?: StringFilter<"ScheduledNotification"> | string
    creadoPor?: StringNullableFilter<"ScheduledNotification"> | string | null
    fechaCreacion?: DateTimeFilter<"ScheduledNotification"> | Date | string
  }

  export type SystemBackupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SystemBackupWhereUniqueInput
    update: XOR<SystemBackupUpdateWithoutCreatorInput, SystemBackupUncheckedUpdateWithoutCreatorInput>
    create: XOR<SystemBackupCreateWithoutCreatorInput, SystemBackupUncheckedCreateWithoutCreatorInput>
  }

  export type SystemBackupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SystemBackupWhereUniqueInput
    data: XOR<SystemBackupUpdateWithoutCreatorInput, SystemBackupUncheckedUpdateWithoutCreatorInput>
  }

  export type SystemBackupUpdateManyWithWhereWithoutCreatorInput = {
    where: SystemBackupScalarWhereInput
    data: XOR<SystemBackupUpdateManyMutationInput, SystemBackupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SystemBackupScalarWhereInput = {
    AND?: SystemBackupScalarWhereInput | SystemBackupScalarWhereInput[]
    OR?: SystemBackupScalarWhereInput[]
    NOT?: SystemBackupScalarWhereInput | SystemBackupScalarWhereInput[]
    id?: StringFilter<"SystemBackup"> | string
    version?: StringFilter<"SystemBackup"> | string
    dbFile?: StringFilter<"SystemBackup"> | string
    filesFile?: StringFilter<"SystemBackup"> | string
    dbSize?: BigIntFilter<"SystemBackup"> | bigint | number
    filesSize?: BigIntFilter<"SystemBackup"> | bigint | number
    status?: EnumBackupStatusFilter<"SystemBackup"> | $Enums.BackupStatus
    errorMessage?: StringNullableFilter<"SystemBackup"> | string | null
    createdBy?: StringNullableFilter<"SystemBackup"> | string | null
    createdAt?: DateTimeFilter<"SystemBackup"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemBackup"> | Date | string | null
  }

  export type SystemUpdateUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: SystemUpdateWhereUniqueInput
    update: XOR<SystemUpdateUpdateWithoutInitiatorInput, SystemUpdateUncheckedUpdateWithoutInitiatorInput>
    create: XOR<SystemUpdateCreateWithoutInitiatorInput, SystemUpdateUncheckedCreateWithoutInitiatorInput>
  }

  export type SystemUpdateUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: SystemUpdateWhereUniqueInput
    data: XOR<SystemUpdateUpdateWithoutInitiatorInput, SystemUpdateUncheckedUpdateWithoutInitiatorInput>
  }

  export type SystemUpdateUpdateManyWithWhereWithoutInitiatorInput = {
    where: SystemUpdateScalarWhereInput
    data: XOR<SystemUpdateUpdateManyMutationInput, SystemUpdateUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type SystemUpdateScalarWhereInput = {
    AND?: SystemUpdateScalarWhereInput | SystemUpdateScalarWhereInput[]
    OR?: SystemUpdateScalarWhereInput[]
    NOT?: SystemUpdateScalarWhereInput | SystemUpdateScalarWhereInput[]
    id?: StringFilter<"SystemUpdate"> | string
    fromVersion?: StringFilter<"SystemUpdate"> | string
    toVersion?: StringFilter<"SystemUpdate"> | string
    status?: EnumUpdateStatusFilter<"SystemUpdate"> | $Enums.UpdateStatus
    logs?: JsonNullableFilter<"SystemUpdate">
    backupId?: StringNullableFilter<"SystemUpdate"> | string | null
    errorMessage?: StringNullableFilter<"SystemUpdate"> | string | null
    initiatedBy?: StringNullableFilter<"SystemUpdate"> | string | null
    createdAt?: DateTimeFilter<"SystemUpdate"> | Date | string
    completedAt?: DateTimeNullableFilter<"SystemUpdate"> | Date | string | null
  }

  export type UserCreateWithoutClientsManagedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutClientsManagedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutClientsManagedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
  }

  export type TaskCreateWithoutClienteInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    asignado?: UserCreateNestedOneWithoutTasksAssignedInput
  }

  export type TaskUncheckedCreateWithoutClienteInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    asignadoA?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type TaskCreateOrConnectWithoutClienteInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput>
  }

  export type TaskCreateManyClienteInputEnvelope = {
    data: TaskCreateManyClienteInput | TaskCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type ClientEmployeeCreateWithoutClientInput = {
    isPrimary?: boolean
    assignedAt?: Date | string
    user: UserCreateNestedOneWithoutClientsAssignedInput
  }

  export type ClientEmployeeUncheckedCreateWithoutClientInput = {
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type ClientEmployeeCreateOrConnectWithoutClientInput = {
    where: ClientEmployeeWhereUniqueInput
    create: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput>
  }

  export type ClientEmployeeCreateManyClientInputEnvelope = {
    data: ClientEmployeeCreateManyClientInput | ClientEmployeeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type clientTaxCreateWithoutClientInput = {
    id?: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    period: taxPeriodCreateNestedOneWithoutClientTaxesInput
    files?: taxFileCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxUncheckedCreateWithoutClientInput = {
    id?: string
    taxPeriodId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    files?: taxFileUncheckedCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxCreateOrConnectWithoutClientInput = {
    where: clientTaxWhereUniqueInput
    create: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput>
  }

  export type clientTaxCreateManyClientInputEnvelope = {
    data: clientTaxCreateManyClientInput | clientTaxCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type clientTaxRequirementCreateWithoutClientInput = {
    id?: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
  }

  export type clientTaxRequirementUncheckedCreateWithoutClientInput = {
    id?: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
  }

  export type clientTaxRequirementCreateOrConnectWithoutClientInput = {
    where: clientTaxRequirementWhereUniqueInput
    create: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput>
  }

  export type clientTaxRequirementCreateManyClientInputEnvelope = {
    data: clientTaxRequirementCreateManyClientInput | clientTaxRequirementCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type clientTaxFilingCreateWithoutClientInput = {
    id?: string
    taxModelCode: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
    period?: fiscalPeriodCreateNestedOneWithoutFilingsInput
  }

  export type clientTaxFilingUncheckedCreateWithoutClientInput = {
    id?: string
    taxModelCode: string
    periodId: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type clientTaxFilingCreateOrConnectWithoutClientInput = {
    where: clientTaxFilingWhereUniqueInput
    create: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput>
  }

  export type clientTaxFilingCreateManyClientInputEnvelope = {
    data: clientTaxFilingCreateManyClientInput | clientTaxFilingCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ObligacionFiscalCreateWithoutClienteInput = {
    id?: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    impuesto: ImpuestoCreateNestedOneWithoutObligacionesInput
    declaraciones?: DeclaracionCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalUncheckedCreateWithoutClienteInput = {
    id?: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    declaraciones?: DeclaracionUncheckedCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalCreateOrConnectWithoutClienteInput = {
    where: ObligacionFiscalWhereUniqueInput
    create: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput>
  }

  export type ObligacionFiscalCreateManyClienteInputEnvelope = {
    data: ObligacionFiscalCreateManyClienteInput | ObligacionFiscalCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type NotificacionCreateWithoutClienteInput = {
    id?: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
  }

  export type NotificacionUncheckedCreateWithoutClienteInput = {
    id?: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
  }

  export type NotificacionCreateOrConnectWithoutClienteInput = {
    where: NotificacionWhereUniqueInput
    create: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput>
  }

  export type NotificacionCreateManyClienteInputEnvelope = {
    data: NotificacionCreateManyClienteInput | NotificacionCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClientsManagedInput = {
    update: XOR<UserUpdateWithoutClientsManagedInput, UserUncheckedUpdateWithoutClientsManagedInput>
    create: XOR<UserCreateWithoutClientsManagedInput, UserUncheckedCreateWithoutClientsManagedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsManagedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsManagedInput, UserUncheckedUpdateWithoutClientsManagedInput>
  }

  export type UserUpdateWithoutClientsManagedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsManagedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutClienteInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutClienteInput, TaskUncheckedUpdateWithoutClienteInput>
    create: XOR<TaskCreateWithoutClienteInput, TaskUncheckedCreateWithoutClienteInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutClienteInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutClienteInput, TaskUncheckedUpdateWithoutClienteInput>
  }

  export type TaskUpdateManyWithWhereWithoutClienteInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutClienteInput>
  }

  export type ClientEmployeeUpsertWithWhereUniqueWithoutClientInput = {
    where: ClientEmployeeWhereUniqueInput
    update: XOR<ClientEmployeeUpdateWithoutClientInput, ClientEmployeeUncheckedUpdateWithoutClientInput>
    create: XOR<ClientEmployeeCreateWithoutClientInput, ClientEmployeeUncheckedCreateWithoutClientInput>
  }

  export type ClientEmployeeUpdateWithWhereUniqueWithoutClientInput = {
    where: ClientEmployeeWhereUniqueInput
    data: XOR<ClientEmployeeUpdateWithoutClientInput, ClientEmployeeUncheckedUpdateWithoutClientInput>
  }

  export type ClientEmployeeUpdateManyWithWhereWithoutClientInput = {
    where: ClientEmployeeScalarWhereInput
    data: XOR<ClientEmployeeUpdateManyMutationInput, ClientEmployeeUncheckedUpdateManyWithoutClientInput>
  }

  export type clientTaxUpsertWithWhereUniqueWithoutClientInput = {
    where: clientTaxWhereUniqueInput
    update: XOR<clientTaxUpdateWithoutClientInput, clientTaxUncheckedUpdateWithoutClientInput>
    create: XOR<clientTaxCreateWithoutClientInput, clientTaxUncheckedCreateWithoutClientInput>
  }

  export type clientTaxUpdateWithWhereUniqueWithoutClientInput = {
    where: clientTaxWhereUniqueInput
    data: XOR<clientTaxUpdateWithoutClientInput, clientTaxUncheckedUpdateWithoutClientInput>
  }

  export type clientTaxUpdateManyWithWhereWithoutClientInput = {
    where: clientTaxScalarWhereInput
    data: XOR<clientTaxUpdateManyMutationInput, clientTaxUncheckedUpdateManyWithoutClientInput>
  }

  export type clientTaxScalarWhereInput = {
    AND?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
    OR?: clientTaxScalarWhereInput[]
    NOT?: clientTaxScalarWhereInput | clientTaxScalarWhereInput[]
    id?: StringFilter<"clientTax"> | string
    clientId?: StringFilter<"clientTax"> | string
    taxPeriodId?: StringFilter<"clientTax"> | string
    estado?: StringFilter<"clientTax"> | string
    notas?: StringNullableFilter<"clientTax"> | string | null
    displayText?: StringNullableFilter<"clientTax"> | string | null
    colorTag?: StringNullableFilter<"clientTax"> | string | null
    fechaCreacion?: DateTimeFilter<"clientTax"> | Date | string
    fechaActualizacion?: DateTimeFilter<"clientTax"> | Date | string
  }

  export type clientTaxRequirementUpsertWithWhereUniqueWithoutClientInput = {
    where: clientTaxRequirementWhereUniqueInput
    update: XOR<clientTaxRequirementUpdateWithoutClientInput, clientTaxRequirementUncheckedUpdateWithoutClientInput>
    create: XOR<clientTaxRequirementCreateWithoutClientInput, clientTaxRequirementUncheckedCreateWithoutClientInput>
  }

  export type clientTaxRequirementUpdateWithWhereUniqueWithoutClientInput = {
    where: clientTaxRequirementWhereUniqueInput
    data: XOR<clientTaxRequirementUpdateWithoutClientInput, clientTaxRequirementUncheckedUpdateWithoutClientInput>
  }

  export type clientTaxRequirementUpdateManyWithWhereWithoutClientInput = {
    where: clientTaxRequirementScalarWhereInput
    data: XOR<clientTaxRequirementUpdateManyMutationInput, clientTaxRequirementUncheckedUpdateManyWithoutClientInput>
  }

  export type clientTaxRequirementScalarWhereInput = {
    AND?: clientTaxRequirementScalarWhereInput | clientTaxRequirementScalarWhereInput[]
    OR?: clientTaxRequirementScalarWhereInput[]
    NOT?: clientTaxRequirementScalarWhereInput | clientTaxRequirementScalarWhereInput[]
    id?: StringFilter<"clientTaxRequirement"> | string
    clientId?: StringFilter<"clientTaxRequirement"> | string
    impuesto?: StringFilter<"clientTaxRequirement"> | string
    detalle?: StringNullableFilter<"clientTaxRequirement"> | string | null
    taxModelCode?: StringNullableFilter<"clientTaxRequirement"> | string | null
    required?: BoolFilter<"clientTaxRequirement"> | boolean
    note?: StringNullableFilter<"clientTaxRequirement"> | string | null
    colorTag?: StringNullableFilter<"clientTaxRequirement"> | string | null
  }

  export type clientTaxFilingUpsertWithWhereUniqueWithoutClientInput = {
    where: clientTaxFilingWhereUniqueInput
    update: XOR<clientTaxFilingUpdateWithoutClientInput, clientTaxFilingUncheckedUpdateWithoutClientInput>
    create: XOR<clientTaxFilingCreateWithoutClientInput, clientTaxFilingUncheckedCreateWithoutClientInput>
  }

  export type clientTaxFilingUpdateWithWhereUniqueWithoutClientInput = {
    where: clientTaxFilingWhereUniqueInput
    data: XOR<clientTaxFilingUpdateWithoutClientInput, clientTaxFilingUncheckedUpdateWithoutClientInput>
  }

  export type clientTaxFilingUpdateManyWithWhereWithoutClientInput = {
    where: clientTaxFilingScalarWhereInput
    data: XOR<clientTaxFilingUpdateManyMutationInput, clientTaxFilingUncheckedUpdateManyWithoutClientInput>
  }

  export type clientTaxFilingScalarWhereInput = {
    AND?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
    OR?: clientTaxFilingScalarWhereInput[]
    NOT?: clientTaxFilingScalarWhereInput | clientTaxFilingScalarWhereInput[]
    id?: StringFilter<"clientTaxFiling"> | string
    clientId?: StringFilter<"clientTaxFiling"> | string
    taxModelCode?: StringFilter<"clientTaxFiling"> | string
    periodId?: StringFilter<"clientTaxFiling"> | string
    status?: StringFilter<"clientTaxFiling"> | string
    notes?: StringNullableFilter<"clientTaxFiling"> | string | null
    presentedAt?: DateTimeNullableFilter<"clientTaxFiling"> | Date | string | null
  }

  export type ObligacionFiscalUpsertWithWhereUniqueWithoutClienteInput = {
    where: ObligacionFiscalWhereUniqueInput
    update: XOR<ObligacionFiscalUpdateWithoutClienteInput, ObligacionFiscalUncheckedUpdateWithoutClienteInput>
    create: XOR<ObligacionFiscalCreateWithoutClienteInput, ObligacionFiscalUncheckedCreateWithoutClienteInput>
  }

  export type ObligacionFiscalUpdateWithWhereUniqueWithoutClienteInput = {
    where: ObligacionFiscalWhereUniqueInput
    data: XOR<ObligacionFiscalUpdateWithoutClienteInput, ObligacionFiscalUncheckedUpdateWithoutClienteInput>
  }

  export type ObligacionFiscalUpdateManyWithWhereWithoutClienteInput = {
    where: ObligacionFiscalScalarWhereInput
    data: XOR<ObligacionFiscalUpdateManyMutationInput, ObligacionFiscalUncheckedUpdateManyWithoutClienteInput>
  }

  export type ObligacionFiscalScalarWhereInput = {
    AND?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
    OR?: ObligacionFiscalScalarWhereInput[]
    NOT?: ObligacionFiscalScalarWhereInput | ObligacionFiscalScalarWhereInput[]
    id?: StringFilter<"ObligacionFiscal"> | string
    clienteId?: StringFilter<"ObligacionFiscal"> | string
    impuestoId?: StringFilter<"ObligacionFiscal"> | string
    periodicidad?: EnumPeriodicidadFilter<"ObligacionFiscal"> | $Enums.Periodicidad
    diaVencimiento?: IntNullableFilter<"ObligacionFiscal"> | number | null
    fechaInicio?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"ObligacionFiscal"> | Date | string | null
    observaciones?: StringNullableFilter<"ObligacionFiscal"> | string | null
    fechaAsignacion?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    activo?: BoolFilter<"ObligacionFiscal"> | boolean
    createdAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
    updatedAt?: DateTimeFilter<"ObligacionFiscal"> | Date | string
  }

  export type NotificacionUpsertWithWhereUniqueWithoutClienteInput = {
    where: NotificacionWhereUniqueInput
    update: XOR<NotificacionUpdateWithoutClienteInput, NotificacionUncheckedUpdateWithoutClienteInput>
    create: XOR<NotificacionCreateWithoutClienteInput, NotificacionUncheckedCreateWithoutClienteInput>
  }

  export type NotificacionUpdateWithWhereUniqueWithoutClienteInput = {
    where: NotificacionWhereUniqueInput
    data: XOR<NotificacionUpdateWithoutClienteInput, NotificacionUncheckedUpdateWithoutClienteInput>
  }

  export type NotificacionUpdateManyWithWhereWithoutClienteInput = {
    where: NotificacionScalarWhereInput
    data: XOR<NotificacionUpdateManyMutationInput, NotificacionUncheckedUpdateManyWithoutClienteInput>
  }

  export type NotificacionScalarWhereInput = {
    AND?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    OR?: NotificacionScalarWhereInput[]
    NOT?: NotificacionScalarWhereInput | NotificacionScalarWhereInput[]
    id?: StringFilter<"Notificacion"> | string
    clienteId?: StringFilter<"Notificacion"> | string
    periodo?: StringFilter<"Notificacion"> | string
    tipo?: EnumTipoNotificacionFilter<"Notificacion"> | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFilter<"Notificacion"> | Date | string
    enviada?: BoolFilter<"Notificacion"> | boolean
    asunto?: StringNullableFilter<"Notificacion"> | string | null
    mensaje?: StringNullableFilter<"Notificacion"> | string | null
    createdAt?: DateTimeFilter<"Notificacion"> | Date | string
  }

  export type ClientCreateWithoutEmployeesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutEmployeesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutEmployeesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutEmployeesInput, ClientUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutClientsAssignedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutClientsAssignedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutClientsAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClientsAssignedInput, UserUncheckedCreateWithoutClientsAssignedInput>
  }

  export type ClientUpsertWithoutEmployeesInput = {
    update: XOR<ClientUpdateWithoutEmployeesInput, ClientUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ClientCreateWithoutEmployeesInput, ClientUncheckedCreateWithoutEmployeesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutEmployeesInput, ClientUncheckedUpdateWithoutEmployeesInput>
  }

  export type ClientUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type UserUpsertWithoutClientsAssignedInput = {
    update: XOR<UserUpdateWithoutClientsAssignedInput, UserUncheckedUpdateWithoutClientsAssignedInput>
    create: XOR<UserCreateWithoutClientsAssignedInput, UserUncheckedCreateWithoutClientsAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClientsAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClientsAssignedInput, UserUncheckedUpdateWithoutClientsAssignedInput>
  }

  export type UserUpdateWithoutClientsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutClientsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type ClientCreateWithoutTasksInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutTasksInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutTasksInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksAssignedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutTasksAssignedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutTasksAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
  }

  export type ClientUpsertWithoutTasksInput = {
    update: XOR<ClientUpdateWithoutTasksInput, ClientUncheckedUpdateWithoutTasksInput>
    create: XOR<ClientCreateWithoutTasksInput, ClientUncheckedCreateWithoutTasksInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTasksInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTasksInput, ClientUncheckedUpdateWithoutTasksInput>
  }

  export type ClientUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type UserUpsertWithoutTasksAssignedInput = {
    update: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
    create: XOR<UserCreateWithoutTasksAssignedInput, UserUncheckedCreateWithoutTasksAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksAssignedInput, UserUncheckedUpdateWithoutTasksAssignedInput>
  }

  export type UserUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateWithoutManualsAuthoredInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutManualsAuthoredInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutManualsAuthoredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManualsAuthoredInput, UserUncheckedCreateWithoutManualsAuthoredInput>
  }

  export type ManualAttachmentCreateWithoutManualInput = {
    id?: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type ManualAttachmentUncheckedCreateWithoutManualInput = {
    id?: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type ManualAttachmentCreateOrConnectWithoutManualInput = {
    where: ManualAttachmentWhereUniqueInput
    create: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput>
  }

  export type ManualAttachmentCreateManyManualInputEnvelope = {
    data: ManualAttachmentCreateManyManualInput | ManualAttachmentCreateManyManualInput[]
    skipDuplicates?: boolean
  }

  export type ManualVersionCreateWithoutManualInput = {
    id?: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ManualVersionUncheckedCreateWithoutManualInput = {
    id?: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ManualVersionCreateOrConnectWithoutManualInput = {
    where: ManualVersionWhereUniqueInput
    create: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput>
  }

  export type ManualVersionCreateManyManualInputEnvelope = {
    data: ManualVersionCreateManyManualInput | ManualVersionCreateManyManualInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutManualsAuthoredInput = {
    update: XOR<UserUpdateWithoutManualsAuthoredInput, UserUncheckedUpdateWithoutManualsAuthoredInput>
    create: XOR<UserCreateWithoutManualsAuthoredInput, UserUncheckedCreateWithoutManualsAuthoredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManualsAuthoredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManualsAuthoredInput, UserUncheckedUpdateWithoutManualsAuthoredInput>
  }

  export type UserUpdateWithoutManualsAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutManualsAuthoredInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type ManualAttachmentUpsertWithWhereUniqueWithoutManualInput = {
    where: ManualAttachmentWhereUniqueInput
    update: XOR<ManualAttachmentUpdateWithoutManualInput, ManualAttachmentUncheckedUpdateWithoutManualInput>
    create: XOR<ManualAttachmentCreateWithoutManualInput, ManualAttachmentUncheckedCreateWithoutManualInput>
  }

  export type ManualAttachmentUpdateWithWhereUniqueWithoutManualInput = {
    where: ManualAttachmentWhereUniqueInput
    data: XOR<ManualAttachmentUpdateWithoutManualInput, ManualAttachmentUncheckedUpdateWithoutManualInput>
  }

  export type ManualAttachmentUpdateManyWithWhereWithoutManualInput = {
    where: ManualAttachmentScalarWhereInput
    data: XOR<ManualAttachmentUpdateManyMutationInput, ManualAttachmentUncheckedUpdateManyWithoutManualInput>
  }

  export type ManualAttachmentScalarWhereInput = {
    AND?: ManualAttachmentScalarWhereInput | ManualAttachmentScalarWhereInput[]
    OR?: ManualAttachmentScalarWhereInput[]
    NOT?: ManualAttachmentScalarWhereInput | ManualAttachmentScalarWhereInput[]
    id?: StringFilter<"ManualAttachment"> | string
    manualId?: StringFilter<"ManualAttachment"> | string
    fileName?: StringFilter<"ManualAttachment"> | string
    originalName?: StringFilter<"ManualAttachment"> | string
    filePath?: StringFilter<"ManualAttachment"> | string
    fileType?: StringFilter<"ManualAttachment"> | string
    fileSize?: IntFilter<"ManualAttachment"> | number
    uploadedBy?: StringFilter<"ManualAttachment"> | string
    uploadedAt?: DateTimeFilter<"ManualAttachment"> | Date | string
  }

  export type ManualVersionUpsertWithWhereUniqueWithoutManualInput = {
    where: ManualVersionWhereUniqueInput
    update: XOR<ManualVersionUpdateWithoutManualInput, ManualVersionUncheckedUpdateWithoutManualInput>
    create: XOR<ManualVersionCreateWithoutManualInput, ManualVersionUncheckedCreateWithoutManualInput>
  }

  export type ManualVersionUpdateWithWhereUniqueWithoutManualInput = {
    where: ManualVersionWhereUniqueInput
    data: XOR<ManualVersionUpdateWithoutManualInput, ManualVersionUncheckedUpdateWithoutManualInput>
  }

  export type ManualVersionUpdateManyWithWhereWithoutManualInput = {
    where: ManualVersionScalarWhereInput
    data: XOR<ManualVersionUpdateManyMutationInput, ManualVersionUncheckedUpdateManyWithoutManualInput>
  }

  export type ManualVersionScalarWhereInput = {
    AND?: ManualVersionScalarWhereInput | ManualVersionScalarWhereInput[]
    OR?: ManualVersionScalarWhereInput[]
    NOT?: ManualVersionScalarWhereInput | ManualVersionScalarWhereInput[]
    id?: StringFilter<"ManualVersion"> | string
    manualId?: StringFilter<"ManualVersion"> | string
    versionNumber?: IntFilter<"ManualVersion"> | number
    titulo?: StringFilter<"ManualVersion"> | string
    contenidoHtml?: StringFilter<"ManualVersion"> | string
    etiquetas?: StringNullableFilter<"ManualVersion"> | string | null
    categoria?: StringNullableFilter<"ManualVersion"> | string | null
    createdBy?: StringFilter<"ManualVersion"> | string
    createdAt?: DateTimeFilter<"ManualVersion"> | Date | string
  }

  export type ManualCreateWithoutAttachmentsInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    autor: UserCreateNestedOneWithoutManualsAuthoredInput
    versions?: ManualVersionCreateNestedManyWithoutManualInput
  }

  export type ManualUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    autorId: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    versions?: ManualVersionUncheckedCreateNestedManyWithoutManualInput
  }

  export type ManualCreateOrConnectWithoutAttachmentsInput = {
    where: ManualWhereUniqueInput
    create: XOR<ManualCreateWithoutAttachmentsInput, ManualUncheckedCreateWithoutAttachmentsInput>
  }

  export type ManualUpsertWithoutAttachmentsInput = {
    update: XOR<ManualUpdateWithoutAttachmentsInput, ManualUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<ManualCreateWithoutAttachmentsInput, ManualUncheckedCreateWithoutAttachmentsInput>
    where?: ManualWhereInput
  }

  export type ManualUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: ManualWhereInput
    data: XOR<ManualUpdateWithoutAttachmentsInput, ManualUncheckedUpdateWithoutAttachmentsInput>
  }

  export type ManualUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: UserUpdateOneRequiredWithoutManualsAuthoredNestedInput
    versions?: ManualVersionUpdateManyWithoutManualNestedInput
  }

  export type ManualUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    versions?: ManualVersionUncheckedUpdateManyWithoutManualNestedInput
  }

  export type ManualCreateWithoutVersionsInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    autor: UserCreateNestedOneWithoutManualsAuthoredInput
    attachments?: ManualAttachmentCreateNestedManyWithoutManualInput
  }

  export type ManualUncheckedCreateWithoutVersionsInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    autorId: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
    attachments?: ManualAttachmentUncheckedCreateNestedManyWithoutManualInput
  }

  export type ManualCreateOrConnectWithoutVersionsInput = {
    where: ManualWhereUniqueInput
    create: XOR<ManualCreateWithoutVersionsInput, ManualUncheckedCreateWithoutVersionsInput>
  }

  export type ManualUpsertWithoutVersionsInput = {
    update: XOR<ManualUpdateWithoutVersionsInput, ManualUncheckedUpdateWithoutVersionsInput>
    create: XOR<ManualCreateWithoutVersionsInput, ManualUncheckedCreateWithoutVersionsInput>
    where?: ManualWhereInput
  }

  export type ManualUpdateToOneWithWhereWithoutVersionsInput = {
    where?: ManualWhereInput
    data: XOR<ManualUpdateWithoutVersionsInput, ManualUncheckedUpdateWithoutVersionsInput>
  }

  export type ManualUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    autor?: UserUpdateOneRequiredWithoutManualsAuthoredNestedInput
    attachments?: ManualAttachmentUpdateManyWithoutManualNestedInput
  }

  export type ManualUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    autorId?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: ManualAttachmentUncheckedUpdateManyWithoutManualNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateWithoutAuditTrailsInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutAuditTrailsInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutAuditTrailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
  }

  export type UserUpsertWithoutAuditTrailsInput = {
    update: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditTrailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type UserUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateWithoutSmtpAccountsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutSmtpAccountsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutSmtpAccountsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSmtpAccountsCreatedInput, UserUncheckedCreateWithoutSmtpAccountsCreatedInput>
  }

  export type NotificationLogCreateWithoutSmtpAccountInput = {
    id?: string
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateCreateNestedOneWithoutLogsInput
    enviador?: UserCreateNestedOneWithoutNotificationsSentInput
  }

  export type NotificationLogUncheckedCreateWithoutSmtpAccountInput = {
    id?: string
    plantillaId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogCreateOrConnectWithoutSmtpAccountInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput>
  }

  export type NotificationLogCreateManySmtpAccountInputEnvelope = {
    data: NotificationLogCreateManySmtpAccountInput | NotificationLogCreateManySmtpAccountInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledNotificationCreateWithoutSmtpAccountInput = {
    id?: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
    plantilla: NotificationTemplateCreateNestedOneWithoutScheduledInput
    creador?: UserCreateNestedOneWithoutScheduledNotificationsCreatedInput
  }

  export type ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput = {
    id?: string
    plantillaId: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type ScheduledNotificationCreateOrConnectWithoutSmtpAccountInput = {
    where: ScheduledNotificationWhereUniqueInput
    create: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput>
  }

  export type ScheduledNotificationCreateManySmtpAccountInputEnvelope = {
    data: ScheduledNotificationCreateManySmtpAccountInput | ScheduledNotificationCreateManySmtpAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSmtpAccountsCreatedInput = {
    update: XOR<UserUpdateWithoutSmtpAccountsCreatedInput, UserUncheckedUpdateWithoutSmtpAccountsCreatedInput>
    create: XOR<UserCreateWithoutSmtpAccountsCreatedInput, UserUncheckedCreateWithoutSmtpAccountsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSmtpAccountsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSmtpAccountsCreatedInput, UserUncheckedUpdateWithoutSmtpAccountsCreatedInput>
  }

  export type UserUpdateWithoutSmtpAccountsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSmtpAccountsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutSmtpAccountInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutSmtpAccountInput, NotificationLogUncheckedUpdateWithoutSmtpAccountInput>
    create: XOR<NotificationLogCreateWithoutSmtpAccountInput, NotificationLogUncheckedCreateWithoutSmtpAccountInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutSmtpAccountInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutSmtpAccountInput, NotificationLogUncheckedUpdateWithoutSmtpAccountInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutSmtpAccountInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutSmtpAccountInput>
  }

  export type ScheduledNotificationUpsertWithWhereUniqueWithoutSmtpAccountInput = {
    where: ScheduledNotificationWhereUniqueInput
    update: XOR<ScheduledNotificationUpdateWithoutSmtpAccountInput, ScheduledNotificationUncheckedUpdateWithoutSmtpAccountInput>
    create: XOR<ScheduledNotificationCreateWithoutSmtpAccountInput, ScheduledNotificationUncheckedCreateWithoutSmtpAccountInput>
  }

  export type ScheduledNotificationUpdateWithWhereUniqueWithoutSmtpAccountInput = {
    where: ScheduledNotificationWhereUniqueInput
    data: XOR<ScheduledNotificationUpdateWithoutSmtpAccountInput, ScheduledNotificationUncheckedUpdateWithoutSmtpAccountInput>
  }

  export type ScheduledNotificationUpdateManyWithWhereWithoutSmtpAccountInput = {
    where: ScheduledNotificationScalarWhereInput
    data: XOR<ScheduledNotificationUpdateManyMutationInput, ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountInput>
  }

  export type UserCreateWithoutNotificationTemplatesCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutNotificationTemplatesCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutNotificationTemplatesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
  }

  export type NotificationLogCreateWithoutPlantillaInput = {
    id?: string
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    smtpAccount?: SMTPAccountCreateNestedOneWithoutLogsInput
    enviador?: UserCreateNestedOneWithoutNotificationsSentInput
  }

  export type NotificationLogUncheckedCreateWithoutPlantillaInput = {
    id?: string
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogCreateOrConnectWithoutPlantillaInput = {
    where: NotificationLogWhereUniqueInput
    create: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput>
  }

  export type NotificationLogCreateManyPlantillaInputEnvelope = {
    data: NotificationLogCreateManyPlantillaInput | NotificationLogCreateManyPlantillaInput[]
    skipDuplicates?: boolean
  }

  export type ScheduledNotificationCreateWithoutPlantillaInput = {
    id?: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
    smtpAccount?: SMTPAccountCreateNestedOneWithoutScheduledInput
    creador?: UserCreateNestedOneWithoutScheduledNotificationsCreatedInput
  }

  export type ScheduledNotificationUncheckedCreateWithoutPlantillaInput = {
    id?: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type ScheduledNotificationCreateOrConnectWithoutPlantillaInput = {
    where: ScheduledNotificationWhereUniqueInput
    create: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput>
  }

  export type ScheduledNotificationCreateManyPlantillaInputEnvelope = {
    data: ScheduledNotificationCreateManyPlantillaInput | ScheduledNotificationCreateManyPlantillaInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotificationTemplatesCreatedInput = {
    update: XOR<UserUpdateWithoutNotificationTemplatesCreatedInput, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
    create: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationTemplatesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationTemplatesCreatedInput, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
  }

  export type UserUpdateWithoutNotificationTemplatesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type NotificationLogUpsertWithWhereUniqueWithoutPlantillaInput = {
    where: NotificationLogWhereUniqueInput
    update: XOR<NotificationLogUpdateWithoutPlantillaInput, NotificationLogUncheckedUpdateWithoutPlantillaInput>
    create: XOR<NotificationLogCreateWithoutPlantillaInput, NotificationLogUncheckedCreateWithoutPlantillaInput>
  }

  export type NotificationLogUpdateWithWhereUniqueWithoutPlantillaInput = {
    where: NotificationLogWhereUniqueInput
    data: XOR<NotificationLogUpdateWithoutPlantillaInput, NotificationLogUncheckedUpdateWithoutPlantillaInput>
  }

  export type NotificationLogUpdateManyWithWhereWithoutPlantillaInput = {
    where: NotificationLogScalarWhereInput
    data: XOR<NotificationLogUpdateManyMutationInput, NotificationLogUncheckedUpdateManyWithoutPlantillaInput>
  }

  export type ScheduledNotificationUpsertWithWhereUniqueWithoutPlantillaInput = {
    where: ScheduledNotificationWhereUniqueInput
    update: XOR<ScheduledNotificationUpdateWithoutPlantillaInput, ScheduledNotificationUncheckedUpdateWithoutPlantillaInput>
    create: XOR<ScheduledNotificationCreateWithoutPlantillaInput, ScheduledNotificationUncheckedCreateWithoutPlantillaInput>
  }

  export type ScheduledNotificationUpdateWithWhereUniqueWithoutPlantillaInput = {
    where: ScheduledNotificationWhereUniqueInput
    data: XOR<ScheduledNotificationUpdateWithoutPlantillaInput, ScheduledNotificationUncheckedUpdateWithoutPlantillaInput>
  }

  export type ScheduledNotificationUpdateManyWithWhereWithoutPlantillaInput = {
    where: ScheduledNotificationScalarWhereInput
    data: XOR<ScheduledNotificationUpdateManyMutationInput, ScheduledNotificationUncheckedUpdateManyWithoutPlantillaInput>
  }

  export type NotificationTemplateCreateWithoutLogsInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    creador?: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateUncheckedCreateWithoutLogsInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    creadoPor?: string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateCreateOrConnectWithoutLogsInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutLogsInput, NotificationTemplateUncheckedCreateWithoutLogsInput>
  }

  export type SMTPAccountCreateWithoutLogsInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
    creador?: UserCreateNestedOneWithoutSmtpAccountsCreatedInput
    scheduled?: ScheduledNotificationCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountUncheckedCreateWithoutLogsInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: string | null
    fechaCreacion?: Date | string
    scheduled?: ScheduledNotificationUncheckedCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountCreateOrConnectWithoutLogsInput = {
    where: SMTPAccountWhereUniqueInput
    create: XOR<SMTPAccountCreateWithoutLogsInput, SMTPAccountUncheckedCreateWithoutLogsInput>
  }

  export type UserCreateWithoutNotificationsSentInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsSentInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
  }

  export type NotificationTemplateUpsertWithoutLogsInput = {
    update: XOR<NotificationTemplateUpdateWithoutLogsInput, NotificationTemplateUncheckedUpdateWithoutLogsInput>
    create: XOR<NotificationTemplateCreateWithoutLogsInput, NotificationTemplateUncheckedCreateWithoutLogsInput>
    where?: NotificationTemplateWhereInput
  }

  export type NotificationTemplateUpdateToOneWithWhereWithoutLogsInput = {
    where?: NotificationTemplateWhereInput
    data: XOR<NotificationTemplateUpdateWithoutLogsInput, NotificationTemplateUncheckedUpdateWithoutLogsInput>
  }

  export type NotificationTemplateUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutNotificationTemplatesCreatedNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutPlantillaNestedInput
  }

  export type SMTPAccountUpsertWithoutLogsInput = {
    update: XOR<SMTPAccountUpdateWithoutLogsInput, SMTPAccountUncheckedUpdateWithoutLogsInput>
    create: XOR<SMTPAccountCreateWithoutLogsInput, SMTPAccountUncheckedCreateWithoutLogsInput>
    where?: SMTPAccountWhereInput
  }

  export type SMTPAccountUpdateToOneWithWhereWithoutLogsInput = {
    where?: SMTPAccountWhereInput
    data: XOR<SMTPAccountUpdateWithoutLogsInput, SMTPAccountUncheckedUpdateWithoutLogsInput>
  }

  export type SMTPAccountUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutSmtpAccountsCreatedNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountNestedInput
  }

  export type UserUpsertWithoutNotificationsSentInput = {
    update: XOR<UserUpdateWithoutNotificationsSentInput, UserUncheckedUpdateWithoutNotificationsSentInput>
    create: XOR<UserCreateWithoutNotificationsSentInput, UserUncheckedCreateWithoutNotificationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsSentInput, UserUncheckedUpdateWithoutNotificationsSentInput>
  }

  export type UserUpdateWithoutNotificationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type NotificationTemplateCreateWithoutScheduledInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    creador?: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    logs?: NotificationLogCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateUncheckedCreateWithoutScheduledInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    creadoPor?: string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutPlantillaInput
  }

  export type NotificationTemplateCreateOrConnectWithoutScheduledInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutScheduledInput, NotificationTemplateUncheckedCreateWithoutScheduledInput>
  }

  export type SMTPAccountCreateWithoutScheduledInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
    creador?: UserCreateNestedOneWithoutSmtpAccountsCreatedInput
    logs?: NotificationLogCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountUncheckedCreateWithoutScheduledInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    creadaPor?: string | null
    fechaCreacion?: Date | string
    logs?: NotificationLogUncheckedCreateNestedManyWithoutSmtpAccountInput
  }

  export type SMTPAccountCreateOrConnectWithoutScheduledInput = {
    where: SMTPAccountWhereUniqueInput
    create: XOR<SMTPAccountCreateWithoutScheduledInput, SMTPAccountUncheckedCreateWithoutScheduledInput>
  }

  export type UserCreateWithoutScheduledNotificationsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutScheduledNotificationsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutScheduledNotificationsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScheduledNotificationsCreatedInput, UserUncheckedCreateWithoutScheduledNotificationsCreatedInput>
  }

  export type NotificationTemplateUpsertWithoutScheduledInput = {
    update: XOR<NotificationTemplateUpdateWithoutScheduledInput, NotificationTemplateUncheckedUpdateWithoutScheduledInput>
    create: XOR<NotificationTemplateCreateWithoutScheduledInput, NotificationTemplateUncheckedCreateWithoutScheduledInput>
    where?: NotificationTemplateWhereInput
  }

  export type NotificationTemplateUpdateToOneWithWhereWithoutScheduledInput = {
    where?: NotificationTemplateWhereInput
    data: XOR<NotificationTemplateUpdateWithoutScheduledInput, NotificationTemplateUncheckedUpdateWithoutScheduledInput>
  }

  export type NotificationTemplateUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutNotificationTemplatesCreatedNestedInput
    logs?: NotificationLogUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutPlantillaNestedInput
  }

  export type SMTPAccountUpsertWithoutScheduledInput = {
    update: XOR<SMTPAccountUpdateWithoutScheduledInput, SMTPAccountUncheckedUpdateWithoutScheduledInput>
    create: XOR<SMTPAccountCreateWithoutScheduledInput, SMTPAccountUncheckedCreateWithoutScheduledInput>
    where?: SMTPAccountWhereInput
  }

  export type SMTPAccountUpdateToOneWithWhereWithoutScheduledInput = {
    where?: SMTPAccountWhereInput
    data: XOR<SMTPAccountUpdateWithoutScheduledInput, SMTPAccountUncheckedUpdateWithoutScheduledInput>
  }

  export type SMTPAccountUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    creador?: UserUpdateOneWithoutSmtpAccountsCreatedNestedInput
    logs?: NotificationLogUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountUncheckedUpdateWithoutScheduledInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    creadaPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutSmtpAccountNestedInput
  }

  export type UserUpsertWithoutScheduledNotificationsCreatedInput = {
    update: XOR<UserUpdateWithoutScheduledNotificationsCreatedInput, UserUncheckedUpdateWithoutScheduledNotificationsCreatedInput>
    create: XOR<UserCreateWithoutScheduledNotificationsCreatedInput, UserUncheckedCreateWithoutScheduledNotificationsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutScheduledNotificationsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutScheduledNotificationsCreatedInput, UserUncheckedUpdateWithoutScheduledNotificationsCreatedInput>
  }

  export type UserUpdateWithoutScheduledNotificationsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutScheduledNotificationsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateWithoutBackupsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    updatesInitiated?: SystemUpdateCreateNestedManyWithoutInitiatorInput
  }

  export type UserUncheckedCreateWithoutBackupsCreatedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    updatesInitiated?: SystemUpdateUncheckedCreateNestedManyWithoutInitiatorInput
  }

  export type UserCreateOrConnectWithoutBackupsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBackupsCreatedInput, UserUncheckedCreateWithoutBackupsCreatedInput>
  }

  export type UserUpsertWithoutBackupsCreatedInput = {
    update: XOR<UserUpdateWithoutBackupsCreatedInput, UserUncheckedUpdateWithoutBackupsCreatedInput>
    create: XOR<UserCreateWithoutBackupsCreatedInput, UserUncheckedCreateWithoutBackupsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBackupsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBackupsCreatedInput, UserUncheckedUpdateWithoutBackupsCreatedInput>
  }

  export type UserUpdateWithoutBackupsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutBackupsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserCreateWithoutUpdatesInitiatedInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
    role?: RoleCreateNestedOneWithoutUsersInput
    clientsManaged?: ClientCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutUpdatesInitiatedInput = {
    id?: string
    username: string
    email: string
    password: string
    roleId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    clientsManaged?: ClientUncheckedCreateNestedManyWithoutResponsableInput
    clientsAssigned?: ClientEmployeeUncheckedCreateNestedManyWithoutUserInput
    tasksAssigned?: TaskUncheckedCreateNestedManyWithoutAsignadoInput
    manualsAuthored?: ManualUncheckedCreateNestedManyWithoutAutorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUsuarioInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUsuarioInput
    smtpAccountsCreated?: SMTPAccountUncheckedCreateNestedManyWithoutCreadorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreadorInput
    notificationsSent?: NotificationLogUncheckedCreateNestedManyWithoutEnviadorInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedCreateNestedManyWithoutCreadorInput
    backupsCreated?: SystemBackupUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutUpdatesInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatesInitiatedInput, UserUncheckedCreateWithoutUpdatesInitiatedInput>
  }

  export type UserUpsertWithoutUpdatesInitiatedInput = {
    update: XOR<UserUpdateWithoutUpdatesInitiatedInput, UserUncheckedUpdateWithoutUpdatesInitiatedInput>
    create: XOR<UserCreateWithoutUpdatesInitiatedInput, UserUncheckedCreateWithoutUpdatesInitiatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatesInitiatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatesInitiatedInput, UserUncheckedUpdateWithoutUpdatesInitiatedInput>
  }

  export type UserUpdateWithoutUpdatesInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneWithoutUsersNestedInput
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatesInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    roleId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type ObligacionFiscalCreateWithoutImpuestoInput = {
    id?: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClientCreateNestedOneWithoutObligacionesFiscalesInput
    declaraciones?: DeclaracionCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalUncheckedCreateWithoutImpuestoInput = {
    id?: string
    clienteId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    declaraciones?: DeclaracionUncheckedCreateNestedManyWithoutObligacionInput
  }

  export type ObligacionFiscalCreateOrConnectWithoutImpuestoInput = {
    where: ObligacionFiscalWhereUniqueInput
    create: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput>
  }

  export type ObligacionFiscalCreateManyImpuestoInputEnvelope = {
    data: ObligacionFiscalCreateManyImpuestoInput | ObligacionFiscalCreateManyImpuestoInput[]
    skipDuplicates?: boolean
  }

  export type ObligacionFiscalUpsertWithWhereUniqueWithoutImpuestoInput = {
    where: ObligacionFiscalWhereUniqueInput
    update: XOR<ObligacionFiscalUpdateWithoutImpuestoInput, ObligacionFiscalUncheckedUpdateWithoutImpuestoInput>
    create: XOR<ObligacionFiscalCreateWithoutImpuestoInput, ObligacionFiscalUncheckedCreateWithoutImpuestoInput>
  }

  export type ObligacionFiscalUpdateWithWhereUniqueWithoutImpuestoInput = {
    where: ObligacionFiscalWhereUniqueInput
    data: XOR<ObligacionFiscalUpdateWithoutImpuestoInput, ObligacionFiscalUncheckedUpdateWithoutImpuestoInput>
  }

  export type ObligacionFiscalUpdateManyWithWhereWithoutImpuestoInput = {
    where: ObligacionFiscalScalarWhereInput
    data: XOR<ObligacionFiscalUpdateManyMutationInput, ObligacionFiscalUncheckedUpdateManyWithoutImpuestoInput>
  }

  export type ClientCreateWithoutObligacionesFiscalesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutObligacionesFiscalesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutObligacionesFiscalesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutObligacionesFiscalesInput, ClientUncheckedCreateWithoutObligacionesFiscalesInput>
  }

  export type ImpuestoCreateWithoutObligacionesInput = {
    id?: string
    nombre: string
    modelo: string
    descripcion?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpuestoUncheckedCreateWithoutObligacionesInput = {
    id?: string
    nombre: string
    modelo: string
    descripcion?: string | null
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImpuestoCreateOrConnectWithoutObligacionesInput = {
    where: ImpuestoWhereUniqueInput
    create: XOR<ImpuestoCreateWithoutObligacionesInput, ImpuestoUncheckedCreateWithoutObligacionesInput>
  }

  export type DeclaracionCreateWithoutObligacionInput = {
    id?: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    calendario: CalendarioAEATCreateNestedOneWithoutDeclaracionesInput
  }

  export type DeclaracionUncheckedCreateWithoutObligacionInput = {
    id?: string
    calendarioId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionCreateOrConnectWithoutObligacionInput = {
    where: DeclaracionWhereUniqueInput
    create: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput>
  }

  export type DeclaracionCreateManyObligacionInputEnvelope = {
    data: DeclaracionCreateManyObligacionInput | DeclaracionCreateManyObligacionInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutObligacionesFiscalesInput = {
    update: XOR<ClientUpdateWithoutObligacionesFiscalesInput, ClientUncheckedUpdateWithoutObligacionesFiscalesInput>
    create: XOR<ClientCreateWithoutObligacionesFiscalesInput, ClientUncheckedCreateWithoutObligacionesFiscalesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutObligacionesFiscalesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutObligacionesFiscalesInput, ClientUncheckedUpdateWithoutObligacionesFiscalesInput>
  }

  export type ClientUpdateWithoutObligacionesFiscalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutObligacionesFiscalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ImpuestoUpsertWithoutObligacionesInput = {
    update: XOR<ImpuestoUpdateWithoutObligacionesInput, ImpuestoUncheckedUpdateWithoutObligacionesInput>
    create: XOR<ImpuestoCreateWithoutObligacionesInput, ImpuestoUncheckedCreateWithoutObligacionesInput>
    where?: ImpuestoWhereInput
  }

  export type ImpuestoUpdateToOneWithWhereWithoutObligacionesInput = {
    where?: ImpuestoWhereInput
    data: XOR<ImpuestoUpdateWithoutObligacionesInput, ImpuestoUncheckedUpdateWithoutObligacionesInput>
  }

  export type ImpuestoUpdateWithoutObligacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImpuestoUncheckedUpdateWithoutObligacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionUpsertWithWhereUniqueWithoutObligacionInput = {
    where: DeclaracionWhereUniqueInput
    update: XOR<DeclaracionUpdateWithoutObligacionInput, DeclaracionUncheckedUpdateWithoutObligacionInput>
    create: XOR<DeclaracionCreateWithoutObligacionInput, DeclaracionUncheckedCreateWithoutObligacionInput>
  }

  export type DeclaracionUpdateWithWhereUniqueWithoutObligacionInput = {
    where: DeclaracionWhereUniqueInput
    data: XOR<DeclaracionUpdateWithoutObligacionInput, DeclaracionUncheckedUpdateWithoutObligacionInput>
  }

  export type DeclaracionUpdateManyWithWhereWithoutObligacionInput = {
    where: DeclaracionScalarWhereInput
    data: XOR<DeclaracionUpdateManyMutationInput, DeclaracionUncheckedUpdateManyWithoutObligacionInput>
  }

  export type DeclaracionScalarWhereInput = {
    AND?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
    OR?: DeclaracionScalarWhereInput[]
    NOT?: DeclaracionScalarWhereInput | DeclaracionScalarWhereInput[]
    id?: StringFilter<"Declaracion"> | string
    obligacionId?: StringFilter<"Declaracion"> | string
    calendarioId?: StringFilter<"Declaracion"> | string
    estado?: EnumEstadoDeclaracionFilter<"Declaracion"> | $Enums.EstadoDeclaracion
    fechaPresentacion?: DateTimeNullableFilter<"Declaracion"> | Date | string | null
    archivoPdf?: StringNullableFilter<"Declaracion"> | string | null
    notas?: StringNullableFilter<"Declaracion"> | string | null
    createdAt?: DateTimeFilter<"Declaracion"> | Date | string
    updatedAt?: DateTimeFilter<"Declaracion"> | Date | string
  }

  export type DeclaracionCreateWithoutCalendarioInput = {
    id?: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    obligacion: ObligacionFiscalCreateNestedOneWithoutDeclaracionesInput
  }

  export type DeclaracionUncheckedCreateWithoutCalendarioInput = {
    id?: string
    obligacionId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionCreateOrConnectWithoutCalendarioInput = {
    where: DeclaracionWhereUniqueInput
    create: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput>
  }

  export type DeclaracionCreateManyCalendarioInputEnvelope = {
    data: DeclaracionCreateManyCalendarioInput | DeclaracionCreateManyCalendarioInput[]
    skipDuplicates?: boolean
  }

  export type DeclaracionUpsertWithWhereUniqueWithoutCalendarioInput = {
    where: DeclaracionWhereUniqueInput
    update: XOR<DeclaracionUpdateWithoutCalendarioInput, DeclaracionUncheckedUpdateWithoutCalendarioInput>
    create: XOR<DeclaracionCreateWithoutCalendarioInput, DeclaracionUncheckedCreateWithoutCalendarioInput>
  }

  export type DeclaracionUpdateWithWhereUniqueWithoutCalendarioInput = {
    where: DeclaracionWhereUniqueInput
    data: XOR<DeclaracionUpdateWithoutCalendarioInput, DeclaracionUncheckedUpdateWithoutCalendarioInput>
  }

  export type DeclaracionUpdateManyWithWhereWithoutCalendarioInput = {
    where: DeclaracionScalarWhereInput
    data: XOR<DeclaracionUpdateManyMutationInput, DeclaracionUncheckedUpdateManyWithoutCalendarioInput>
  }

  export type ObligacionFiscalCreateWithoutDeclaracionesInput = {
    id?: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente: ClientCreateNestedOneWithoutObligacionesFiscalesInput
    impuesto: ImpuestoCreateNestedOneWithoutObligacionesInput
  }

  export type ObligacionFiscalUncheckedCreateWithoutDeclaracionesInput = {
    id?: string
    clienteId: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObligacionFiscalCreateOrConnectWithoutDeclaracionesInput = {
    where: ObligacionFiscalWhereUniqueInput
    create: XOR<ObligacionFiscalCreateWithoutDeclaracionesInput, ObligacionFiscalUncheckedCreateWithoutDeclaracionesInput>
  }

  export type CalendarioAEATCreateWithoutDeclaracionesInput = {
    id?: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date | string
    fechaFin: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarioAEATUncheckedCreateWithoutDeclaracionesInput = {
    id?: string
    modelo: string
    periodicidad: $Enums.Periodicidad
    periodoContable: string
    fechaInicio: Date | string
    fechaFin: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CalendarioAEATCreateOrConnectWithoutDeclaracionesInput = {
    where: CalendarioAEATWhereUniqueInput
    create: XOR<CalendarioAEATCreateWithoutDeclaracionesInput, CalendarioAEATUncheckedCreateWithoutDeclaracionesInput>
  }

  export type ObligacionFiscalUpsertWithoutDeclaracionesInput = {
    update: XOR<ObligacionFiscalUpdateWithoutDeclaracionesInput, ObligacionFiscalUncheckedUpdateWithoutDeclaracionesInput>
    create: XOR<ObligacionFiscalCreateWithoutDeclaracionesInput, ObligacionFiscalUncheckedCreateWithoutDeclaracionesInput>
    where?: ObligacionFiscalWhereInput
  }

  export type ObligacionFiscalUpdateToOneWithWhereWithoutDeclaracionesInput = {
    where?: ObligacionFiscalWhereInput
    data: XOR<ObligacionFiscalUpdateWithoutDeclaracionesInput, ObligacionFiscalUncheckedUpdateWithoutDeclaracionesInput>
  }

  export type ObligacionFiscalUpdateWithoutDeclaracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutObligacionesFiscalesNestedInput
    impuesto?: ImpuestoUpdateOneRequiredWithoutObligacionesNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateWithoutDeclaracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    impuestoId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarioAEATUpsertWithoutDeclaracionesInput = {
    update: XOR<CalendarioAEATUpdateWithoutDeclaracionesInput, CalendarioAEATUncheckedUpdateWithoutDeclaracionesInput>
    create: XOR<CalendarioAEATCreateWithoutDeclaracionesInput, CalendarioAEATUncheckedCreateWithoutDeclaracionesInput>
    where?: CalendarioAEATWhereInput
  }

  export type CalendarioAEATUpdateToOneWithWhereWithoutDeclaracionesInput = {
    where?: CalendarioAEATWhereInput
    data: XOR<CalendarioAEATUpdateWithoutDeclaracionesInput, CalendarioAEATUncheckedUpdateWithoutDeclaracionesInput>
  }

  export type CalendarioAEATUpdateWithoutDeclaracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CalendarioAEATUncheckedUpdateWithoutDeclaracionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    periodoContable?: StringFieldUpdateOperationsInput | string
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutNotificacionesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutNotificacionesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutNotificacionesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutNotificacionesInput, ClientUncheckedCreateWithoutNotificacionesInput>
  }

  export type ClientUpsertWithoutNotificacionesInput = {
    update: XOR<ClientUpdateWithoutNotificacionesInput, ClientUncheckedUpdateWithoutNotificacionesInput>
    create: XOR<ClientCreateWithoutNotificacionesInput, ClientUncheckedCreateWithoutNotificacionesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutNotificacionesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutNotificacionesInput, ClientUncheckedUpdateWithoutNotificacionesInput>
  }

  export type ClientUpdateWithoutNotificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutNotificacionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type taxPeriodCreateWithoutModeloInput = {
    id?: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
    clientTaxes?: clientTaxCreateNestedManyWithoutPeriodInput
  }

  export type taxPeriodUncheckedCreateWithoutModeloInput = {
    id?: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutPeriodInput
  }

  export type taxPeriodCreateOrConnectWithoutModeloInput = {
    where: taxPeriodWhereUniqueInput
    create: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput>
  }

  export type taxPeriodCreateManyModeloInputEnvelope = {
    data: taxPeriodCreateManyModeloInput | taxPeriodCreateManyModeloInput[]
    skipDuplicates?: boolean
  }

  export type taxPeriodUpsertWithWhereUniqueWithoutModeloInput = {
    where: taxPeriodWhereUniqueInput
    update: XOR<taxPeriodUpdateWithoutModeloInput, taxPeriodUncheckedUpdateWithoutModeloInput>
    create: XOR<taxPeriodCreateWithoutModeloInput, taxPeriodUncheckedCreateWithoutModeloInput>
  }

  export type taxPeriodUpdateWithWhereUniqueWithoutModeloInput = {
    where: taxPeriodWhereUniqueInput
    data: XOR<taxPeriodUpdateWithoutModeloInput, taxPeriodUncheckedUpdateWithoutModeloInput>
  }

  export type taxPeriodUpdateManyWithWhereWithoutModeloInput = {
    where: taxPeriodScalarWhereInput
    data: XOR<taxPeriodUpdateManyMutationInput, taxPeriodUncheckedUpdateManyWithoutModeloInput>
  }

  export type taxPeriodScalarWhereInput = {
    AND?: taxPeriodScalarWhereInput | taxPeriodScalarWhereInput[]
    OR?: taxPeriodScalarWhereInput[]
    NOT?: taxPeriodScalarWhereInput | taxPeriodScalarWhereInput[]
    id?: StringFilter<"taxPeriod"> | string
    modeloId?: StringFilter<"taxPeriod"> | string
    anio?: IntFilter<"taxPeriod"> | number
    trimestre?: IntNullableFilter<"taxPeriod"> | number | null
    mes?: IntNullableFilter<"taxPeriod"> | number | null
    inicioPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
    finPresentacion?: DateTimeFilter<"taxPeriod"> | Date | string
  }

  export type taxModelCreateWithoutPeriodsInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type taxModelUncheckedCreateWithoutPeriodsInput = {
    id?: string
    nombre: string
    descripcion?: string | null
  }

  export type taxModelCreateOrConnectWithoutPeriodsInput = {
    where: taxModelWhereUniqueInput
    create: XOR<taxModelCreateWithoutPeriodsInput, taxModelUncheckedCreateWithoutPeriodsInput>
  }

  export type clientTaxCreateWithoutPeriodInput = {
    id?: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    client: ClientCreateNestedOneWithoutClientTaxesInput
    files?: taxFileCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxUncheckedCreateWithoutPeriodInput = {
    id?: string
    clientId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    files?: taxFileUncheckedCreateNestedManyWithoutClientTaxInput
  }

  export type clientTaxCreateOrConnectWithoutPeriodInput = {
    where: clientTaxWhereUniqueInput
    create: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput>
  }

  export type clientTaxCreateManyPeriodInputEnvelope = {
    data: clientTaxCreateManyPeriodInput | clientTaxCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type taxModelUpsertWithoutPeriodsInput = {
    update: XOR<taxModelUpdateWithoutPeriodsInput, taxModelUncheckedUpdateWithoutPeriodsInput>
    create: XOR<taxModelCreateWithoutPeriodsInput, taxModelUncheckedCreateWithoutPeriodsInput>
    where?: taxModelWhereInput
  }

  export type taxModelUpdateToOneWithWhereWithoutPeriodsInput = {
    where?: taxModelWhereInput
    data: XOR<taxModelUpdateWithoutPeriodsInput, taxModelUncheckedUpdateWithoutPeriodsInput>
  }

  export type taxModelUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxModelUncheckedUpdateWithoutPeriodsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxUpsertWithWhereUniqueWithoutPeriodInput = {
    where: clientTaxWhereUniqueInput
    update: XOR<clientTaxUpdateWithoutPeriodInput, clientTaxUncheckedUpdateWithoutPeriodInput>
    create: XOR<clientTaxCreateWithoutPeriodInput, clientTaxUncheckedCreateWithoutPeriodInput>
  }

  export type clientTaxUpdateWithWhereUniqueWithoutPeriodInput = {
    where: clientTaxWhereUniqueInput
    data: XOR<clientTaxUpdateWithoutPeriodInput, clientTaxUncheckedUpdateWithoutPeriodInput>
  }

  export type clientTaxUpdateManyWithWhereWithoutPeriodInput = {
    where: clientTaxScalarWhereInput
    data: XOR<clientTaxUpdateManyMutationInput, clientTaxUncheckedUpdateManyWithoutPeriodInput>
  }

  export type ClientCreateWithoutClientTaxesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutClientTaxesInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutClientTaxesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientTaxesInput, ClientUncheckedCreateWithoutClientTaxesInput>
  }

  export type taxPeriodCreateWithoutClientTaxesInput = {
    id?: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
    modelo: taxModelCreateNestedOneWithoutPeriodsInput
  }

  export type taxPeriodUncheckedCreateWithoutClientTaxesInput = {
    id?: string
    modeloId: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
  }

  export type taxPeriodCreateOrConnectWithoutClientTaxesInput = {
    where: taxPeriodWhereUniqueInput
    create: XOR<taxPeriodCreateWithoutClientTaxesInput, taxPeriodUncheckedCreateWithoutClientTaxesInput>
  }

  export type taxFileCreateWithoutClientTaxInput = {
    id?: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
  }

  export type taxFileUncheckedCreateWithoutClientTaxInput = {
    id?: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
  }

  export type taxFileCreateOrConnectWithoutClientTaxInput = {
    where: taxFileWhereUniqueInput
    create: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput>
  }

  export type taxFileCreateManyClientTaxInputEnvelope = {
    data: taxFileCreateManyClientTaxInput | taxFileCreateManyClientTaxInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutClientTaxesInput = {
    update: XOR<ClientUpdateWithoutClientTaxesInput, ClientUncheckedUpdateWithoutClientTaxesInput>
    create: XOR<ClientCreateWithoutClientTaxesInput, ClientUncheckedCreateWithoutClientTaxesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientTaxesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientTaxesInput, ClientUncheckedUpdateWithoutClientTaxesInput>
  }

  export type ClientUpdateWithoutClientTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type taxPeriodUpsertWithoutClientTaxesInput = {
    update: XOR<taxPeriodUpdateWithoutClientTaxesInput, taxPeriodUncheckedUpdateWithoutClientTaxesInput>
    create: XOR<taxPeriodCreateWithoutClientTaxesInput, taxPeriodUncheckedCreateWithoutClientTaxesInput>
    where?: taxPeriodWhereInput
  }

  export type taxPeriodUpdateToOneWithWhereWithoutClientTaxesInput = {
    where?: taxPeriodWhereInput
    data: XOR<taxPeriodUpdateWithoutClientTaxesInput, taxPeriodUncheckedUpdateWithoutClientTaxesInput>
  }

  export type taxPeriodUpdateWithoutClientTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    modelo?: taxModelUpdateOneRequiredWithoutPeriodsNestedInput
  }

  export type taxPeriodUncheckedUpdateWithoutClientTaxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    modeloId?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxFileUpsertWithWhereUniqueWithoutClientTaxInput = {
    where: taxFileWhereUniqueInput
    update: XOR<taxFileUpdateWithoutClientTaxInput, taxFileUncheckedUpdateWithoutClientTaxInput>
    create: XOR<taxFileCreateWithoutClientTaxInput, taxFileUncheckedCreateWithoutClientTaxInput>
  }

  export type taxFileUpdateWithWhereUniqueWithoutClientTaxInput = {
    where: taxFileWhereUniqueInput
    data: XOR<taxFileUpdateWithoutClientTaxInput, taxFileUncheckedUpdateWithoutClientTaxInput>
  }

  export type taxFileUpdateManyWithWhereWithoutClientTaxInput = {
    where: taxFileScalarWhereInput
    data: XOR<taxFileUpdateManyMutationInput, taxFileUncheckedUpdateManyWithoutClientTaxInput>
  }

  export type taxFileScalarWhereInput = {
    AND?: taxFileScalarWhereInput | taxFileScalarWhereInput[]
    OR?: taxFileScalarWhereInput[]
    NOT?: taxFileScalarWhereInput | taxFileScalarWhereInput[]
    id?: StringFilter<"taxFile"> | string
    clientTaxId?: StringFilter<"taxFile"> | string
    nombreArchivo?: StringFilter<"taxFile"> | string
    s3Url?: StringFilter<"taxFile"> | string
    s3Key?: StringFilter<"taxFile"> | string
    tipo?: StringNullableFilter<"taxFile"> | string | null
    tamanio?: IntNullableFilter<"taxFile"> | number | null
    fechaSubida?: DateTimeFilter<"taxFile"> | Date | string
    subidoPor?: StringNullableFilter<"taxFile"> | string | null
  }

  export type clientTaxCreateWithoutFilesInput = {
    id?: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
    client: ClientCreateNestedOneWithoutClientTaxesInput
    period: taxPeriodCreateNestedOneWithoutClientTaxesInput
  }

  export type clientTaxUncheckedCreateWithoutFilesInput = {
    id?: string
    clientId: string
    taxPeriodId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
  }

  export type clientTaxCreateOrConnectWithoutFilesInput = {
    where: clientTaxWhereUniqueInput
    create: XOR<clientTaxCreateWithoutFilesInput, clientTaxUncheckedCreateWithoutFilesInput>
  }

  export type clientTaxUpsertWithoutFilesInput = {
    update: XOR<clientTaxUpdateWithoutFilesInput, clientTaxUncheckedUpdateWithoutFilesInput>
    create: XOR<clientTaxCreateWithoutFilesInput, clientTaxUncheckedCreateWithoutFilesInput>
    where?: clientTaxWhereInput
  }

  export type clientTaxUpdateToOneWithWhereWithoutFilesInput = {
    where?: clientTaxWhereInput
    data: XOR<clientTaxUpdateWithoutFilesInput, clientTaxUncheckedUpdateWithoutFilesInput>
  }

  export type clientTaxUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientTaxesNestedInput
    period?: taxPeriodUpdateOneRequiredWithoutClientTaxesNestedInput
  }

  export type clientTaxUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxPeriodId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutClientTaxRequirementsInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutClientTaxRequirementsInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    taxFilings?: clientTaxFilingUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutClientTaxRequirementsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutClientTaxRequirementsInput, ClientUncheckedCreateWithoutClientTaxRequirementsInput>
  }

  export type ClientUpsertWithoutClientTaxRequirementsInput = {
    update: XOR<ClientUpdateWithoutClientTaxRequirementsInput, ClientUncheckedUpdateWithoutClientTaxRequirementsInput>
    create: XOR<ClientCreateWithoutClientTaxRequirementsInput, ClientUncheckedCreateWithoutClientTaxRequirementsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutClientTaxRequirementsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutClientTaxRequirementsInput, ClientUncheckedUpdateWithoutClientTaxRequirementsInput>
  }

  export type ClientUpdateWithoutClientTaxRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutClientTaxRequirementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clientTaxFilingCreateWithoutPeriodInput = {
    id?: string
    taxModelCode: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
    client?: ClientCreateNestedOneWithoutTaxFilingsInput
  }

  export type clientTaxFilingUncheckedCreateWithoutPeriodInput = {
    id?: string
    clientId: string
    taxModelCode: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type clientTaxFilingCreateOrConnectWithoutPeriodInput = {
    where: clientTaxFilingWhereUniqueInput
    create: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput>
  }

  export type clientTaxFilingCreateManyPeriodInputEnvelope = {
    data: clientTaxFilingCreateManyPeriodInput | clientTaxFilingCreateManyPeriodInput[]
    skipDuplicates?: boolean
  }

  export type clientTaxFilingUpsertWithWhereUniqueWithoutPeriodInput = {
    where: clientTaxFilingWhereUniqueInput
    update: XOR<clientTaxFilingUpdateWithoutPeriodInput, clientTaxFilingUncheckedUpdateWithoutPeriodInput>
    create: XOR<clientTaxFilingCreateWithoutPeriodInput, clientTaxFilingUncheckedCreateWithoutPeriodInput>
  }

  export type clientTaxFilingUpdateWithWhereUniqueWithoutPeriodInput = {
    where: clientTaxFilingWhereUniqueInput
    data: XOR<clientTaxFilingUpdateWithoutPeriodInput, clientTaxFilingUncheckedUpdateWithoutPeriodInput>
  }

  export type clientTaxFilingUpdateManyWithWhereWithoutPeriodInput = {
    where: clientTaxFilingScalarWhereInput
    data: XOR<clientTaxFilingUpdateManyMutationInput, clientTaxFilingUncheckedUpdateManyWithoutPeriodInput>
  }

  export type ClientCreateWithoutTaxFilingsInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    responsable?: UserCreateNestedOneWithoutClientsManagedInput
    tasks?: TaskCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionCreateNestedManyWithoutClienteInput
  }

  export type ClientUncheckedCreateWithoutTaxFilingsInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    responsableAsignado?: string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    tasks?: TaskUncheckedCreateNestedManyWithoutClienteInput
    employees?: ClientEmployeeUncheckedCreateNestedManyWithoutClientInput
    clientTaxes?: clientTaxUncheckedCreateNestedManyWithoutClientInput
    clientTaxRequirements?: clientTaxRequirementUncheckedCreateNestedManyWithoutClientInput
    obligacionesFiscales?: ObligacionFiscalUncheckedCreateNestedManyWithoutClienteInput
    notificaciones?: NotificacionUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClientCreateOrConnectWithoutTaxFilingsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutTaxFilingsInput, ClientUncheckedCreateWithoutTaxFilingsInput>
  }

  export type fiscalPeriodCreateWithoutFilingsInput = {
    id?: string
    year: number
    quarter: number
    label: string
    startsAt: Date | string
    endsAt: Date | string
  }

  export type fiscalPeriodUncheckedCreateWithoutFilingsInput = {
    id?: string
    year: number
    quarter: number
    label: string
    startsAt: Date | string
    endsAt: Date | string
  }

  export type fiscalPeriodCreateOrConnectWithoutFilingsInput = {
    where: fiscalPeriodWhereUniqueInput
    create: XOR<fiscalPeriodCreateWithoutFilingsInput, fiscalPeriodUncheckedCreateWithoutFilingsInput>
  }

  export type ClientUpsertWithoutTaxFilingsInput = {
    update: XOR<ClientUpdateWithoutTaxFilingsInput, ClientUncheckedUpdateWithoutTaxFilingsInput>
    create: XOR<ClientCreateWithoutTaxFilingsInput, ClientUncheckedCreateWithoutTaxFilingsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutTaxFilingsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutTaxFilingsInput, ClientUncheckedUpdateWithoutTaxFilingsInput>
  }

  export type ClientUpdateWithoutTaxFilingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    responsable?: UserUpdateOneWithoutClientsManagedNestedInput
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutTaxFilingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responsableAsignado?: NullableStringFieldUpdateOperationsInput | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type fiscalPeriodUpsertWithoutFilingsInput = {
    update: XOR<fiscalPeriodUpdateWithoutFilingsInput, fiscalPeriodUncheckedUpdateWithoutFilingsInput>
    create: XOR<fiscalPeriodCreateWithoutFilingsInput, fiscalPeriodUncheckedCreateWithoutFilingsInput>
    where?: fiscalPeriodWhereInput
  }

  export type fiscalPeriodUpdateToOneWithWhereWithoutFilingsInput = {
    where?: fiscalPeriodWhereInput
    data: XOR<fiscalPeriodUpdateWithoutFilingsInput, fiscalPeriodUncheckedUpdateWithoutFilingsInput>
  }

  export type fiscalPeriodUpdateWithoutFilingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fiscalPeriodUncheckedUpdateWithoutFilingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    quarter?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyRoleInput = {
    id?: string
    username: string
    email: string
    password: string
    isActive?: boolean
    createdAt?: Date | string
  }

  export type RolePermissionCreateManyRoleInput = {
    id?: string
    permissionId: string
    createdAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientsManaged?: ClientUncheckedUpdateManyWithoutResponsableNestedInput
    clientsAssigned?: ClientEmployeeUncheckedUpdateManyWithoutUserNestedInput
    tasksAssigned?: TaskUncheckedUpdateManyWithoutAsignadoNestedInput
    manualsAuthored?: ManualUncheckedUpdateManyWithoutAutorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUsuarioNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUsuarioNestedInput
    smtpAccountsCreated?: SMTPAccountUncheckedUpdateManyWithoutCreadorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreadorNestedInput
    notificationsSent?: NotificationLogUncheckedUpdateManyWithoutEnviadorNestedInput
    scheduledNotificationsCreated?: ScheduledNotificationUncheckedUpdateManyWithoutCreadorNestedInput
    backupsCreated?: SystemBackupUncheckedUpdateManyWithoutCreatorNestedInput
    updatesInitiated?: SystemUpdateUncheckedUpdateManyWithoutInitiatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permission?: PermissionUpdateOneRequiredWithoutRolesNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissionId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionCreateManyPermissionInput = {
    id?: string
    roleId: string
    createdAt?: Date | string
  }

  export type RolePermissionUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type RolePermissionUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RolePermissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateManyResponsableInput = {
    id?: string
    razonSocial: string
    nifCif: string
    tipo: $Enums.ClientType
    email?: string | null
    telefono?: string | null
    direccion?: string | null
    fechaAlta?: Date | string
    fechaBaja?: Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
  }

  export type ClientEmployeeCreateManyUserInput = {
    clientId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type TaskCreateManyAsignadoInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    clienteId?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type ManualCreateManyAutorInput = {
    id?: string
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    status?: $Enums.ManualStatus
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
    fechaPublicacion?: Date | string | null
  }

  export type ActivityLogCreateManyUsuarioInput = {
    id?: string
    accion: string
    modulo: string
    detalles?: string | null
    fecha?: Date | string
  }

  export type AuditTrailCreateManyUsuarioInput = {
    id?: string
    accion: $Enums.AuditAction
    tabla: string
    registroId: string
    valorAnterior?: string | null
    valorNuevo?: string | null
    cambios?: string | null
    requestId?: string | null
    fecha?: Date | string
  }

  export type SMTPAccountCreateManyCreadorInput = {
    id?: string
    nombre: string
    host: string
    port: number
    user: string
    password: string
    isPredeterminada?: boolean
    activa?: boolean
    fechaCreacion?: Date | string
  }

  export type NotificationTemplateCreateManyCreadorInput = {
    id?: string
    nombre: string
    asunto: string
    contenidoHTML: string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo: string
    activa?: boolean
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type NotificationLogCreateManyEnviadorInput = {
    id?: string
    plantillaId?: string | null
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationCreateManyCreadorInput = {
    id?: string
    plantillaId: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    fechaCreacion?: Date | string
  }

  export type SystemBackupCreateManyCreatorInput = {
    id?: string
    version: string
    dbFile: string
    filesFile: string
    dbSize?: bigint | number
    filesSize?: bigint | number
    status?: $Enums.BackupStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SystemUpdateCreateManyInitiatorInput = {
    id?: string
    fromVersion: string
    toVersion: string
    status?: $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ClientUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tasks?: TaskUncheckedUpdateManyWithoutClienteNestedInput
    employees?: ClientEmployeeUncheckedUpdateManyWithoutClientNestedInput
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutClientNestedInput
    clientTaxRequirements?: clientTaxRequirementUncheckedUpdateManyWithoutClientNestedInput
    taxFilings?: clientTaxFilingUncheckedUpdateManyWithoutClientNestedInput
    obligacionesFiscales?: ObligacionFiscalUncheckedUpdateManyWithoutClienteNestedInput
    notificaciones?: NotificacionUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    razonSocial?: StringFieldUpdateOperationsInput | string
    nifCif?: StringFieldUpdateOperationsInput | string
    tipo?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAlta?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaBaja?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    taxModels?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClientEmployeeUpdateWithoutUserInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type ClientEmployeeUncheckedUpdateWithoutUserInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmployeeUncheckedUpdateManyWithoutUserInput = {
    clientId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutAsignadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAsignadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAsignadoInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    clienteId?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualUpdateWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: ManualAttachmentUpdateManyWithoutManualNestedInput
    versions?: ManualVersionUpdateManyWithoutManualNestedInput
  }

  export type ManualUncheckedUpdateWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attachments?: ManualAttachmentUncheckedUpdateManyWithoutManualNestedInput
    versions?: ManualVersionUncheckedUpdateManyWithoutManualNestedInput
  }

  export type ManualUncheckedUpdateManyWithoutAutorInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumManualStatusFieldUpdateOperationsInput | $Enums.ManualStatus
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaPublicacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ActivityLogUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    modulo?: StringFieldUpdateOperationsInput | string
    detalles?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    accion?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    tabla?: StringFieldUpdateOperationsInput | string
    registroId?: StringFieldUpdateOperationsInput | string
    valorAnterior?: NullableStringFieldUpdateOperationsInput | string | null
    valorNuevo?: NullableStringFieldUpdateOperationsInput | string | null
    cambios?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SMTPAccountUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUpdateManyWithoutSmtpAccountNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountUncheckedUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutSmtpAccountNestedInput
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountNestedInput
  }

  export type SMTPAccountUncheckedUpdateManyWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    host?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    user?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isPredeterminada?: BoolFieldUpdateOperationsInput | boolean
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUpdateManyWithoutPlantillaNestedInput
    scheduled?: ScheduledNotificationUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: NotificationLogUncheckedUpdateManyWithoutPlantillaNestedInput
    scheduled?: ScheduledNotificationUncheckedUpdateManyWithoutPlantillaNestedInput
  }

  export type NotificationTemplateUncheckedUpdateManyWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    asunto?: StringFieldUpdateOperationsInput | string
    contenidoHTML?: StringFieldUpdateOperationsInput | string
    variables?: NullableJsonNullValueInput | InputJsonValue
    tipo?: StringFieldUpdateOperationsInput | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogUpdateWithoutEnviadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateUpdateOneWithoutLogsNestedInput
    smtpAccount?: SMTPAccountUpdateOneWithoutLogsNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutEnviadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUncheckedUpdateManyWithoutEnviadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    plantilla?: NotificationTemplateUpdateOneRequiredWithoutScheduledNestedInput
    smtpAccount?: SMTPAccountUpdateOneWithoutScheduledNestedInput
  }

  export type ScheduledNotificationUncheckedUpdateWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutCreadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemBackupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemBackupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemBackupUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    dbFile?: StringFieldUpdateOperationsInput | string
    filesFile?: StringFieldUpdateOperationsInput | string
    dbSize?: BigIntFieldUpdateOperationsInput | bigint | number
    filesSize?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: EnumBackupStatusFieldUpdateOperationsInput | $Enums.BackupStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemUpdateUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromVersion?: StringFieldUpdateOperationsInput | string
    toVersion?: StringFieldUpdateOperationsInput | string
    status?: EnumUpdateStatusFieldUpdateOperationsInput | $Enums.UpdateStatus
    logs?: NullableJsonNullValueInput | InputJsonValue
    backupId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskCreateManyClienteInput = {
    id?: string
    titulo: string
    descripcion?: string | null
    asignadoA?: string | null
    prioridad?: $Enums.TaskPriority
    estado?: $Enums.TaskStatus
    visibilidad?: $Enums.TaskVisibility
    fechaVencimiento?: Date | string | null
    fechaCreacion?: Date | string
    fechaActualizacion?: Date | string
  }

  export type ClientEmployeeCreateManyClientInput = {
    userId: string
    isPrimary?: boolean
    assignedAt?: Date | string
  }

  export type clientTaxCreateManyClientInput = {
    id?: string
    taxPeriodId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
  }

  export type clientTaxRequirementCreateManyClientInput = {
    id?: string
    impuesto: string
    detalle?: string | null
    taxModelCode?: string | null
    required?: boolean
    note?: string | null
    colorTag?: string | null
  }

  export type clientTaxFilingCreateManyClientInput = {
    id?: string
    taxModelCode: string
    periodId: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type ObligacionFiscalCreateManyClienteInput = {
    id?: string
    impuestoId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificacionCreateManyClienteInput = {
    id?: string
    periodo: string
    tipo: $Enums.TipoNotificacion
    fechaEnvio: Date | string
    enviada?: boolean
    asunto?: string | null
    mensaje?: string | null
    createdAt?: Date | string
  }

  export type TaskUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    asignado?: UserUpdateOneWithoutTasksAssignedNestedInput
  }

  export type TaskUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asignadoA?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    asignadoA?: NullableStringFieldUpdateOperationsInput | string | null
    prioridad?: EnumTaskPriorityFieldUpdateOperationsInput | $Enums.TaskPriority
    estado?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    visibilidad?: EnumTaskVisibilityFieldUpdateOperationsInput | $Enums.TaskVisibility
    fechaVencimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmployeeUpdateWithoutClientInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClientsAssignedNestedInput
  }

  export type ClientEmployeeUncheckedUpdateWithoutClientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEmployeeUncheckedUpdateManyWithoutClientInput = {
    userId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: taxPeriodUpdateOneRequiredWithoutClientTaxesNestedInput
    files?: taxFileUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxPeriodId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: taxFileUncheckedUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxPeriodId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxRequirementUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxRequirementUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxRequirementUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuesto?: StringFieldUpdateOperationsInput | string
    detalle?: NullableStringFieldUpdateOperationsInput | string | null
    taxModelCode?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    note?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxFilingUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period?: fiscalPeriodUpdateOneWithoutFilingsNestedInput
  }

  export type clientTaxFilingUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientTaxFilingUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    periodId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ObligacionFiscalUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    impuesto?: ImpuestoUpdateOneRequiredWithoutObligacionesNestedInput
    declaraciones?: DeclaracionUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuestoId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    declaraciones?: DeclaracionUncheckedUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    impuestoId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificacionUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodo?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoNotificacionFieldUpdateOperationsInput | $Enums.TipoNotificacion
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviada?: BoolFieldUpdateOperationsInput | boolean
    asunto?: NullableStringFieldUpdateOperationsInput | string | null
    mensaje?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualAttachmentCreateManyManualInput = {
    id?: string
    fileName: string
    originalName: string
    filePath: string
    fileType: string
    fileSize: number
    uploadedBy: string
    uploadedAt?: Date | string
  }

  export type ManualVersionCreateManyManualInput = {
    id?: string
    versionNumber: number
    titulo: string
    contenidoHtml: string
    etiquetas?: string | null
    categoria?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type ManualAttachmentUpdateWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualAttachmentUncheckedUpdateWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualAttachmentUncheckedUpdateManyWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionUpdateWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionUncheckedUpdateWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManualVersionUncheckedUpdateManyWithoutManualInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    contenidoHtml?: StringFieldUpdateOperationsInput | string
    etiquetas?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManySmtpAccountInput = {
    id?: string
    plantillaId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationCreateManySmtpAccountInput = {
    id?: string
    plantillaId: string
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type NotificationLogUpdateWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    plantilla?: NotificationTemplateUpdateOneWithoutLogsNestedInput
    enviador?: UserUpdateOneWithoutNotificationsSentNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUncheckedUpdateManyWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationUpdateWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    plantilla?: NotificationTemplateUpdateOneRequiredWithoutScheduledNestedInput
    creador?: UserUpdateOneWithoutScheduledNotificationsCreatedNestedInput
  }

  export type ScheduledNotificationUncheckedUpdateWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutSmtpAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    plantillaId?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationLogCreateManyPlantillaInput = {
    id?: string
    smtpAccountId?: string | null
    destinatarios: JsonNullValueInput | InputJsonValue
    asunto: string
    contenido: string
    tipo: string
    estado: string
    fechaEnvio: Date | string
    enviadoPor?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationCreateManyPlantillaInput = {
    id?: string
    smtpAccountId?: string | null
    destinatariosSeleccionados: JsonNullValueInput | InputJsonValue
    fechaProgramada: Date | string
    estado?: string
    recurrencia?: string
    creadoPor?: string | null
    fechaCreacion?: Date | string
  }

  export type NotificationLogUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    smtpAccount?: SMTPAccountUpdateOneWithoutLogsNestedInput
    enviador?: UserUpdateOneWithoutNotificationsSentNestedInput
  }

  export type NotificationLogUncheckedUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NotificationLogUncheckedUpdateManyWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatarios?: JsonNullValueInput | InputJsonValue
    asunto?: StringFieldUpdateOperationsInput | string
    contenido?: StringFieldUpdateOperationsInput | string
    tipo?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    fechaEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ScheduledNotificationUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    smtpAccount?: SMTPAccountUpdateOneWithoutScheduledNestedInput
    creador?: UserUpdateOneWithoutScheduledNotificationsCreatedNestedInput
  }

  export type ScheduledNotificationUncheckedUpdateWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledNotificationUncheckedUpdateManyWithoutPlantillaInput = {
    id?: StringFieldUpdateOperationsInput | string
    smtpAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    destinatariosSeleccionados?: JsonNullValueInput | InputJsonValue
    fechaProgramada?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    recurrencia?: StringFieldUpdateOperationsInput | string
    creadoPor?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObligacionFiscalCreateManyImpuestoInput = {
    id?: string
    clienteId: string
    periodicidad: $Enums.Periodicidad
    diaVencimiento?: number | null
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    observaciones?: string | null
    fechaAsignacion?: Date | string
    activo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ObligacionFiscalUpdateWithoutImpuestoInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClientUpdateOneRequiredWithoutObligacionesFiscalesNestedInput
    declaraciones?: DeclaracionUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateWithoutImpuestoInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    declaraciones?: DeclaracionUncheckedUpdateManyWithoutObligacionNestedInput
  }

  export type ObligacionFiscalUncheckedUpdateManyWithoutImpuestoInput = {
    id?: StringFieldUpdateOperationsInput | string
    clienteId?: StringFieldUpdateOperationsInput | string
    periodicidad?: EnumPeriodicidadFieldUpdateOperationsInput | $Enums.Periodicidad
    diaVencimiento?: NullableIntFieldUpdateOperationsInput | number | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    fechaAsignacion?: DateTimeFieldUpdateOperationsInput | Date | string
    activo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionCreateManyObligacionInput = {
    id?: string
    calendarioId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionUpdateWithoutObligacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    calendario?: CalendarioAEATUpdateOneRequiredWithoutDeclaracionesNestedInput
  }

  export type DeclaracionUncheckedUpdateWithoutObligacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionUncheckedUpdateManyWithoutObligacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    calendarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionCreateManyCalendarioInput = {
    id?: string
    obligacionId: string
    estado?: $Enums.EstadoDeclaracion
    fechaPresentacion?: Date | string | null
    archivoPdf?: string | null
    notas?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeclaracionUpdateWithoutCalendarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obligacion?: ObligacionFiscalUpdateOneRequiredWithoutDeclaracionesNestedInput
  }

  export type DeclaracionUncheckedUpdateWithoutCalendarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    obligacionId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeclaracionUncheckedUpdateManyWithoutCalendarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    obligacionId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDeclaracionFieldUpdateOperationsInput | $Enums.EstadoDeclaracion
    fechaPresentacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archivoPdf?: NullableStringFieldUpdateOperationsInput | string | null
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxPeriodCreateManyModeloInput = {
    id?: string
    anio: number
    trimestre?: number | null
    mes?: number | null
    inicioPresentacion: Date | string
    finPresentacion: Date | string
  }

  export type taxPeriodUpdateWithoutModeloInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    clientTaxes?: clientTaxUpdateManyWithoutPeriodNestedInput
  }

  export type taxPeriodUncheckedUpdateWithoutModeloInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    clientTaxes?: clientTaxUncheckedUpdateManyWithoutPeriodNestedInput
  }

  export type taxPeriodUncheckedUpdateManyWithoutModeloInput = {
    id?: StringFieldUpdateOperationsInput | string
    anio?: IntFieldUpdateOperationsInput | number
    trimestre?: NullableIntFieldUpdateOperationsInput | number | null
    mes?: NullableIntFieldUpdateOperationsInput | number | null
    inicioPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
    finPresentacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clientTaxCreateManyPeriodInput = {
    id?: string
    clientId: string
    estado: string
    notas?: string | null
    displayText?: string | null
    colorTag?: string | null
    fechaCreacion: Date | string
    fechaActualizacion: Date | string
  }

  export type clientTaxUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutClientTaxesNestedInput
    files?: taxFileUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: taxFileUncheckedUpdateManyWithoutClientTaxNestedInput
  }

  export type clientTaxUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    notas?: NullableStringFieldUpdateOperationsInput | string | null
    displayText?: NullableStringFieldUpdateOperationsInput | string | null
    colorTag?: NullableStringFieldUpdateOperationsInput | string | null
    fechaCreacion?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaActualizacion?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type taxFileCreateManyClientTaxInput = {
    id?: string
    nombreArchivo: string
    s3Url: string
    s3Key: string
    tipo?: string | null
    tamanio?: number | null
    fechaSubida: Date | string
    subidoPor?: string | null
  }

  export type taxFileUpdateWithoutClientTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxFileUncheckedUpdateWithoutClientTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxFileUncheckedUpdateManyWithoutClientTaxInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreArchivo?: StringFieldUpdateOperationsInput | string
    s3Url?: StringFieldUpdateOperationsInput | string
    s3Key?: StringFieldUpdateOperationsInput | string
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    tamanio?: NullableIntFieldUpdateOperationsInput | number | null
    fechaSubida?: DateTimeFieldUpdateOperationsInput | Date | string
    subidoPor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clientTaxFilingCreateManyPeriodInput = {
    id?: string
    clientId: string
    taxModelCode: string
    status: string
    notes?: string | null
    presentedAt?: Date | string | null
  }

  export type clientTaxFilingUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneWithoutTaxFilingsNestedInput
  }

  export type clientTaxFilingUncheckedUpdateWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type clientTaxFilingUncheckedUpdateManyWithoutPeriodInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    taxModelCode?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    presentedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
import express, { Request } from 'express';
import { PrismaClient } from '@prisma/client';
import { authenticateToken, checkIsAdmin, AuthRequest } from './middleware/auth.ts';
import { getSocketServer } from './websocket';
import ipLookup from './ip-lookup.ts';

const prisma = new PrismaClient();
const router = express.Router();

// GET /api/admin/sessions
router.get('/', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const { page = 1, size = 50, activeOnly, query, country, device, vpnOnly, suspicious } = req.query as any;
    const where: any = {};
    
    // Por defecto, mostrar solo sesiones activas si no se especifica lo contrario
    if (activeOnly === 'true' || activeOnly === undefined) {
      where.endedAt = null;
    }
    
    if (query) {
      where.OR = [
        { ip: { contains: query } },
        { user: { username: { contains: query } } },
        { user: { email: { contains: query } } },
        { userAgent: { contains: query } },
      ];
    }
    if (country) where.country = country;
    if (device) where.deviceType = device;
    if (vpnOnly === 'true') where.isVpn = true;
    if (suspicious === 'true') where.suspicious = true;

    const take = Number(size) || 50;
    const skip = (Number(page) - 1) * take;

    console.log('ðŸ” Buscando sesiones con filtros:', { where, activeOnly, page, size });

    const p: any = prisma;
    const [items, total] = await Promise.all([
      p.session.findMany({ 
        where, 
        include: { 
          user: { 
            select: { 
              id: true, 
              username: true, 
              email: true,
              role: {
                select: {
                  name: true
                }
              }
            } 
          } 
        }, 
        orderBy: { lastSeenAt: 'desc' }, 
        take, 
        skip 
      }),
      p.session.count({ where }),
    ]);

    console.log(`ðŸ“Š Encontradas ${items.length} sesiones de ${total} total`);

    // Agregar informaciÃ³n adicional a cada sesiÃ³n
    const enrichedItems = items.map((session: any) => {
      const now = new Date();
      const lastSeen = new Date(session.lastSeenAt);
      const minutesSinceLastSeen = Math.floor((now.getTime() - lastSeen.getTime()) / (1000 * 60));
      
      return {
        ...session,
        isActive: !session.endedAt && minutesSinceLastSeen < 5, // Activo si se vio en los Ãºltimos 5 minutos
        minutesSinceLastSeen,
        status: session.endedAt ? 'closed' : (minutesSinceLastSeen < 5 ? 'active' : 'idle'),
        deviceInfo: {
          type: session.deviceType || 'Unknown',
          platform: session.platform || 'Unknown',
          userAgent: session.userAgent?.substring(0, 100) + (session.userAgent?.length > 100 ? '...' : '')
        },
        location: {
          country: session.country || 'Unknown',
          region: session.region || 'Unknown',
          city: session.city || 'Unknown',
          isVpn: session.isVpn || false
        }
      };
    });

    res.json({ items: enrichedItems, total, page: Number(page), size: take });
  } catch (err) {
    console.error('GET /api/admin/sessions error', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// GET /api/admin/sessions/:id
router.get('/:id', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
  const p: any = prisma;
  const session = await p.session.findUnique({ where: { id: req.params.id }, include: { user: true } });
    if (!session) return res.status(404).json({ error: 'Not found' });
    res.json(session);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// POST /api/admin/sessions/:id/terminate
router.post('/:id/terminate', authenticateToken, checkIsAdmin, async (req: AuthRequest, res) => {
  try {
    console.log(`ðŸ”Œ Intentando terminar sesiÃ³n ${req.params.id} por administrador ${req.user?.username}`);
    
    const p: any = prisma;
    const session = await p.session.findUnique({ 
      where: { id: req.params.id },
      include: { user: { select: { username: true } } }
    });
    
    if (!session) {
      console.log(`âŒ SesiÃ³n ${req.params.id} no encontrada`);
      return res.status(404).json({ error: 'SesiÃ³n no encontrada' });
    }

    console.log(`ðŸ“‹ SesiÃ³n encontrada: ${session.user?.username} (${session.socketId})`);

    // Marcar sesiÃ³n como terminada
    await p.session.update({ where: { id: req.params.id }, data: { endedAt: new Date() } });
    console.log(`âœ… SesiÃ³n ${req.params.id} marcada como terminada en BD`);

    // Desconectar socket si estÃ¡ disponible
    const io = getSocketServer();
    if (io && session.socketId) {
      const sock = io.sockets.sockets.get(session.socketId as any);
      if (sock) {
        console.log(`ðŸ”Œ Socket encontrado, enviando notificaciÃ³n y desconectando...`);
        
        // Enviar evento de sesiÃ³n terminada antes de desconectar
        sock.emit('session:terminated', { 
          reason: 'admin_terminated',
          message: 'Tu sesiÃ³n ha sido terminada por un administrador'
        });
        
        // Desconectar el socket
        sock.disconnect(true);
        console.log(`âœ… Socket ${session.socketId} desconectado exitosamente`);
      } else {
        console.log(`âš ï¸ Socket ${session.socketId} no encontrado en servidor`);
      }
    } else {
      console.log(`âš ï¸ No hay socket ID o servidor IO no disponible`);
    }

    // Notificar a administradores
    if (io) {
      io.to('role:Administrador').emit('session:disconnected', { 
        id: req.params.id,
        userId: session.userId,
        terminatedBy: req.user?.username
      });
      console.log(`ðŸ“¢ NotificaciÃ³n enviada a administradores`);
    }

    console.log(`âœ… SesiÃ³n ${req.params.id} terminada completamente por administrador ${req.user?.username}`);
    res.json({ ok: true, message: 'SesiÃ³n terminada exitosamente' });
  } catch (err) {
    console.error('âŒ Error terminando sesiÃ³n:', err);
    res.status(500).json({ error: 'Error interno del servidor' });
  }
});

// POST /api/admin/sessions/:id/flag
router.post('/:id/flag', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
  const p: any = prisma;
  const session = await p.session.update({ where: { id: req.params.id }, data: { suspicious: true } });
    const io = getSocketServer();
    if (io) io.to('admins').emit('session:update', session);
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// POST /api/admin/sessions/:id/unflag
router.post('/:id/unflag', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const p: any = prisma;
    const session = await p.session.update({ where: { id: req.params.id }, data: { suspicious: false } });
    const io = getSocketServer();
    if (io) io.to('admins').emit('session:update', session);
    res.json({ ok: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// POST /api/admin/sessions/terminate-all-for-user/:userId
router.post('/terminate-all-for-user/:userId', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const p: any = prisma;
    const userId = req.params.userId;
    
    // Obtener todas las sesiones activas del usuario
    const activeSessions = await p.session.findMany({
      where: { userId, endedAt: null }
    });
    
    // Terminar todas las sesiones
    await p.session.updateMany({
      where: { userId, endedAt: null },
      data: { endedAt: new Date() }
    });
    
    // Desconectar todos los sockets del usuario
    const io = getSocketServer();
    if (io) {
      activeSessions.forEach((session: any) => {
        if (session.socketId) {
          const sock = io.sockets.sockets.get(session.socketId);
          if (sock) {
            sock.disconnect(true);
          }
        }
      });
      
      io.to('admins').emit('sessions:terminated', { 
        userId, 
        count: activeSessions.length 
      });
    }
    
    res.json({ ok: true, terminatedCount: activeSessions.length });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// GET /api/admin/sessions/stats
router.get('/stats', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const p: any = prisma;
    
    const [
      totalSessions,
      activeSessions,
      suspiciousSessions,
      vpnSessions,
      sessionsByCountry,
      sessionsByDevice
    ] = await Promise.all([
      p.session.count(),
      p.session.count({ where: { endedAt: null } }),
      p.session.count({ where: { suspicious: true } }),
      p.session.count({ where: { isVpn: true } }),
      p.session.groupBy({
        by: ['country'],
        _count: { country: true },
        where: { endedAt: null },
        orderBy: { _count: { country: 'desc' } },
        take: 10
      }),
      p.session.groupBy({
        by: ['deviceType'],
        _count: { deviceType: true },
        where: { endedAt: null },
        orderBy: { _count: { deviceType: 'desc' } },
        take: 10
      })
    ]);
    
    res.json({
      totalSessions,
      activeSessions,
      suspiciousSessions,
      vpnSessions,
      sessionsByCountry,
      sessionsByDevice
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// POST /api/admin/sessions/cleanup
router.post('/cleanup', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const p: any = prisma;
    
    // Eliminar TODAS las sesiones cerradas (no solo las de 7 dÃ­as)
    const closedSessionsResult = await p.session.deleteMany({
      where: {
        endedAt: { not: null }
      }
    });
    
    // Marcar como cerradas las sesiones inactivas por mÃ¡s de 30 minutos
    const thirtyMinutesAgo = new Date();
    thirtyMinutesAgo.setMinutes(thirtyMinutesAgo.getMinutes() - 30);
    
    const inactiveSessionsResult = await p.session.updateMany({
      where: {
        endedAt: null,
        lastSeenAt: { lt: thirtyMinutesAgo }
      },
      data: {
        endedAt: new Date()
      }
    });
    
    console.log(`ðŸ§¹ Limpieza manual: ${closedSessionsResult.count} sesiones cerradas eliminadas, ${inactiveSessionsResult.count} sesiones inactivas marcadas como cerradas`);
    
    res.json({ 
      ok: true, 
      deletedCount: closedSessionsResult.count,
      markedInactiveCount: inactiveSessionsResult.count,
      totalCleaned: closedSessionsResult.count + inactiveSessionsResult.count
    });
  } catch (err) {
    console.error('Error en limpieza de sesiones:', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

// GET /api/admin/sessions/all - Mostrar todas las sesiones (activas y cerradas)
router.get('/all', authenticateToken, checkIsAdmin, async (req, res) => {
  try {
    const { page = 1, size = 50, query, country, device, vpnOnly, suspicious } = req.query as any;
    const where: any = {};
    
    // No filtrar por endedAt para mostrar todas
    
    if (query) {
      where.OR = [
        { ip: { contains: query } },
        { user: { username: { contains: query } } },
        { user: { email: { contains: query } } },
        { userAgent: { contains: query } },
      ];
    }
    if (country) where.country = country;
    if (device) where.deviceType = device;
    if (vpnOnly === 'true') where.isVpn = true;
    if (suspicious === 'true') where.suspicious = true;

    const take = Number(size) || 50;
    const skip = (Number(page) - 1) * take;

    console.log('ðŸ” Buscando TODAS las sesiones con filtros:', { where, page, size });

    const p: any = prisma;
    const [items, total] = await Promise.all([
      p.session.findMany({ 
        where, 
        include: { 
          user: { 
            select: { 
              id: true, 
              username: true, 
              email: true,
              role: {
                select: {
                  name: true
                }
              }
            } 
          } 
        }, 
        orderBy: { lastSeenAt: 'desc' }, 
        take, 
        skip 
      }),
      p.session.count({ where }),
    ]);

    console.log(`ðŸ“Š Encontradas ${items.length} sesiones de ${total} total (todas)`);

    // Agregar informaciÃ³n adicional a cada sesiÃ³n
    const enrichedItems = items.map((session: any) => {
      const now = new Date();
      const lastSeen = new Date(session.lastSeenAt);
      const minutesSinceLastSeen = Math.floor((now.getTime() - lastSeen.getTime()) / (1000 * 60));
      
      return {
        ...session,
        isActive: !session.endedAt && minutesSinceLastSeen < 5,
        minutesSinceLastSeen,
        status: session.endedAt ? 'closed' : (minutesSinceLastSeen < 5 ? 'active' : 'idle'),
        deviceInfo: {
          type: session.deviceType || 'Unknown',
          platform: session.platform || 'Unknown',
          userAgent: session.userAgent?.substring(0, 100) + (session.userAgent?.length > 100 ? '...' : '')
        },
        location: {
          country: session.country || 'Unknown',
          region: session.region || 'Unknown',
          city: session.city || 'Unknown',
          isVpn: session.isVpn || false
        }
      };
    });

    res.json({ items: enrichedItems, total, page: Number(page), size: take });
  } catch (err) {
    console.error('GET /api/admin/sessions/all error', err);
    res.status(500).json({ error: 'Internal error' });
  }
});

export default router;
